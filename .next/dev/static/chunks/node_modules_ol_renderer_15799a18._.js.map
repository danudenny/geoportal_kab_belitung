{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/danudenny/Downloads/geogreen-mapper/node_modules/ol/renderer/vector.js"],"sourcesContent":["/**\n * @module ol/renderer/vector\n */\nimport ImageState from '../ImageState.js';\nimport {getUid} from '../util.js';\n\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nconst SIMPLIFY_TOLERANCE = 0.5;\n\n/**\n * @const\n * @type {Object<import(\"../geom/Geometry.js\").Type,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nconst GEOMETRY_RENDERERS = {\n  'Point': renderPointGeometry,\n  'LineString': renderLineStringGeometry,\n  'Polygon': renderPolygonGeometry,\n  'MultiPoint': renderMultiPointGeometry,\n  'MultiLineString': renderMultiLineStringGeometry,\n  'MultiPolygon': renderMultiPolygonGeometry,\n  'GeometryCollection': renderGeometryCollectionGeometry,\n  'Circle': renderCircleGeometry,\n};\n\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n  const tolerance = getTolerance(resolution, pixelRatio);\n  return tolerance * tolerance;\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n  return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderCircleGeometry(builderGroup, geometry, style, feature, index) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');\n    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    circleReplay.drawCircle(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n * @param {boolean} [declutter] Enable decluttering.\n * @param {number} [index] Render order index..\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  listener,\n  transform,\n  declutter,\n  index,\n) {\n  const loadingPromises = [];\n  const imageStyle = style.getImage();\n  if (imageStyle) {\n    let loading = true;\n    const imageState = imageStyle.getImageState();\n    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n      loading = false;\n    } else {\n      if (imageState == ImageState.IDLE) {\n        imageStyle.load();\n      }\n    }\n    if (loading) {\n      loadingPromises.push(imageStyle.ready());\n    }\n  }\n  const fillStyle = style.getFill();\n  if (fillStyle && fillStyle.loading()) {\n    loadingPromises.push(fillStyle.ready());\n  }\n  const loading = loadingPromises.length > 0;\n  if (loading) {\n    Promise.all(loadingPromises).then(() => listener(null));\n  }\n  renderFeatureInternal(\n    replayGroup,\n    feature,\n    style,\n    squaredTolerance,\n    transform,\n    declutter,\n    index,\n  );\n\n  return loading;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n * @param {boolean} [declutter] Enable decluttering.\n * @param {number} [index] Render order index..\n */\nfunction renderFeatureInternal(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  transform,\n  declutter,\n  index,\n) {\n  const geometry = style.getGeometryFunction()(feature);\n  if (!geometry) {\n    return;\n  }\n  const simplifiedGeometry = geometry.simplifyTransformed(\n    squaredTolerance,\n    transform,\n  );\n  const renderer = style.getRenderer();\n  if (renderer) {\n    renderGeometry(replayGroup, simplifiedGeometry, style, feature, index);\n  } else {\n    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n    geometryRenderer(\n      replayGroup,\n      simplifiedGeometry,\n      style,\n      feature,\n      index,\n      declutter,\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature, index) {\n  if (geometry.getType() == 'GeometryCollection') {\n    const geometries =\n      /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n        geometry\n      ).getGeometries();\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      renderGeometry(replayGroup, geometries[i], style, feature, index);\n    }\n    return;\n  }\n  const replay = replayGroup.getBuilder(style.getZIndex(), 'Default');\n  replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry),\n    feature,\n    style.getRenderer(),\n    style.getHitDetectionRenderer(),\n    index,\n  );\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n * @param {number} [index] Render order index.\n */\nfunction renderGeometryCollectionGeometry(\n  replayGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup,\n  index,\n) {\n  const geometries = geometry.getGeometriesArray();\n  let i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n    geometryRenderer(\n      replayGroup,\n      geometries[i],\n      style,\n      feature,\n      declutterBuilderGroup,\n      index,\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString',\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawLineString(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderMultiLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString',\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawMultiLineString(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderMultiPolygonGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (strokeStyle || fillStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawMultiPolygon(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n * @param {boolean} [declutter] Enable decluttering.\n */\nfunction renderPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n  declutter,\n) {\n  const imageStyle = style.getImage();\n  const textStyle = style.getText();\n  const hasText = textStyle && textStyle.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  const declutterImageWithText =\n    declutter && imageStyle && hasText ? {} : undefined;\n  if (imageStyle) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawPoint(geometry, feature, index);\n  }\n  if (hasText) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n * @param {boolean} [declutter] Enable decluttering.\n */\nfunction renderMultiPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n  declutter,\n) {\n  const imageStyle = style.getImage();\n  const hasImage = imageStyle && imageStyle.getOpacity() !== 0;\n  const textStyle = style.getText();\n  const hasText = textStyle && textStyle.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  const declutterImageWithText =\n    declutter && hasImage && hasText ? {} : undefined;\n  if (hasImage) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawMultiPoint(geometry, feature, index);\n  }\n  if (hasText) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderPolygonGeometry(builderGroup, geometry, style, feature, index) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawPolygon(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 302, "column": 0}, "map": {"version":3,"sources":["file:///home/danudenny/Downloads/geogreen-mapper/node_modules/ol/renderer/Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/Layer\n */\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport EventType from '../events/EventType.js';\nimport {abstract} from '../util.js';\n\nconst maxStaleKeys = 5;\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.staleKeys_ = new Array();\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.maxStaleKeys = maxStaleKeys;\n  }\n\n  /**\n   * @return {Array<string>} Get the list of stale keys.\n   */\n  getStaleKeys() {\n    return this.staleKeys_;\n  }\n\n  /**\n   * @param {string} key The new stale key.\n   */\n  prependStaleKey(key) {\n    this.staleKeys_.unshift(key);\n    if (this.staleKeys_.length > this.maxStaleKeys) {\n      this.staleKeys_.length = this.maxStaleKeys;\n    }\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (\n      image.getState() === ImageState.LOADED ||\n      image.getState() === ImageState.ERROR\n    ) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../Image.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferred(frameState) {}\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;;;;;AAEA,MAAM,eAAe;AAErB;;CAEC,GACD,MAAM,sBAAsB,8IAAU;IACpC;;GAEC,GACD,YAAY,KAAK,CAAE;QACjB,KAAK;QAEL;;;KAGC,GACD,IAAI,CAAC,KAAK,GAAG;QAEb,aAAa,GACb,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI;QAEhE;;;KAGC,GACD,IAAI,CAAC,MAAM,GAAG;QAEd;;;KAGC,GACD,IAAI,CAAC,UAAU,GAAG,IAAI;QAEtB;;;KAGC,GACD,IAAI,CAAC,YAAY,GAAG;IACtB;IAEA;;GAEC,GACD,eAAe;QACb,OAAO,IAAI,CAAC,UAAU;IACxB;IAEA;;GAEC,GACD,gBAAgB,GAAG,EAAE;QACnB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;QACxB,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY,EAAE;YAC9C,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY;QAC5C;IACF;IAEA;;;;;GAKC,GACD,YAAY,KAAK,EAAE;QACjB,OAAO,IAAA,yIAAQ;IACjB;IAEA;;;GAGC,GACD,QAAQ,KAAK,EAAE;QACb,OAAO;IACT;IAEA;;;;;GAKC,GACD,aAAa,UAAU,EAAE;QACvB,OAAO,IAAA,yIAAQ;IACjB;IAEA;;;;;;GAMC,GACD,YAAY,UAAU,EAAE,MAAM,EAAE;QAC9B,OAAO,IAAA,yIAAQ;IACjB;IAEA;;;;;;;;;GASC,GACD,2BACE,UAAU,EACV,UAAU,EACV,YAAY,EACZ,QAAQ,EACR,OAAO,EACP;QACA,OAAO;IACT;IAEA;;GAEC,GACD,WAAW;QACT,OAAO,IAAI,CAAC,MAAM;IACpB;IAEA;;;GAGC,GACD,qBAAqB,CAAC;IAEtB;;;;GAIC,GACD,mBAAmB,KAAK,EAAE;QACxB,MAAM,QAAsD,MAAM,MAAM;QACxE,IACE,MAAM,QAAQ,OAAO,8IAAU,CAAC,MAAM,IACtC,MAAM,QAAQ,OAAO,8IAAU,CAAC,KAAK,EACrC;YACA,IAAI,CAAC,uBAAuB;QAC9B;IACF;IAEA;;;;;;GAMC,GACD,UAAU,KAAK,EAAE;QACf,IAAI,aAAa,MAAM,QAAQ;QAC/B,IAAI,cAAc,8IAAU,CAAC,MAAM,IAAI,cAAc,8IAAU,CAAC,KAAK,EAAE;YACrE,MAAM,gBAAgB,CAAC,uJAAS,CAAC,MAAM,EAAE,IAAI,CAAC,uBAAuB;QACvE;QACA,IAAI,cAAc,8IAAU,CAAC,IAAI,EAAE;YACjC,MAAM,IAAI;YACV,aAAa,MAAM,QAAQ;QAC7B;QACA,OAAO,cAAc,8IAAU,CAAC,MAAM;IACxC;IAEA;;GAEC,GACD,0BAA0B;QACxB,MAAM,QAAQ,IAAI,CAAC,QAAQ;QAC3B,IAAI,SAAS,MAAM,UAAU,MAAM,MAAM,cAAc,OAAO,SAAS;YACrE,MAAM,OAAO;QACf;IACF;IAEA;;GAEC,GACD,eAAe,UAAU,EAAE,CAAC;IAE5B;;;GAGC,GACD,kBAAkB;QAChB,OAAO,IAAI,CAAC,MAAM;QAClB,KAAK,CAAC;IACR;AACF;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 461, "column": 0}, "map": {"version":3,"sources":["file:///home/danudenny/Downloads/geogreen-mapper/node_modules/ol/renderer/canvas/Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/Layer\n */\nimport {equals} from '../../array.js';\nimport {asArray} from '../../color.js';\nimport {createCanvasContext2D, createMockDiv, isCanvas} from '../../dom.js';\nimport {\n  getBottomLeft,\n  getBottomRight,\n  getHeight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n} from '../../extent.js';\nimport {WORKER_OFFSCREEN_CANVAS} from '../../has.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n  equivalent,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport LayerRenderer from '../Layer.js';\n\n/**\n * @type {Array<HTMLCanvasElement|OffscreenCanvas>}\n */\nexport const canvasPool = [];\n\n/**\n * @type {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D}\n */\nlet pixelContext = null;\n\nfunction createPixelContext() {\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\n    willReadFrequently: true,\n  });\n}\n\n/**\n * @abstract\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass CanvasLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * HTMLElement container for the layer to be rendered in.\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.container = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedResolution;\n\n    /**\n     * A temporary transform.  The values in this transform should only be used in a\n     * function that sets the values.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tempTransform = createTransform();\n\n    /**\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.pixelTransform = createTransform();\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform = createTransform();\n\n    /**\n     * @type {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D}\n     */\n    this.context = null;\n\n    /**\n     * @private\n     * @type {ZIndexContext}\n     */\n    this.deferredContext_ = null;\n\n    /**\n     * true if the container has been reused from the previous renderer\n     * @type {boolean}\n     */\n    this.containerReused = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n  }\n\n  /**\n   * @param {import('../../DataTile.js').ImageLike} image Image.\n   * @param {number} col The column index.\n   * @param {number} row The row index.\n   * @return {Uint8ClampedArray|null} The image data.\n   */\n  getImageData(image, col, row) {\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n\n    let data;\n    try {\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import('../../Map.js').FrameState} frameState Frame state.\n   * @return {string} Background color.\n   */\n  getBackground(frameState) {\n    const layer = this.getLayer();\n    let background = layer.getBackground();\n    if (typeof background === 'function') {\n      background = background(frameState.viewState.resolution);\n    }\n    return background || undefined;\n  }\n\n  /**\n   * Get a rendering container from an existing target, if compatible.\n   * @param {HTMLElement} target Potential render target.\n   * @param {string} transform CSS transform matrix.\n   * @param {string} [backgroundColor] Background color.\n   */\n  useContainer(target, transform, backgroundColor) {\n    // renderer canvas to target canvas\n    const layerClassName = this.getLayer().getClassName();\n    let container, context;\n    if (\n      target &&\n      target.className === layerClassName &&\n      (!backgroundColor ||\n        (target &&\n          target.style.backgroundColor &&\n          equals(\n            asArray(target.style.backgroundColor),\n            asArray(backgroundColor),\n          )))\n    ) {\n      const canvas = target.firstElementChild;\n      if (isCanvas(canvas)) {\n        context = canvas.getContext('2d');\n      }\n    }\n    if (context && equivalent(context.canvas.style.transform, transform)) {\n      // Container of the previous layer renderer can be used.\n      this.container = target;\n      this.context = context;\n      this.containerReused = true;\n    } else if (this.containerReused) {\n      // Previously reused container cannot be used any more.\n      this.container = null;\n      this.context = null;\n      this.containerReused = false;\n    } else if (this.container) {\n      this.container.style.backgroundColor = null;\n    }\n    if (!this.container) {\n      container = WORKER_OFFSCREEN_CANVAS\n        ? createMockDiv()\n        : document.createElement('div');\n      container.className = layerClassName;\n      let style = container.style;\n      style.position = 'absolute';\n      style.width = '100%';\n      style.height = '100%';\n      context = createCanvasContext2D();\n      const canvas = /** @type {HTMLCanvasElement} */ (context.canvas);\n      container.appendChild(canvas);\n      style = canvas.style;\n      style.position = 'absolute';\n      style.left = '0';\n      style.transformOrigin = 'top left';\n      this.container = container;\n      this.context = context;\n    }\n    if (\n      !this.containerReused &&\n      backgroundColor &&\n      !this.container.style.backgroundColor\n    ) {\n      this.container.style.backgroundColor = backgroundColor;\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\n   * @protected\n   */\n  clipUnrotated(context, frameState, extent) {\n    const topLeft = getTopLeft(extent);\n    const topRight = getTopRight(extent);\n    const bottomRight = getBottomRight(extent);\n    const bottomLeft = getBottomLeft(extent);\n\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\n\n    const inverted = this.inversePixelTransform;\n    applyTransform(inverted, topLeft);\n    applyTransform(inverted, topRight);\n    applyTransform(inverted, bottomRight);\n    applyTransform(inverted, bottomLeft);\n\n    context.save();\n    context.beginPath();\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\n    context.clip();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @protected\n   */\n  prepareContainer(frameState, target) {\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2,\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    if (!this.containerReused) {\n      const canvas = this.context.canvas;\n      if (canvas.width != width || canvas.height != height) {\n        canvas.width = width;\n        canvas.height = height;\n      } else {\n        this.context.clearRect(0, 0, width, height);\n      }\n      if (\n        canvasTransform !==\n        /** @type {HTMLCanvasElement} */ (canvas).style.transform\n      ) {\n        /** @type {HTMLCanvasElement} */ (canvas).style.transform =\n          canvasTransform;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform,\n        frameState,\n        context,\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.frameState = frameState;\n    if (frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    if (frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferredInternal(frameState) {}\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.\n   */\n  getRenderContext(frameState) {\n    if (frameState.declutter && !this.deferredContext_) {\n      this.deferredContext_ = new ZIndexContext();\n    }\n    return frameState.declutter\n      ? this.deferredContext_.getContext()\n      : this.context;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferred(frameState) {\n    if (!frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(\n      RenderEventType.PRERENDER,\n      this.context,\n      frameState,\n    );\n    if (frameState.declutter && this.deferredContext_) {\n      this.deferredContext_.draw(this.context);\n      this.deferredContext_.clear();\n    }\n    this.renderDeferredInternal(frameState);\n    this.dispatchRenderEvent_(\n      RenderEventType.POSTRENDER,\n      this.context,\n      frameState,\n    );\n  }\n\n  /**\n   * Creates a transform for rendering to an element that will be rotated after rendering.\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} width Width of the rendered element (in pixels).\n   * @param {number} height Height of the rendered element (in pixels).\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!import(\"../../transform.js\").Transform} Transform.\n   */\n  getRenderTransform(\n    center,\n    resolution,\n    rotation,\n    pixelRatio,\n    width,\n    height,\n    offsetX,\n  ) {\n    const dx1 = width / 2;\n    const dy1 = height / 2;\n    const sx = pixelRatio / resolution;\n    const sy = -sx;\n    const dx2 = -center[0] + offsetX;\n    const dy2 = -center[1];\n    return composeTransform(\n      this.tempTransform,\n      dx1,\n      dy1,\n      sx,\n      sy,\n      -rotation,\n      dx2,\n      dy2,\n    );\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    delete this.frameState;\n    super.disposeInternal();\n  }\n}\n\nexport default CanvasLayerRenderer;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 782, "column": 0}, "map": {"version":3,"sources":["file:///home/danudenny/Downloads/geogreen-mapper/node_modules/ol/renderer/canvas/VectorLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport ViewHint from '../../ViewHint.js';\nimport {equals} from '../../array.js';\nimport {wrapX as wrapCoordinateX} from '../../coordinate.js';\nimport {createCanvasContext2D, releaseCanvas} from '../../dom.js';\nimport {\n  buffer,\n  containsExtent,\n  createEmpty,\n  getHeight,\n  getWidth,\n  intersects as intersectsExtent,\n  wrapX as wrapExtentX,\n} from '../../extent.js';\nimport {\n  fromUserExtent,\n  getTransformFromProjections,\n  getUserProjection,\n  toUserExtent,\n  toUserResolution,\n} from '../../proj.js';\nimport RenderEventType from '../../render/EventType.js';\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport ExecutorGroup, {\n  ALL,\n  DECLUTTER,\n  NON_DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {getUid} from '../../util.js';\nimport {\n  defaultOrder as defaultRenderOrder,\n  getSquaredTolerance as getSquaredRenderTolerance,\n  getTolerance as getRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport CanvasLayerRenderer, {canvasPool} from './Layer.js';\n\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\nclass CanvasVectorLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/BaseVector.js\").default} vectorLayer Vector layer.\n   */\n  constructor(vectorLayer) {\n    super(vectorLayer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.animatingOrInteracting_;\n\n    /**\n     * @private\n     * @type {ImageData|null}\n     */\n    this.hitDetectionImageData_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.clipped_ = false;\n\n    /**\n     * @private\n     * @type {Array<import(\"../../Feature.js\").default>}\n     */\n    this.renderedFeatures_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.wrappedRenderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate\").Coordinate}\n     */\n    this.renderedCenter_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection\").default}\n     */\n    this.renderedProjection_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedPixelRatio_ = 1;\n\n    /**\n     * @private\n     * @type {import(\"../../render.js\").OrderFunction|null}\n     */\n    this.renderedRenderOrder_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedFrameDeclutter_;\n\n    /**\n     * @private\n     * @type {import(\"../../render/canvas/ExecutorGroup\").default}\n     */\n    this.replayGroup_ = null;\n\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n    this.replayGroupChanged = true;\n\n    /**\n     * Clipping to be performed by `renderFrame()`\n     * @type {boolean}\n     */\n    this.clipping = true;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D}\n     */\n    this.targetContext_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.opacity_ = 1;\n  }\n\n  /**\n   * @param {ExecutorGroup} executorGroup Executor group.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {boolean} [declutterable] `true` to only render declutterable items,\n   *     `false` to only render non-declutterable items, `undefined` to render all.\n   */\n  renderWorlds(executorGroup, frameState, declutterable) {\n    const extent = frameState.extent;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const rotation = viewState.rotation;\n    const projectionExtent = projection.getExtent();\n    const vectorSource = this.getLayer().getSource();\n    const declutter = this.getLayer().getDeclutter();\n    const pixelRatio = frameState.pixelRatio;\n    const viewHints = frameState.viewHints;\n    const snapToPixel = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const context = this.context;\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n    let world = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n    do {\n      let transform = this.getRenderTransform(\n        center,\n        resolution,\n        0,\n        pixelRatio,\n        width,\n        height,\n        world * worldWidth,\n      );\n      if (frameState.declutter) {\n        transform = transform.slice(0);\n      }\n      executorGroup.execute(\n        context,\n        [context.canvas.width, context.canvas.height],\n        transform,\n        rotation,\n        snapToPixel,\n        declutterable === undefined\n          ? ALL\n          : declutterable\n            ? DECLUTTER\n            : NON_DECLUTTER,\n        declutterable\n          ? declutter && frameState.declutter[declutter]\n          : undefined,\n      );\n    } while (++world < endWorld);\n  }\n\n  /**\n   * @private\n   */\n  setDrawContext_() {\n    if (this.opacity_ !== 1) {\n      this.targetContext_ = this.context;\n      this.context = createCanvasContext2D(\n        this.context.canvas.width,\n        this.context.canvas.height,\n        canvasPool,\n      );\n    }\n  }\n\n  /**\n   * @private\n   */\n  resetDrawContext_() {\n    if (this.opacity_ !== 1 && this.targetContext_) {\n      const alpha = this.targetContext_.globalAlpha;\n      this.targetContext_.globalAlpha = this.opacity_;\n      this.targetContext_.drawImage(this.context.canvas, 0, 0);\n      this.targetContext_.globalAlpha = alpha;\n      releaseCanvas(this.context);\n      canvasPool.push(this.context.canvas);\n      this.context = this.targetContext_;\n      this.targetContext_ = null;\n    }\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    if (!this.replayGroup_ || !this.getLayer().getDeclutter()) {\n      return;\n    }\n    this.renderWorlds(this.replayGroup_, frameState, true);\n  }\n\n  /**\n   * Render deferred instructions.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferredInternal(frameState) {\n    if (!this.replayGroup_) {\n      return;\n    }\n    this.replayGroup_.renderDeferred();\n    if (this.clipped_) {\n      this.context.restore();\n    }\n    this.resetDrawContext_();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    this.opacity_ = layerState.opacity;\n    const viewState = frameState.viewState;\n\n    this.prepareContainer(frameState, target);\n    const context = this.context;\n\n    const replayGroup = this.replayGroup_;\n    let render = replayGroup && !replayGroup.isEmpty();\n    if (!render) {\n      const hasRenderListeners =\n        this.getLayer().hasListener(RenderEventType.PRERENDER) ||\n        this.getLayer().hasListener(RenderEventType.POSTRENDER);\n      if (!hasRenderListeners) {\n        return this.container;\n      }\n    }\n\n    this.setDrawContext_();\n\n    this.preRender(context, frameState);\n\n    const projection = viewState.projection;\n\n    // clipped rendering if layer extent is set\n    this.clipped_ = false;\n    if (render && layerState.extent && this.clipping) {\n      const layerExtent = fromUserExtent(layerState.extent, projection);\n      render = intersectsExtent(layerExtent, frameState.extent);\n      this.clipped_ = render && !containsExtent(layerExtent, frameState.extent);\n      if (this.clipped_) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    if (render) {\n      this.renderWorlds(\n        replayGroup,\n        frameState,\n        this.getLayer().getDeclutter() ? false : undefined,\n      );\n    }\n\n    if (!frameState.declutter && this.clipped_) {\n      context.restore();\n    }\n\n    this.postRender(context, frameState);\n\n    if (this.renderedRotation_ !== viewState.rotation) {\n      this.renderedRotation_ = viewState.rotation;\n      this.hitDetectionImageData_ = null;\n    }\n    if (!frameState.declutter) {\n      this.resetDrawContext_();\n    }\n    return this.container;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise\n   * that resolves with an array of features.\n   * @override\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve) => {\n      if (\n        this.frameState &&\n        !this.hitDetectionImageData_ &&\n        !this.animatingOrInteracting_\n      ) {\n        const size = this.frameState.size.slice();\n        const center = this.renderedCenter_;\n        const resolution = this.renderedResolution_;\n        const rotation = this.renderedRotation_;\n        const projection = this.renderedProjection_;\n        const extent = this.wrappedRenderedExtent_;\n        const layer = this.getLayer();\n        const transforms = [];\n        const width = size[0] * HIT_DETECT_RESOLUTION;\n        const height = size[1] * HIT_DETECT_RESOLUTION;\n        transforms.push(\n          this.getRenderTransform(\n            center,\n            resolution,\n            rotation,\n            HIT_DETECT_RESOLUTION,\n            width,\n            height,\n            0,\n          ).slice(),\n        );\n        const source = layer.getSource();\n        const projectionExtent = projection.getExtent();\n        if (\n          source.getWrapX() &&\n          projection.canWrapX() &&\n          !containsExtent(projectionExtent, extent)\n        ) {\n          let startX = extent[0];\n          const worldWidth = getWidth(projectionExtent);\n          let world = 0;\n          let offsetX;\n          while (startX < projectionExtent[0]) {\n            --world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX,\n              ).slice(),\n            );\n            startX += worldWidth;\n          }\n          world = 0;\n          startX = extent[2];\n          while (startX > projectionExtent[2]) {\n            ++world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX,\n              ).slice(),\n            );\n            startX -= worldWidth;\n          }\n        }\n        const userProjection = getUserProjection();\n        this.hitDetectionImageData_ = createHitDetectionImageData(\n          size,\n          transforms,\n          this.renderedFeatures_,\n          layer.getStyleFunction(),\n          extent,\n          resolution,\n          rotation,\n          getSquaredRenderTolerance(resolution, this.renderedPixelRatio_),\n          userProjection ? projection : null,\n        );\n      }\n      resolve(\n        hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_),\n      );\n    });\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    if (!this.replayGroup_) {\n      return undefined;\n    }\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const layer = this.getLayer();\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      const key = getUid(feature);\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const declutter = this.getLayer().getDeclutter();\n    return this.replayGroup_.forEachFeatureAtCoordinate(\n      coordinate,\n      resolution,\n      rotation,\n      hitTolerance,\n      featureCallback,\n      declutter\n        ? frameState.declutter?.[declutter]?.all().map((item) => item.value)\n        : null,\n    );\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @override\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const vectorLayer = this.getLayer();\n    const vectorSource = vectorLayer.getSource();\n    if (!vectorSource) {\n      return false;\n    }\n\n    const animating = frameState.viewHints[ViewHint.ANIMATING];\n    const interacting = frameState.viewHints[ViewHint.INTERACTING];\n    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (\n      (this.ready && !updateWhileAnimating && animating) ||\n      (!updateWhileInteracting && interacting)\n    ) {\n      this.animatingOrInteracting_ = true;\n      return true;\n    }\n    this.animatingOrInteracting_ = false;\n\n    const frameStateExtent = frameState.extent;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const resolution = viewState.resolution;\n    const pixelRatio = frameState.pixelRatio;\n    const vectorLayerRevision = vectorLayer.getRevision();\n    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n\n    const center = viewState.center.slice();\n    const extent = buffer(\n      frameStateExtent,\n      vectorLayerRenderBuffer * resolution,\n    );\n    const renderedExtent = extent.slice();\n    const loadExtents = [extent.slice()];\n    const projectionExtent = projection.getExtent();\n\n    if (\n      vectorSource.getWrapX() &&\n      projection.canWrapX() &&\n      !containsExtent(projectionExtent, frameState.extent)\n    ) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180 to +180). To support geometries in a coordinate range from -540\n      // to +540, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      const worldWidth = getWidth(projectionExtent);\n      const gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n      wrapCoordinateX(center, projection);\n      const loadExtent = wrapExtentX(loadExtents[0], projection);\n      // If the extent crosses the date line, we load data for both edges of the worlds\n      if (\n        loadExtent[0] < projectionExtent[0] &&\n        loadExtent[2] < projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] + worldWidth,\n          loadExtent[1],\n          loadExtent[2] + worldWidth,\n          loadExtent[3],\n        ]);\n      } else if (\n        loadExtent[0] > projectionExtent[0] &&\n        loadExtent[2] > projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] - worldWidth,\n          loadExtent[1],\n          loadExtent[2] - worldWidth,\n          loadExtent[3],\n        ]);\n      }\n    }\n\n    if (\n      this.ready &&\n      this.renderedResolution_ == resolution &&\n      this.renderedRevision_ == vectorLayerRevision &&\n      this.renderedRenderOrder_ == vectorLayerRenderOrder &&\n      this.renderedFrameDeclutter_ === !!frameState.declutter &&\n      containsExtent(this.wrappedRenderedExtent_, extent)\n    ) {\n      if (!equals(this.renderedExtent_, renderedExtent)) {\n        this.hitDetectionImageData_ = null;\n        this.renderedExtent_ = renderedExtent;\n      }\n      this.renderedCenter_ = center;\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n\n    const replayGroup = new CanvasBuilderGroup(\n      getRenderTolerance(resolution, pixelRatio),\n      extent,\n      resolution,\n      pixelRatio,\n    );\n\n    const userProjection = getUserProjection();\n    let userTransform;\n    if (userProjection) {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        const extent = loadExtents[i];\n        const userExtent = toUserExtent(extent, projection);\n        vectorSource.loadFeatures(\n          userExtent,\n          toUserResolution(resolution, projection),\n          userProjection,\n        );\n      }\n      userTransform = getTransformFromProjections(userProjection, projection);\n    } else {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        vectorSource.loadFeatures(loadExtents[i], resolution, projection);\n      }\n    }\n\n    const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n    let ready = true;\n    const render =\n      /**\n       * @param {import(\"../../Feature.js\").default} feature Feature.\n       * @param {number} index Index.\n       */\n      (feature, index) => {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || vectorLayer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            replayGroup,\n            userTransform,\n            this.getLayer().getDeclutter(),\n            index,\n          );\n          ready = ready && !dirty;\n        }\n      };\n\n    const userExtent = toUserExtent(extent, projection);\n    /** @type {Array<import(\"../../Feature.js\").default>} */\n    const features = vectorSource.getFeaturesInExtent(userExtent);\n    if (vectorLayerRenderOrder) {\n      features.sort(vectorLayerRenderOrder);\n    }\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      render(features[i], i);\n    }\n    this.renderedFeatures_ = features;\n    this.ready = ready;\n\n    const replayGroupInstructions = replayGroup.finish();\n    const executorGroup = new ExecutorGroup(\n      extent,\n      resolution,\n      pixelRatio,\n      vectorSource.getOverlaps(),\n      replayGroupInstructions,\n      vectorLayer.getRenderBuffer(),\n      !!frameState.declutter,\n    );\n\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedFrameDeclutter_ = !!frameState.declutter;\n    this.renderedExtent_ = renderedExtent;\n    this.wrappedRenderedExtent_ = extent;\n    this.renderedCenter_ = center;\n    this.renderedProjection_ = projection;\n    this.renderedPixelRatio_ = pixelRatio;\n    this.replayGroup_ = executorGroup;\n    this.hitDetectionImageData_ = null;\n\n    this.replayGroupChanged = true;\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} squaredTolerance Squared render tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n   * @param {import(\"../../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    transform,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            transform,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        transform,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n}\n\nexport default CanvasVectorLayerRenderer;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1312, "column": 0}, "map": {"version":3,"sources":["file:///home/danudenny/Downloads/geogreen-mapper/node_modules/ol/renderer/Map.js"],"sourcesContent":["/**\n * @module ol/renderer/Map\n */\nimport Disposable from '../Disposable.js';\nimport {wrapX} from '../coordinate.js';\nimport {getWidth} from '../extent.js';\nimport {TRUE} from '../functions.js';\nimport {inView} from '../layer/Layer.js';\nimport {shared as iconImageCache} from '../style/IconImageCache.js';\nimport {compose as composeTransform, makeInverse} from '../transform.js';\nimport {abstract} from '../util.js';\n\n/**\n * @template T\n * @typedef HitMatch\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} distanceSq Squared distance.\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\n */\n\n/**\n * @abstract\n */\nclass MapRenderer extends Disposable {\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  constructor(map) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default}\n     */\n    this.map_ = map;\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  dispatchRenderEvent(type, frameState) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @protected\n   */\n  calculateMatrices2D(frameState) {\n    const viewState = frameState.viewState;\n    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n\n    composeTransform(\n      coordinateToPixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / viewState.resolution,\n      -1 / viewState.resolution,\n      -viewState.rotation,\n      -viewState.center[0],\n      -viewState.center[1],\n    );\n\n    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    checkWrapped,\n    callback,\n    thisArg,\n    layerFilter,\n    thisArg2,\n  ) {\n    let result;\n    const viewState = frameState.viewState;\n\n    /**\n     * @param {boolean} managed Managed layer.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../layer/Layer.js\").default} layer Layer.\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @return {T|undefined} Callback result.\n     */\n    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n      return callback.call(thisArg, feature, managed ? layer : null, geometry);\n    }\n\n    const projection = viewState.projection;\n\n    const translatedCoordinate = wrapX(coordinate.slice(), projection);\n    const offsets = [[0, 0]];\n    if (projection.canWrapX() && checkWrapped) {\n      const projectionExtent = projection.getExtent();\n      const worldWidth = getWidth(projectionExtent);\n      offsets.push([-worldWidth, 0], [worldWidth, 0]);\n    }\n\n    const layerStates = frameState.layerStatesArray;\n    const numLayers = layerStates.length;\n\n    const matches = /** @type {Array<HitMatch<T>>} */ ([]);\n    const tmpCoord = [];\n    for (let i = 0; i < offsets.length; i++) {\n      for (let j = numLayers - 1; j >= 0; --j) {\n        const layerState = layerStates[j];\n        const layer = layerState.layer;\n        if (\n          layer.hasRenderer() &&\n          inView(layerState, viewState) &&\n          layerFilter.call(thisArg2, layer)\n        ) {\n          const layerRenderer = layer.getRenderer();\n          const source = layer.getSource();\n          if (layerRenderer && source) {\n            const coordinates = source.getWrapX()\n              ? translatedCoordinate\n              : coordinate;\n            const callback = forEachFeatureAtCoordinate.bind(\n              null,\n              layerState.managed,\n            );\n            tmpCoord[0] = coordinates[0] + offsets[i][0];\n            tmpCoord[1] = coordinates[1] + offsets[i][1];\n            result = layerRenderer.forEachFeatureAtCoordinate(\n              tmpCoord,\n              frameState,\n              hitTolerance,\n              callback,\n              matches,\n            );\n          }\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    if (matches.length === 0) {\n      return undefined;\n    }\n    const order = 1 / matches.length;\n    matches.forEach((m, i) => (m.distanceSq += i * order));\n    matches.sort((a, b) => a.distanceSq - b.distanceSq);\n    matches.some((m) => {\n      return (result = m.callback(m.feature, m.layer, m.geometry));\n    });\n    return result;\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n   * @return {boolean} Is there a feature at the given coordinate?\n   * @template U\n   */\n  hasFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    checkWrapped,\n    layerFilter,\n    thisArg,\n  ) {\n    const hasFeature = this.forEachFeatureAtCoordinate(\n      coordinate,\n      frameState,\n      hitTolerance,\n      checkWrapped,\n      TRUE,\n      this,\n      layerFilter,\n      thisArg,\n    );\n\n    return hasFeature !== undefined;\n  }\n\n  /**\n   * @return {import(\"../Map.js\").default} Map.\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\n   * Render.\n   * @abstract\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderFrame(frameState) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  scheduleExpireIconCache(frameState) {\n    if (iconImageCache.canExpireCache()) {\n      frameState.postRenderFunctions.push(expireIconCache);\n    }\n  }\n}\n\n/**\n * @param {import(\"../Map.js\").default} map Map.\n * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n */\nfunction expireIconCache(map, frameState) {\n  iconImageCache.expire();\n}\n\nexport default MapRenderer;\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;;;;;;;;CAQC,GAED;;CAEC,GACD,MAAM,oBAAoB,8IAAU;IAClC;;GAEC,GACD,YAAY,GAAG,CAAE;QACf,KAAK;QAEL;;;KAGC,GACD,IAAI,CAAC,IAAI,GAAG;IACd;IAEA;;;;GAIC,GACD,oBAAoB,IAAI,EAAE,UAAU,EAAE;QACpC,IAAA,yIAAQ;IACV;IAEA;;;GAGC,GACD,oBAAoB,UAAU,EAAE;QAC9B,MAAM,YAAY,WAAW,SAAS;QACtC,MAAM,6BAA6B,WAAW,0BAA0B;QACxE,MAAM,6BAA6B,WAAW,0BAA0B;QAExE,IAAA,6IAAgB,EACd,4BACA,WAAW,IAAI,CAAC,EAAE,GAAG,GACrB,WAAW,IAAI,CAAC,EAAE,GAAG,GACrB,IAAI,UAAU,UAAU,EACxB,CAAC,IAAI,UAAU,UAAU,EACzB,CAAC,UAAU,QAAQ,EACnB,CAAC,UAAU,MAAM,CAAC,EAAE,EACpB,CAAC,UAAU,MAAM,CAAC,EAAE;QAGtB,IAAA,iJAAW,EAAC,4BAA4B;IAC1C;IAEA;;;;;;;;;;;;;;GAcC,GACD,2BACE,UAAU,EACV,UAAU,EACV,YAAY,EACZ,YAAY,EACZ,QAAQ,EACR,OAAO,EACP,WAAW,EACX,QAAQ,EACR;QACA,IAAI;QACJ,MAAM,YAAY,WAAW,SAAS;QAEtC;;;;;;KAMC,GACD,SAAS,2BAA2B,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,QAAQ;YACnE,OAAO,SAAS,IAAI,CAAC,SAAS,SAAS,UAAU,QAAQ,MAAM;QACjE;QAEA,MAAM,aAAa,UAAU,UAAU;QAEvC,MAAM,uBAAuB,IAAA,4IAAK,EAAC,WAAW,KAAK,IAAI;QACvD,MAAM,UAAU;YAAC;gBAAC;gBAAG;aAAE;SAAC;QACxB,IAAI,WAAW,QAAQ,MAAM,cAAc;YACzC,MAAM,mBAAmB,WAAW,SAAS;YAC7C,MAAM,aAAa,IAAA,2IAAQ,EAAC;YAC5B,QAAQ,IAAI,CAAC;gBAAC,CAAC;gBAAY;aAAE,EAAE;gBAAC;gBAAY;aAAE;QAChD;QAEA,MAAM,cAAc,WAAW,gBAAgB;QAC/C,MAAM,YAAY,YAAY,MAAM;QAEpC,MAAM,UAA6C,EAAE;QACrD,MAAM,WAAW,EAAE;QACnB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAAK;YACvC,IAAK,IAAI,IAAI,YAAY,GAAG,KAAK,GAAG,EAAE,EAAG;gBACvC,MAAM,aAAa,WAAW,CAAC,EAAE;gBACjC,MAAM,QAAQ,WAAW,KAAK;gBAC9B,IACE,MAAM,WAAW,MACjB,IAAA,iJAAM,EAAC,YAAY,cACnB,YAAY,IAAI,CAAC,UAAU,QAC3B;oBACA,MAAM,gBAAgB,MAAM,WAAW;oBACvC,MAAM,SAAS,MAAM,SAAS;oBAC9B,IAAI,iBAAiB,QAAQ;wBAC3B,MAAM,cAAc,OAAO,QAAQ,KAC/B,uBACA;wBACJ,MAAM,WAAW,2BAA2B,IAAI,CAC9C,MACA,WAAW,OAAO;wBAEpB,QAAQ,CAAC,EAAE,GAAG,WAAW,CAAC,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC,EAAE;wBAC5C,QAAQ,CAAC,EAAE,GAAG,WAAW,CAAC,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC,EAAE;wBAC5C,SAAS,cAAc,0BAA0B,CAC/C,UACA,YACA,cACA,UACA;oBAEJ;oBACA,IAAI,QAAQ;wBACV,OAAO;oBACT;gBACF;YACF;QACF;QACA,IAAI,QAAQ,MAAM,KAAK,GAAG;YACxB,OAAO;QACT;QACA,MAAM,QAAQ,IAAI,QAAQ,MAAM;QAChC,QAAQ,OAAO,CAAC,CAAC,GAAG,IAAO,EAAE,UAAU,IAAI,IAAI;QAC/C,QAAQ,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,UAAU,GAAG,EAAE,UAAU;QAClD,QAAQ,IAAI,CAAC,CAAC;YACZ,OAAQ,SAAS,EAAE,QAAQ,CAAC,EAAE,OAAO,EAAE,EAAE,KAAK,EAAE,EAAE,QAAQ;QAC5D;QACA,OAAO;IACT;IAEA;;;;;;;;;;;;GAYC,GACD,uBACE,UAAU,EACV,UAAU,EACV,YAAY,EACZ,YAAY,EACZ,WAAW,EACX,OAAO,EACP;QACA,MAAM,aAAa,IAAI,CAAC,0BAA0B,CAChD,YACA,YACA,cACA,cACA,0IAAI,EACJ,IAAI,EACJ,aACA;QAGF,OAAO,eAAe;IACxB;IAEA;;GAEC,GACD,SAAS;QACP,OAAO,IAAI,CAAC,IAAI;IAClB;IAEA;;;;GAIC,GACD,YAAY,UAAU,EAAE;QACtB,IAAA,yIAAQ;IACV;IAEA;;;GAGC,GACD,wBAAwB,UAAU,EAAE;QAClC,IAAI,0JAAc,CAAC,cAAc,IAAI;YACnC,WAAW,mBAAmB,CAAC,IAAI,CAAC;QACtC;IACF;AACF;AAEA;;;CAGC,GACD,SAAS,gBAAgB,GAAG,EAAE,UAAU;IACtC,0JAAc,CAAC,MAAM;AACvB;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 1502, "column": 0}, "map": {"version":3,"sources":["file:///home/danudenny/Downloads/geogreen-mapper/node_modules/ol/renderer/Composite.js"],"sourcesContent":["/**\n * @module ol/renderer/Composite\n */\nimport ObjectEventType from '../ObjectEventType.js';\nimport {CLASS_UNSELECTABLE} from '../css.js';\nimport {createMockDiv, isCanvas, replaceChildren} from '../dom.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {WORKER_OFFSCREEN_CANVAS} from '../has.js';\nimport BaseVectorLayer from '../layer/BaseVector.js';\nimport {inView} from '../layer/Layer.js';\nimport RenderEvent from '../render/Event.js';\nimport RenderEventType from '../render/EventType.js';\nimport {checkedFonts} from '../render/canvas.js';\nimport {fromString} from '../transform.js';\nimport MapRenderer from './Map.js';\n\n/**\n * @classdesc\n * Canvas map renderer.\n * @api\n */\nclass CompositeMapRenderer extends MapRenderer {\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  constructor(map) {\n    super(map);\n\n    /**\n     * @private\n     * @type {import(\"../events.js\").EventsKey}\n     */\n    this.fontChangeListenerKey_ = listen(\n      checkedFonts,\n      ObjectEventType.PROPERTYCHANGE,\n      map.redrawText,\n      map,\n    );\n\n    /**\n     * @private\n     * @type {HTMLDivElement}\n     */\n    this.element_ = WORKER_OFFSCREEN_CANVAS\n      ? createMockDiv()\n      : document.createElement('div');\n    const style = this.element_.style;\n    style.position = 'absolute';\n    style.width = '100%';\n    style.height = '100%';\n    style.zIndex = '0';\n\n    this.element_.className = CLASS_UNSELECTABLE + ' ol-layers';\n\n    const container = map.getViewport();\n    if (container) {\n      // maps in a worker do not have a viewport.\n      container.insertBefore(this.element_, container.firstChild || null);\n    }\n\n    /**\n     * @private\n     * @type {Array<HTMLElement>}\n     */\n    this.children_ = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedVisible_ = true;\n  }\n\n  /**\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  dispatchRenderEvent(type, frameState) {\n    const map = this.getMap();\n    if (map.hasListener(type)) {\n      const event = new RenderEvent(type, undefined, frameState);\n      map.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    unlistenByKey(this.fontChangeListenerKey_);\n    this.element_.remove();\n    super.disposeInternal();\n  }\n\n  /**\n   * Render.\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderFrame(frameState) {\n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.element_.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n\n    this.calculateMatrices2D(frameState);\n    this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);\n\n    const layerStatesArray = frameState.layerStatesArray.sort(\n      (a, b) => a.zIndex - b.zIndex,\n    );\n    const declutter = layerStatesArray.some(\n      (layerState) =>\n        layerState.layer instanceof BaseVectorLayer &&\n        layerState.layer.getDeclutter(),\n    );\n    if (declutter) {\n      // Some layers need decluttering, turn on deferred rendering hint\n      frameState.declutter = {};\n    }\n    const viewState = frameState.viewState;\n\n    this.children_.length = 0;\n\n    const renderedLayerStates = [];\n    let previousElement = null;\n    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      const layerState = layerStatesArray[i];\n      frameState.layerIndex = i;\n\n      const layer = layerState.layer;\n      const sourceState = layer.getSourceState();\n      if (\n        !inView(layerState, viewState) ||\n        (sourceState != 'ready' && sourceState != 'undefined')\n      ) {\n        layer.unrender();\n        continue;\n      }\n\n      const element = layer.render(frameState, previousElement);\n      if (!element) {\n        continue;\n      }\n      if (element !== previousElement) {\n        this.children_.push(element);\n        previousElement = element;\n      }\n\n      renderedLayerStates.push(layerState);\n    }\n\n    this.declutter(frameState, renderedLayerStates);\n\n    replaceChildren(this.element_, this.children_);\n\n    const map = this.getMap();\n    const mapCanvas = map.getTargetElement();\n    if (isCanvas(mapCanvas)) {\n      // Canvas composition when container is a canvas\n      const mapContext = mapCanvas.getContext('2d');\n      for (const container of this.children_) {\n        const canvas = container.firstElementChild || container;\n        const backgroundColor = container.style.backgroundColor;\n        if (backgroundColor && (!isCanvas(canvas) || canvas.width > 0)) {\n          mapContext.fillStyle = backgroundColor;\n          mapContext.fillRect(0, 0, mapCanvas.width, mapCanvas.height);\n        }\n        if (isCanvas(canvas) && canvas.width > 0) {\n          const opacity = container.style.opacity || canvas.style.opacity;\n          mapContext.globalAlpha = opacity === '' ? 1 : Number(opacity);\n          const transform = canvas.style.transform;\n          if (transform) {\n            // Get the transform parameters from the style's transform matrix\n            mapContext.setTransform(\n              .../** @type {[number, number, number, number, number, number]} */ (\n                fromString(transform)\n              ),\n            );\n          } else {\n            const w = parseFloat(canvas.style.width) / canvas.width;\n            const h = parseFloat(canvas.style.height) / canvas.height;\n            mapContext.setTransform(w, 0, 0, h, 0, 0);\n          }\n          mapContext.drawImage(canvas, 0, 0);\n        }\n      }\n      mapContext.globalAlpha = 1;\n      mapContext.setTransform(1, 0, 0, 1, 0, 0);\n    }\n\n    this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);\n\n    if (!this.renderedVisible_) {\n      this.element_.style.display = '';\n      this.renderedVisible_ = true;\n    }\n\n    this.scheduleExpireIconCache(frameState);\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.\n   */\n  declutter(frameState, layerStates) {\n    if (!frameState.declutter) {\n      return;\n    }\n    for (let i = layerStates.length - 1; i >= 0; --i) {\n      const layerState = layerStates[i];\n      const layer = layerState.layer;\n      if (layer.getDeclutter()) {\n        layer.renderDeclutter(frameState, layerState);\n      }\n    }\n    layerStates.forEach((layerState) =>\n      layerState.layer.renderDeferred(frameState),\n    );\n  }\n}\n\nexport default CompositeMapRenderer;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1694, "column": 0}, "map": {"version":3,"sources":["file:///home/danudenny/Downloads/geogreen-mapper/node_modules/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {equivalent, fromUserExtent} from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport {toSize} from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport {\n  createOrUpdate as createTileCoord,\n  getCacheKey,\n} from '../../tilecoord.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default|null>}\n     * @private\n     */\n    this.sourceTileCache_ = null;\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getSourceTileCache() {\n    if (!this.sourceTileCache_) {\n      this.sourceTileCache_ = new LRUCache(512);\n    }\n    return this.sourceTileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource, tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      const projection = frameState.viewState.projection;\n      const sourceProjection = tileSource.getProjection();\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        projection,\n        !sourceProjection || equivalent(sourceProjection, projection)\n          ? undefined\n          : this.getSourceTileCache(),\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedSourceRevision_) {\n      this.renderedSourceRevision_ = sourceRevision;\n    } else if (this.renderedSourceRevision_ !== sourceRevision) {\n      this.renderedSourceRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n        this.sourceTileCache_?.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determine whether tiles for next extent should be enqueued for rendering.\n   * @return {boolean} Rendering tiles for next extent is supported.\n   * @protected\n   */\n  enqueueTilesForNextExtent() {\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    const rotation = viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(\n        this.getLayer().getSource(),\n        staleKeys[i],\n        z,\n        x,\n        y,\n      );\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    this.renderComplete = true;\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent && this.enqueueTilesForNextExtent()) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n        this.sourceTileCache_?.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n\n    // this normally is `div.ol-layer` and is a mocked div in worker\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement|OffscreenCanvas} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|OffscreenCanvas|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2444, "column": 0}, "map": {"version":3,"sources":["file:///home/danudenny/Downloads/geogreen-mapper/node_modules/ol/renderer/canvas/VectorTileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {ascending} from '../../array.js';\nimport {wrapX} from '../../coordinate.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {equivalent, getTransform, transformExtent} from '../../proj.js';\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup, {\n  DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {toSize} from '../../size.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default<import('../../source/VectorTile.js').default<import('../../Feature.js').FeatureLike>>>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   * @param {import(\"./TileLayer.js\").Options} options Options.\n   */\n  constructor(layer, options) {\n    super(layer, options);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedOpacity_ = 1;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<ZIndexContext>}\n     */\n    this.tileClipContexts_ = null;\n  }\n\n  /**\n   * Determine whether tiles for next extent should be enqueued for rendering.\n   * @return {boolean} Rendering tiles for next extent is supported.\n   * @override\n   */\n  enqueueTilesForNextExtent() {\n    return this.getLayer().getRenderMode() !== 'vector';\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @override\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    this.updateExecutorGroup_(\n      tile,\n      frameState.pixelRatio,\n      frameState.viewState.projection,\n    );\n    if (this.tileImageNeedsRender_(tile)) {\n      this.renderTileImage_(tile, frameState);\n    }\n    super.drawTile(tile, frameState, x, y, w, h, gutter, transition);\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, frameState) {\n    const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n      this.getOrCreateTile(z, x, y, frameState)\n    );\n    if (!tile) {\n      return null;\n    }\n\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const viewHints = frameState.viewHints;\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const withinTileResolutionRange =\n      tileGrid.getZForResolution(resolution, source.zDirection) === z;\n    if (hifi && withinTileResolutionRange) {\n      tile.wantedResolution = resolution;\n    } else if (!tile.wantedResolution) {\n      tile.wantedResolution = tileGrid.getResolution(z);\n    }\n\n    return tile;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = !!layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceProjection = source.getProjection();\n      const sourceTileCoord = sourceTile.tileCoord;\n      let sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      if (\n        projection &&\n        sourceProjection &&\n        !equivalent(projection, sourceProjection)\n      ) {\n        sourceTileExtent = transformExtent(\n          sourceTileExtent,\n          sourceProjection,\n          projection,\n          32,\n        );\n      }\n\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tempExtent,\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        sharedExtent,\n        resolution,\n        pixelRatio,\n      );\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio,\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {number} [index] Render order index.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature, index) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutter,\n            index,\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        let feature = features[i];\n        if (\n          projection &&\n          sourceTile.projection &&\n          !equivalent(projection, sourceTile.projection)\n        ) {\n          feature = feature.clone();\n          feature\n            .getGeometry()\n            .applyTransform(getTransform(sourceTile.projection, projection));\n        }\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature, i);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer(),\n        true,\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const layerUid = getUid(layer);\n    const declutter = layer.getDeclutter();\n    const declutteredFeatures = declutter\n      ? frameState.declutter?.[declutter]?.all().map((item) => item.value)\n      : null;\n    let found;\n    foundFeature: for (let i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const executorGroups = tile.executorGroups[layerUid];\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        found = executorGroups[t].forEachFeatureAtCoordinate(\n          coordinate,\n          resolution,\n          rotation,\n          hitTolerance,\n          featureCallback,\n          declutteredFeatures,\n        );\n        if (found) {\n          break foundFeature;\n        }\n      }\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   * @override\n   */\n  getFeatures(pixel) {\n    if (this.renderedTiles.length === 0) {\n      return Promise.resolve([]);\n    }\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice(),\n      );\n      const tileCoordString = tileGrid\n        .getTileCoordForCoordAndResolution(coordinate, resolution)\n        .toString();\n      const tile =\n        /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n          this.renderedTiles\n        ).find(\n          (tile) =>\n            tile.tileCoord.toString() === tileCoordString &&\n            tile.getState() === TileState.LOADED,\n        );\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      if (\n        source.getWrapX() &&\n        projection.canWrapX() &&\n        !containsExtent(\n          projectionExtent,\n          tileGrid.getTileCoordExtent(tile.tileCoord),\n        )\n      ) {\n        wrapX(coordinate, projection);\n      }\n      const layerUid = getUid(layer);\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      const features = tile\n        .getSourceTiles()\n        .reduce(\n          (accumulator, sourceTile) =>\n            accumulator.concat(sourceTile.getFeatures()),\n          /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */ ([]),\n        );\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection),\n          ),\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0,\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation,\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @return {Array<import('../../Feature.js').FeatureLike>} Features.\n   */\n  getFeaturesInExtent(extent) {\n    /** @type {Array<import('../../Feature.js').FeatureLike>} */\n    const features = [];\n    const tileCache = this.getTileCache();\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      this.frameState.viewState.projection,\n    );\n    const z = tileGrid.getZForResolution(this.renderedResolution);\n    /** @type {Object<string, true>} */\n    const visitedSourceTiles = {};\n    tileCache.forEach((tile) => {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const sourceTiles = tile.getSourceTiles();\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        const sourceTile = sourceTiles[i];\n        const key = sourceTile.getKey();\n        if (key in visitedSourceTiles) {\n          continue;\n        }\n        visitedSourceTiles[key] = true;\n        const tileCoord = sourceTile.tileCoord;\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          const tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              const candidate = tileFeatures[j];\n              const geometry = candidate.getGeometry();\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @override\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  renderDeclutter(frameState, layerState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layerState.opacity;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const scaledCanvasSize = [\n      this.context.canvas.width,\n      this.context.canvas.height,\n    ];\n    const declutter = this.getLayer().getDeclutter();\n    const declutterTree = declutter\n      ? frameState.declutter?.[declutter]\n      : undefined;\n    const layerUid = getUid(this.getLayer());\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const executorGroups = tile.executorGroups[layerUid];\n      if (executorGroups) {\n        for (let j = executorGroups.length - 1; j >= 0; --j) {\n          executorGroups[j].execute(\n            this.context,\n            scaledCanvasSize,\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            DECLUTTER,\n            declutterTree,\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferredInternal(frameState) {\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const layerUid = getUid(this.getLayer());\n    const executorGroups = tiles.reduce((acc, tile, index) => {\n      tile.executorGroups[layerUid].forEach((executorGroup) =>\n        acc.push({\n          executorGroup,\n          index,\n        }),\n      );\n      return acc;\n    }, /** @type {Array<{executorGroup: CanvasExecutorGroup, index: number}>} */ ([]));\n\n    const executorGroupZIndexContexts = executorGroups.map(({executorGroup}) =>\n      executorGroup.getDeferredZIndexContexts(),\n    );\n    /** @type {Object<number, true>} */\n    const usedZIndices = {};\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroupZindexContext =\n        executorGroups[i].executorGroup.getDeferredZIndexContexts();\n      for (const key in executorGroupZindexContext) {\n        usedZIndices[key] = true;\n      }\n    }\n    const zIndexKeys = Object.keys(usedZIndices).map(Number).sort(ascending);\n    zIndexKeys.forEach((zIndex) => {\n      executorGroupZIndexContexts.forEach((zIndexContexts, i) => {\n        if (!zIndexContexts[zIndex]) {\n          return;\n        }\n        zIndexContexts[zIndex].forEach((zIndexContext) => {\n          const {executorGroup, index} = executorGroups[i];\n          const context = executorGroup.getRenderedContext();\n          const alpha = context.globalAlpha;\n          context.globalAlpha = this.renderedOpacity_;\n          const tileClipContext = this.tileClipContexts_[index];\n          if (tileClipContext) {\n            tileClipContext.draw(context);\n          }\n          zIndexContext.draw(context);\n          if (tileClipContext) {\n            context.restore();\n          }\n          context.globalAlpha = alpha;\n          zIndexContext.clear();\n        });\n        zIndexContexts[zIndex].length = 0;\n      });\n    });\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile The tile\n   * @param {import('../../Map.js').FrameState} frameState Current frame state\n   * @return {import('../../transform.js').Transform} Transform to use to render this tile\n   */\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tempExtent)[0] -\n      tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset,\n      ),\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    this.renderedOpacity_ =\n      frameState.layerStatesArray[frameState.layerIndex].opacity;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.renderedOpacity_;\n    const declutter = layer.getDeclutter();\n    const replayTypes = declutter\n      ? VECTOR_REPLAYS[renderMode].filter((type) => !DECLUTTER.includes(type))\n      : VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection,\n    );\n\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const clips = [];\n    const clipZs = [];\n    const tileClipContexts = [];\n    const layerUid = getUid(layer);\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = tiles[i];\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[layerUid].filter((group) =>\n        group.hasExecutors(replayTypes),\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      let clipContext = context;\n      let tileClipContext;\n      if (currentClip) {\n        tileClipContext = new ZIndexContext();\n        clipContext = tileClipContext.getContext();\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                clipContext.save();\n                contextSaved = true;\n              }\n              clipContext.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              clipContext.moveTo(currentClip[0], currentClip[1]);\n              clipContext.lineTo(currentClip[2], currentClip[3]);\n              clipContext.lineTo(currentClip[4], currentClip[5]);\n              clipContext.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              clipContext.moveTo(clip[6], clip[7]);\n              clipContext.lineTo(clip[4], clip[5]);\n              clipContext.lineTo(clip[2], clip[3]);\n              clipContext.lineTo(clip[0], clip[1]);\n              clipContext.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          [context.canvas.width, context.canvas.height],\n          transform,\n          rotation,\n          hifi,\n          replayTypes,\n          frameState.declutter?.[declutter],\n        );\n      }\n      if (contextSaved) {\n        if (clipContext === context) {\n          clipContext.restore();\n        } else {\n          tileClipContexts[i] = tileClipContext;\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n    this.tileClipContexts_ = tileClipContexts;\n    if (!frameState.declutter) {\n      this.renderDeferredInternal(frameState);\n    }\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    const tileImageNeedsRender =\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision;\n    return tileImageNeedsRender;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext();\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio),\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tempExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        [\n          context.canvas.width * renderScale,\n          context.canvas.height * renderScale,\n        ],\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()],\n        null,\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}