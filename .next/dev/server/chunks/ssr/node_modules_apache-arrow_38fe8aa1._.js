module.exports = [
"[project]/node_modules/apache-arrow/util/utf8.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeUtf8 = exports.decodeUtf8 = void 0;
const decoder = new TextDecoder('utf-8');
/** @ignore */ const decodeUtf8 = (buffer)=>decoder.decode(buffer);
exports.decodeUtf8 = decodeUtf8;
const encoder = new TextEncoder();
/** @ignore */ const encodeUtf8 = (value)=>encoder.encode(value);
exports.encodeUtf8 = encodeUtf8; //# sourceMappingURL=utf8.js.map
}),
"[project]/node_modules/apache-arrow/util/compat.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isFlatbuffersByteBuffer = exports.isReadableNodeStream = exports.isWritableNodeStream = exports.isReadableDOMStream = exports.isWritableDOMStream = exports.isFetchResponse = exports.isFSReadStream = exports.isFileHandle = exports.isUnderlyingSink = exports.isIteratorResult = exports.isArrayLike = exports.isArrowJSON = exports.isAsyncIterable = exports.isIterable = exports.isObservable = exports.isPromise = exports.isObject = void 0;
/** @ignore */ const isNumber = (x)=>typeof x === 'number';
/** @ignore */ const isBoolean = (x)=>typeof x === 'boolean';
/** @ignore */ const isFunction = (x)=>typeof x === 'function';
/** @ignore */ // eslint-disable-next-line @typescript-eslint/ban-types
const isObject = (x)=>x != null && Object(x) === x;
exports.isObject = isObject;
/** @ignore */ const isPromise = (x)=>{
    return (0, exports.isObject)(x) && isFunction(x.then);
};
exports.isPromise = isPromise;
/** @ignore */ const isObservable = (x)=>{
    return (0, exports.isObject)(x) && isFunction(x.subscribe);
};
exports.isObservable = isObservable;
/** @ignore */ const isIterable = (x)=>{
    return (0, exports.isObject)(x) && isFunction(x[Symbol.iterator]);
};
exports.isIterable = isIterable;
/** @ignore */ const isAsyncIterable = (x)=>{
    return (0, exports.isObject)(x) && isFunction(x[Symbol.asyncIterator]);
};
exports.isAsyncIterable = isAsyncIterable;
/** @ignore */ const isArrowJSON = (x)=>{
    return (0, exports.isObject)(x) && (0, exports.isObject)(x['schema']);
};
exports.isArrowJSON = isArrowJSON;
/** @ignore */ const isArrayLike = (x)=>{
    return (0, exports.isObject)(x) && isNumber(x['length']);
};
exports.isArrayLike = isArrayLike;
/** @ignore */ const isIteratorResult = (x)=>{
    return (0, exports.isObject)(x) && 'done' in x && 'value' in x;
};
exports.isIteratorResult = isIteratorResult;
/** @ignore */ const isUnderlyingSink = (x)=>{
    return (0, exports.isObject)(x) && isFunction(x['abort']) && isFunction(x['close']) && isFunction(x['start']) && isFunction(x['write']);
};
exports.isUnderlyingSink = isUnderlyingSink;
/** @ignore */ const isFileHandle = (x)=>{
    return (0, exports.isObject)(x) && isFunction(x['stat']) && isNumber(x['fd']);
};
exports.isFileHandle = isFileHandle;
/** @ignore */ const isFSReadStream = (x)=>{
    return (0, exports.isReadableNodeStream)(x) && isNumber(x['bytesRead']);
};
exports.isFSReadStream = isFSReadStream;
/** @ignore */ const isFetchResponse = (x)=>{
    return (0, exports.isObject)(x) && (0, exports.isReadableDOMStream)(x['body']);
};
exports.isFetchResponse = isFetchResponse;
const isReadableInterop = (x)=>'_getDOMStream' in x && '_getNodeStream' in x;
/** @ignore */ const isWritableDOMStream = (x)=>{
    return (0, exports.isObject)(x) && isFunction(x['abort']) && isFunction(x['getWriter']) && !isReadableInterop(x);
};
exports.isWritableDOMStream = isWritableDOMStream;
/** @ignore */ const isReadableDOMStream = (x)=>{
    return (0, exports.isObject)(x) && isFunction(x['cancel']) && isFunction(x['getReader']) && !isReadableInterop(x);
};
exports.isReadableDOMStream = isReadableDOMStream;
/** @ignore */ const isWritableNodeStream = (x)=>{
    return (0, exports.isObject)(x) && isFunction(x['end']) && isFunction(x['write']) && isBoolean(x['writable']) && !isReadableInterop(x);
};
exports.isWritableNodeStream = isWritableNodeStream;
/** @ignore */ const isReadableNodeStream = (x)=>{
    return (0, exports.isObject)(x) && isFunction(x['read']) && isFunction(x['pipe']) && isBoolean(x['readable']) && !isReadableInterop(x);
};
exports.isReadableNodeStream = isReadableNodeStream;
/** @ignore */ const isFlatbuffersByteBuffer = (x)=>{
    return (0, exports.isObject)(x) && isFunction(x['clear']) && isFunction(x['bytes']) && isFunction(x['position']) && isFunction(x['setPosition']) && isFunction(x['capacity']) && isFunction(x['getBufferIdentifier']) && isFunction(x['createLong']);
};
exports.isFlatbuffersByteBuffer = isFlatbuffersByteBuffer; //# sourceMappingURL=compat.js.map
}),
"[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.compareArrayLike = exports.rebaseValueOffsets = exports.toUint8ClampedArrayAsyncIterator = exports.toFloat64ArrayAsyncIterator = exports.toFloat32ArrayAsyncIterator = exports.toUint32ArrayAsyncIterator = exports.toUint16ArrayAsyncIterator = exports.toUint8ArrayAsyncIterator = exports.toInt32ArrayAsyncIterator = exports.toInt16ArrayAsyncIterator = exports.toInt8ArrayAsyncIterator = exports.toArrayBufferViewAsyncIterator = exports.toUint8ClampedArrayIterator = exports.toFloat64ArrayIterator = exports.toFloat32ArrayIterator = exports.toUint32ArrayIterator = exports.toUint16ArrayIterator = exports.toUint8ArrayIterator = exports.toInt32ArrayIterator = exports.toInt16ArrayIterator = exports.toInt8ArrayIterator = exports.toArrayBufferViewIterator = exports.toUint8ClampedArray = exports.toFloat64Array = exports.toFloat32Array = exports.toBigUint64Array = exports.toUint32Array = exports.toUint16Array = exports.toUint8Array = exports.toBigInt64Array = exports.toInt32Array = exports.toInt16Array = exports.toInt8Array = exports.toArrayBufferView = exports.joinUint8Arrays = exports.memcpy = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/utf8.js [app-ssr] (ecmascript)");
const compat_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/compat.js [app-ssr] (ecmascript)");
/** @ignore */ const SharedArrayBuf = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer;
/** @ignore */ function collapseContiguousByteRanges(chunks) {
    const result = chunks[0] ? [
        chunks[0]
    ] : [];
    let xOffset, yOffset, xLen, yLen;
    for(let x, y, i = 0, j = 0, n = chunks.length; ++i < n;){
        x = result[j];
        y = chunks[i];
        // continue if x and y don't share the same underlying ArrayBuffer, or if x isn't before y
        if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
            y && (result[++j] = y);
            continue;
        }
        ({ byteOffset: xOffset, byteLength: xLen } = x);
        ({ byteOffset: yOffset, byteLength: yLen } = y);
        // continue if the byte ranges of x and y aren't contiguous
        if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
            y && (result[++j] = y);
            continue;
        }
        result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
    }
    return result;
}
/** @ignore */ function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
    const targetByteLength = target.byteLength;
    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
    dst.set(src, targetByteOffset);
    return target;
}
exports.memcpy = memcpy;
/** @ignore */ function joinUint8Arrays(chunks, size) {
    // collapse chunks that share the same underlying ArrayBuffer and whose byte ranges overlap,
    // to avoid unnecessarily copying the bytes to do this buffer join. This is a common case during
    // streaming, where we may be reading partial byte ranges out of the same underlying ArrayBuffer
    const result = collapseContiguousByteRanges(chunks);
    const byteLength = result.reduce((x, b)=>x + b.byteLength, 0);
    let source, sliced, buffer;
    let offset = 0, index = -1;
    const length = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
    for(const n = result.length; ++index < n;){
        source = result[index];
        sliced = source.subarray(0, Math.min(source.length, length - offset));
        if (length <= offset + sliced.length) {
            if (sliced.length < source.length) {
                result[index] = source.subarray(sliced.length);
            } else if (sliced.length === source.length) {
                index++;
            }
            buffer ? memcpy(buffer, sliced, offset) : buffer = sliced;
            break;
        }
        memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);
        offset += sliced.length;
    }
    return [
        buffer || new Uint8Array(0),
        result.slice(index),
        byteLength - (buffer ? buffer.byteLength : 0)
    ];
}
exports.joinUint8Arrays = joinUint8Arrays;
/** @ignore */ function toArrayBufferView(ArrayBufferViewCtor, input) {
    let value = (0, compat_js_1.isIteratorResult)(input) ? input.value : input;
    if (value instanceof ArrayBufferViewCtor) {
        if (ArrayBufferViewCtor === Uint8Array) {
            // Node's `Buffer` class passes the `instanceof Uint8Array` check, but we need
            // a real Uint8Array, since Buffer#slice isn't the same as Uint8Array#slice :/
            return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
        }
        return value;
    }
    if (!value) {
        return new ArrayBufferViewCtor(0);
    }
    if (typeof value === 'string') {
        value = (0, utf8_js_1.encodeUtf8)(value);
    }
    if (value instanceof ArrayBuffer) {
        return new ArrayBufferViewCtor(value);
    }
    if (value instanceof SharedArrayBuf) {
        return new ArrayBufferViewCtor(value);
    }
    if ((0, compat_js_1.isFlatbuffersByteBuffer)(value)) {
        return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
    }
    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
}
exports.toArrayBufferView = toArrayBufferView;
/** @ignore */ const toInt8Array = (input)=>toArrayBufferView(Int8Array, input);
exports.toInt8Array = toInt8Array;
/** @ignore */ const toInt16Array = (input)=>toArrayBufferView(Int16Array, input);
exports.toInt16Array = toInt16Array;
/** @ignore */ const toInt32Array = (input)=>toArrayBufferView(Int32Array, input);
exports.toInt32Array = toInt32Array;
/** @ignore */ const toBigInt64Array = (input)=>toArrayBufferView(BigInt64Array, input);
exports.toBigInt64Array = toBigInt64Array;
/** @ignore */ const toUint8Array = (input)=>toArrayBufferView(Uint8Array, input);
exports.toUint8Array = toUint8Array;
/** @ignore */ const toUint16Array = (input)=>toArrayBufferView(Uint16Array, input);
exports.toUint16Array = toUint16Array;
/** @ignore */ const toUint32Array = (input)=>toArrayBufferView(Uint32Array, input);
exports.toUint32Array = toUint32Array;
/** @ignore */ const toBigUint64Array = (input)=>toArrayBufferView(BigUint64Array, input);
exports.toBigUint64Array = toBigUint64Array;
/** @ignore */ const toFloat32Array = (input)=>toArrayBufferView(Float32Array, input);
exports.toFloat32Array = toFloat32Array;
/** @ignore */ const toFloat64Array = (input)=>toArrayBufferView(Float64Array, input);
exports.toFloat64Array = toFloat64Array;
/** @ignore */ const toUint8ClampedArray = (input)=>toArrayBufferView(Uint8ClampedArray, input);
exports.toUint8ClampedArray = toUint8ClampedArray;
/** @ignore */ const pump = (iterator)=>{
    iterator.next();
    return iterator;
};
/** @ignore */ function* toArrayBufferViewIterator(ArrayCtor, source) {
    const wrap = function*(x) {
        yield x;
    };
    const buffers = typeof source === 'string' ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !(0, compat_js_1.isIterable)(source) ? wrap(source) : source;
    yield* pump(function*(it) {
        let r = null;
        do {
            r = it.next((yield toArrayBufferView(ArrayCtor, r)));
        }while (!r.done)
    }(buffers[Symbol.iterator]()));
    return new ArrayCtor();
}
exports.toArrayBufferViewIterator = toArrayBufferViewIterator;
/** @ignore */ const toInt8ArrayIterator = (input)=>toArrayBufferViewIterator(Int8Array, input);
exports.toInt8ArrayIterator = toInt8ArrayIterator;
/** @ignore */ const toInt16ArrayIterator = (input)=>toArrayBufferViewIterator(Int16Array, input);
exports.toInt16ArrayIterator = toInt16ArrayIterator;
/** @ignore */ const toInt32ArrayIterator = (input)=>toArrayBufferViewIterator(Int32Array, input);
exports.toInt32ArrayIterator = toInt32ArrayIterator;
/** @ignore */ const toUint8ArrayIterator = (input)=>toArrayBufferViewIterator(Uint8Array, input);
exports.toUint8ArrayIterator = toUint8ArrayIterator;
/** @ignore */ const toUint16ArrayIterator = (input)=>toArrayBufferViewIterator(Uint16Array, input);
exports.toUint16ArrayIterator = toUint16ArrayIterator;
/** @ignore */ const toUint32ArrayIterator = (input)=>toArrayBufferViewIterator(Uint32Array, input);
exports.toUint32ArrayIterator = toUint32ArrayIterator;
/** @ignore */ const toFloat32ArrayIterator = (input)=>toArrayBufferViewIterator(Float32Array, input);
exports.toFloat32ArrayIterator = toFloat32ArrayIterator;
/** @ignore */ const toFloat64ArrayIterator = (input)=>toArrayBufferViewIterator(Float64Array, input);
exports.toFloat64ArrayIterator = toFloat64ArrayIterator;
/** @ignore */ const toUint8ClampedArrayIterator = (input)=>toArrayBufferViewIterator(Uint8ClampedArray, input);
exports.toUint8ClampedArrayIterator = toUint8ClampedArrayIterator;
/** @ignore */ function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
    return tslib_1.__asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
        // if a Promise, unwrap the Promise and iterate the resolved value
        if ((0, compat_js_1.isPromise)(source)) {
            return yield tslib_1.__await((yield tslib_1.__await((yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, (yield tslib_1.__await(source)))))))));
        }
        const wrap = function(x) {
            return tslib_1.__asyncGenerator(this, arguments, function*() {
                yield yield tslib_1.__await((yield tslib_1.__await(x)));
            });
        };
        const emit = function(source) {
            return tslib_1.__asyncGenerator(this, arguments, function*() {
                yield tslib_1.__await((yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(pump(function*(it) {
                    let r = null;
                    do {
                        r = it.next((yield r === null || r === void 0 ? void 0 : r.value));
                    }while (!r.done)
                }(source[Symbol.iterator]()))))));
            });
        };
        const buffers = typeof source === 'string' ? wrap(source) // if string, wrap in an AsyncIterableIterator
         : ArrayBuffer.isView(source) ? wrap(source) // if TypedArray, wrap in an AsyncIterableIterator
         : source instanceof ArrayBuffer ? wrap(source) // if ArrayBuffer, wrap in an AsyncIterableIterator
         : source instanceof SharedArrayBuf ? wrap(source) // if SharedArrayBuffer, wrap in an AsyncIterableIterator
         : (0, compat_js_1.isIterable)(source) ? emit(source) // If Iterable, wrap in an AsyncIterableIterator and compose the `next` values
         : !(0, compat_js_1.isAsyncIterable)(source) ? wrap(source) // If not an AsyncIterable, treat as a sentinel and wrap in an AsyncIterableIterator
         : source; // otherwise if AsyncIterable, use it
        yield tslib_1.__await((yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(pump(function(it) {
            return tslib_1.__asyncGenerator(this, arguments, function*() {
                let r = null;
                do {
                    r = yield tslib_1.__await(it.next((yield yield tslib_1.__await(toArrayBufferView(ArrayCtor, r)))));
                }while (!r.done)
            });
        }(buffers[Symbol.asyncIterator]()))))));
        return yield tslib_1.__await(new ArrayCtor());
    });
}
exports.toArrayBufferViewAsyncIterator = toArrayBufferViewAsyncIterator;
/** @ignore */ const toInt8ArrayAsyncIterator = (input)=>toArrayBufferViewAsyncIterator(Int8Array, input);
exports.toInt8ArrayAsyncIterator = toInt8ArrayAsyncIterator;
/** @ignore */ const toInt16ArrayAsyncIterator = (input)=>toArrayBufferViewAsyncIterator(Int16Array, input);
exports.toInt16ArrayAsyncIterator = toInt16ArrayAsyncIterator;
/** @ignore */ const toInt32ArrayAsyncIterator = (input)=>toArrayBufferViewAsyncIterator(Int32Array, input);
exports.toInt32ArrayAsyncIterator = toInt32ArrayAsyncIterator;
/** @ignore */ const toUint8ArrayAsyncIterator = (input)=>toArrayBufferViewAsyncIterator(Uint8Array, input);
exports.toUint8ArrayAsyncIterator = toUint8ArrayAsyncIterator;
/** @ignore */ const toUint16ArrayAsyncIterator = (input)=>toArrayBufferViewAsyncIterator(Uint16Array, input);
exports.toUint16ArrayAsyncIterator = toUint16ArrayAsyncIterator;
/** @ignore */ const toUint32ArrayAsyncIterator = (input)=>toArrayBufferViewAsyncIterator(Uint32Array, input);
exports.toUint32ArrayAsyncIterator = toUint32ArrayAsyncIterator;
/** @ignore */ const toFloat32ArrayAsyncIterator = (input)=>toArrayBufferViewAsyncIterator(Float32Array, input);
exports.toFloat32ArrayAsyncIterator = toFloat32ArrayAsyncIterator;
/** @ignore */ const toFloat64ArrayAsyncIterator = (input)=>toArrayBufferViewAsyncIterator(Float64Array, input);
exports.toFloat64ArrayAsyncIterator = toFloat64ArrayAsyncIterator;
/** @ignore */ const toUint8ClampedArrayAsyncIterator = (input)=>toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
exports.toUint8ClampedArrayAsyncIterator = toUint8ClampedArrayAsyncIterator;
function rebaseValueOffsets(offset, length, valueOffsets) {
    // If we have a non-zero offset, create a new offsets array with the values
    // shifted by the start offset, such that the new start offset is 0
    if (offset !== 0) {
        valueOffsets = valueOffsets.slice(0, length);
        for(let i = -1, n = valueOffsets.length; ++i < n;){
            valueOffsets[i] += offset;
        }
    }
    return valueOffsets.subarray(0, length);
}
exports.rebaseValueOffsets = rebaseValueOffsets;
/** @ignore */ function compareArrayLike(a, b) {
    let i = 0;
    const n = a.length;
    if (n !== b.length) {
        return false;
    }
    if (n > 0) {
        do {
            if (a[i] !== b[i]) {
                return false;
            }
        }while (++i < n)
    }
    return true;
}
exports.compareArrayLike = compareArrayLike; //# sourceMappingURL=buffer.js.map
}),
"[project]/node_modules/apache-arrow/io/adapters.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
/** @ignore */ exports.default = {
    fromIterable (source) {
        return pump(fromIterable(source));
    },
    fromAsyncIterable (source) {
        return pump(fromAsyncIterable(source));
    },
    fromDOMStream (source) {
        return pump(fromDOMStream(source));
    },
    fromNodeStream (stream) {
        return pump(fromNodeStream(stream));
    },
    // @ts-ignore
    toDOMStream (source, options) {
        throw new Error(`"toDOMStream" not available in this environment`);
    },
    // @ts-ignore
    toNodeStream (source, options) {
        throw new Error(`"toNodeStream" not available in this environment`);
    }
};
/** @ignore */ const pump = (iterator)=>{
    iterator.next();
    return iterator;
};
/** @ignore */ function* fromIterable(source) {
    let done, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
        if (cmd === 'peek') {
            return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
        return buffer;
    }
    // Yield so the caller can inject the read command before creating the source Iterator
    ({ cmd, size } = (yield (()=>null)()) || {
        cmd: 'read',
        size: 0
    });
    // initialize the iterator
    const it = (0, buffer_js_1.toUint8ArrayIterator)(source)[Symbol.iterator]();
    try {
        do {
            // read the next value
            ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? it.next() : it.next(size - bufferLength));
            // if chunk is not null or empty, push it onto the queue
            if (!done && buffer.byteLength > 0) {
                buffers.push(buffer);
                bufferLength += buffer.byteLength;
            }
            // If we have enough bytes in our buffer, yield chunks until we don't
            if (done || size <= bufferLength) {
                do {
                    ({ cmd, size } = yield byteRange());
                }while (size < bufferLength)
            }
        }while (!done)
    } catch (e) {
        (threw = true) && typeof it.throw === 'function' && it.throw(e);
    } finally{
        threw === false && typeof it.return === 'function' && it.return(null);
    }
    return null;
}
/** @ignore */ function fromAsyncIterable(source) {
    return tslib_1.__asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
        let done, threw = false;
        let buffers = [], buffer;
        let cmd, size, bufferLength = 0;
        function byteRange() {
            if (cmd === 'peek') {
                return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
            }
            [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
            return buffer;
        }
        // Yield so the caller can inject the read command before creating the source AsyncIterator
        ({ cmd, size } = (yield yield tslib_1.__await((()=>null)())) || {
            cmd: 'read',
            size: 0
        });
        // initialize the iterator
        const it = (0, buffer_js_1.toUint8ArrayAsyncIterator)(source)[Symbol.asyncIterator]();
        try {
            do {
                // read the next value
                ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield tslib_1.__await(it.next()) : yield tslib_1.__await(it.next(size - bufferLength)));
                // if chunk is not null or empty, push it onto the queue
                if (!done && buffer.byteLength > 0) {
                    buffers.push(buffer);
                    bufferLength += buffer.byteLength;
                }
                // If we have enough bytes in our buffer, yield chunks until we don't
                if (done || size <= bufferLength) {
                    do {
                        ({ cmd, size } = yield yield tslib_1.__await(byteRange()));
                    }while (size < bufferLength)
                }
            }while (!done)
        } catch (e) {
            (threw = true) && typeof it.throw === 'function' && (yield tslib_1.__await(it.throw(e)));
        } finally{
            threw === false && typeof it.return === 'function' && (yield tslib_1.__await(it.return(new Uint8Array(0))));
        }
        return yield tslib_1.__await(null);
    });
}
// All this manual Uint8Array chunk management can be avoided if/when engines
// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():
// https://github.com/domenic/proposal-arraybuffer-transfer
/** @ignore */ function fromDOMStream(source) {
    return tslib_1.__asyncGenerator(this, arguments, function* fromDOMStream_1() {
        let done = false, threw = false;
        let buffers = [], buffer;
        let cmd, size, bufferLength = 0;
        function byteRange() {
            if (cmd === 'peek') {
                return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
            }
            [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
            return buffer;
        }
        // Yield so the caller can inject the read command before we establish the ReadableStream lock
        ({ cmd, size } = (yield yield tslib_1.__await((()=>null)())) || {
            cmd: 'read',
            size: 0
        });
        // initialize the reader and lock the stream
        const it = new AdaptiveByteReader(source);
        try {
            do {
                // read the next value
                ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield tslib_1.__await(it['read']()) : yield tslib_1.__await(it['read'](size - bufferLength)));
                // if chunk is not null or empty, push it onto the queue
                if (!done && buffer.byteLength > 0) {
                    buffers.push((0, buffer_js_1.toUint8Array)(buffer));
                    bufferLength += buffer.byteLength;
                }
                // If we have enough bytes in our buffer, yield chunks until we don't
                if (done || size <= bufferLength) {
                    do {
                        ({ cmd, size } = yield yield tslib_1.__await(byteRange()));
                    }while (size < bufferLength)
                }
            }while (!done)
        } catch (e) {
            (threw = true) && (yield tslib_1.__await(it['cancel'](e)));
        } finally{
            threw === false ? yield tslib_1.__await(it['cancel']()) : source['locked'] && it.releaseLock();
        }
        return yield tslib_1.__await(null);
    });
}
/** @ignore */ class AdaptiveByteReader {
    constructor(source){
        this.source = source;
        this.reader = null;
        this.reader = this.source['getReader']();
        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions
        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified
        // about why these errors are raised, but I'm sure there's some important spec reason that
        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the
        // only solution in this case :/
        this.reader['closed'].catch(()=>{});
    }
    get closed() {
        return this.reader ? this.reader['closed'].catch(()=>{}) : Promise.resolve();
    }
    releaseLock() {
        if (this.reader) {
            this.reader.releaseLock();
        }
        this.reader = null;
    }
    cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            const { reader, source } = this;
            reader && (yield reader['cancel'](reason).catch(()=>{}));
            source && source['locked'] && this.releaseLock();
        });
    }
    read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            if (size === 0) {
                return {
                    done: this.reader == null,
                    value: new Uint8Array(0)
                };
            }
            const result = yield this.reader.read();
            !result.done && (result.value = (0, buffer_js_1.toUint8Array)(result));
            return result;
        });
    }
}
/** @ignore */ const onEvent = (stream, event)=>{
    const handler = (_)=>resolve([
            event,
            _
        ]);
    let resolve;
    return [
        event,
        handler,
        new Promise((r)=>(resolve = r) && stream['once'](event, handler))
    ];
};
/** @ignore */ function fromNodeStream(stream) {
    return tslib_1.__asyncGenerator(this, arguments, function* fromNodeStream_1() {
        const events = [];
        let event = 'error';
        let done = false, err = null;
        let cmd, size, bufferLength = 0;
        let buffers = [], buffer;
        function byteRange() {
            if (cmd === 'peek') {
                return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
            }
            [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
            return buffer;
        }
        // Yield so the caller can inject the read command before we
        // add the listener for the source stream's 'readable' event.
        ({ cmd, size } = (yield yield tslib_1.__await((()=>null)())) || {
            cmd: 'read',
            size: 0
        });
        // ignore stdin if it's a TTY
        if (stream['isTTY']) {
            yield yield tslib_1.__await(new Uint8Array(0));
            return yield tslib_1.__await(null);
        }
        try {
            // initialize the stream event handlers
            events[0] = onEvent(stream, 'end');
            events[1] = onEvent(stream, 'error');
            do {
                events[2] = onEvent(stream, 'readable');
                // wait on the first message event from the stream
                [event, err] = yield tslib_1.__await(Promise.race(events.map((x)=>x[2])));
                // if the stream emitted an Error, rethrow it
                if (event === 'error') {
                    break;
                }
                if (!(done = event === 'end')) {
                    // If the size is NaN, request to read everything in the stream's internal buffer
                    if (!Number.isFinite(size - bufferLength)) {
                        buffer = (0, buffer_js_1.toUint8Array)(stream['read']());
                    } else {
                        buffer = (0, buffer_js_1.toUint8Array)(stream['read'](size - bufferLength));
                        // If the byteLength is 0, then the requested amount is more than the stream has
                        // in its internal buffer. In this case the stream needs a "kick" to tell it to
                        // continue emitting readable events, so request to read everything the stream
                        // has in its internal buffer right now.
                        if (buffer.byteLength < size - bufferLength) {
                            buffer = (0, buffer_js_1.toUint8Array)(stream['read']());
                        }
                    }
                    // if chunk is not null or empty, push it onto the queue
                    if (buffer.byteLength > 0) {
                        buffers.push(buffer);
                        bufferLength += buffer.byteLength;
                    }
                }
                // If we have enough bytes in our buffer, yield chunks until we don't
                if (done || size <= bufferLength) {
                    do {
                        ({ cmd, size } = yield yield tslib_1.__await(byteRange()));
                    }while (size < bufferLength)
                }
            }while (!done)
        } finally{
            yield tslib_1.__await(cleanup(events, event === 'error' ? err : null));
        }
        return yield tslib_1.__await(null);
        //TURBOPACK unreachable
        ;
        function cleanup(events, err) {
            buffer = buffers = null;
            return new Promise((resolve, reject)=>{
                for (const [evt, fn] of events){
                    stream['off'](evt, fn);
                }
                try {
                    // Some stream implementations don't call the destroy callback,
                    // because it's really a node-internal API. Just calling `destroy`
                    // here should be enough to conform to the ReadableStream contract
                    const destroy = stream['destroy'];
                    destroy && destroy.call(stream, err);
                    err = undefined;
                } catch (e) {
                    err = e || err;
                } finally{
                    err != null ? reject(err) : resolve();
                }
            });
        }
    });
} //# sourceMappingURL=adapters.js.map
}),
"[project]/node_modules/apache-arrow/fb/metadata-version.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MetadataVersion = void 0;
/**
 * Logical types, vector layouts, and schemas
 * Format Version History.
 * Version 1.0 - Forward and backwards compatibility guaranteed.
 * Version 1.1 - Add Decimal256.
 * Version 1.2 - Add Interval MONTH_DAY_NANO.
 * Version 1.3 - Add Run-End Encoded.
 */ var MetadataVersion;
(function(MetadataVersion) {
    /**
     * 0.1.0 (October 2016).
     */ MetadataVersion[MetadataVersion["V1"] = 0] = "V1";
    /**
     * 0.2.0 (February 2017). Non-backwards compatible with V1.
     */ MetadataVersion[MetadataVersion["V2"] = 1] = "V2";
    /**
     * 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2.
     */ MetadataVersion[MetadataVersion["V3"] = 2] = "V3";
    /**
     * >= 0.8.0 (December 2017). Non-backwards compatible with V3.
     */ MetadataVersion[MetadataVersion["V4"] = 3] = "V4";
    /**
     * >= 1.0.0 (July 2020. Backwards compatible with V4 (V5 readers can read V4
     * metadata and IPC messages). Implementations are recommended to provide a
     * V4 compatibility mode with V5 format changes disabled.
     *
     * Incompatible changes between V4 and V5:
     * - Union buffer layout has changed. In V5, Unions don't have a validity
     *   bitmap buffer.
     */ MetadataVersion[MetadataVersion["V5"] = 4] = "V5";
})(MetadataVersion || (exports.MetadataVersion = MetadataVersion = {})); //# sourceMappingURL=metadata-version.js.map
}),
"[project]/node_modules/apache-arrow/fb/union-mode.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UnionMode = void 0;
var UnionMode;
(function(UnionMode) {
    UnionMode[UnionMode["Sparse"] = 0] = "Sparse";
    UnionMode[UnionMode["Dense"] = 1] = "Dense";
})(UnionMode || (exports.UnionMode = UnionMode = {})); //# sourceMappingURL=union-mode.js.map
}),
"[project]/node_modules/apache-arrow/fb/precision.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Precision = void 0;
var Precision;
(function(Precision) {
    Precision[Precision["HALF"] = 0] = "HALF";
    Precision[Precision["SINGLE"] = 1] = "SINGLE";
    Precision[Precision["DOUBLE"] = 2] = "DOUBLE";
})(Precision || (exports.Precision = Precision = {})); //# sourceMappingURL=precision.js.map
}),
"[project]/node_modules/apache-arrow/fb/date-unit.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DateUnit = void 0;
var DateUnit;
(function(DateUnit) {
    DateUnit[DateUnit["DAY"] = 0] = "DAY";
    DateUnit[DateUnit["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit || (exports.DateUnit = DateUnit = {})); //# sourceMappingURL=date-unit.js.map
}),
"[project]/node_modules/apache-arrow/fb/time-unit.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TimeUnit = void 0;
var TimeUnit;
(function(TimeUnit) {
    TimeUnit[TimeUnit["SECOND"] = 0] = "SECOND";
    TimeUnit[TimeUnit["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit[TimeUnit["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit[TimeUnit["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit || (exports.TimeUnit = TimeUnit = {})); //# sourceMappingURL=time-unit.js.map
}),
"[project]/node_modules/apache-arrow/fb/interval-unit.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IntervalUnit = void 0;
var IntervalUnit;
(function(IntervalUnit) {
    IntervalUnit[IntervalUnit["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit[IntervalUnit["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit[IntervalUnit["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
})(IntervalUnit || (exports.IntervalUnit = IntervalUnit = {})); //# sourceMappingURL=interval-unit.js.map
}),
"[project]/node_modules/apache-arrow/fb/body-compression-method.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BodyCompressionMethod = void 0;
/**
 * Provided for forward compatibility in case we need to support different
 * strategies for compressing the IPC message body (like whole-body
 * compression rather than buffer-level) in the future
 */ var BodyCompressionMethod;
(function(BodyCompressionMethod) {
    /**
     * Each constituent buffer is first compressed with the indicated
     * compressor, and then written with the uncompressed length in the first 8
     * bytes as a 64-bit little-endian signed integer followed by the compressed
     * buffer bytes (and then padding as required by the protocol). The
     * uncompressed length may be set to -1 to indicate that the data that
     * follows is not compressed, which can be useful for cases where
     * compression does not yield appreciable savings.
     */ BodyCompressionMethod[BodyCompressionMethod["BUFFER"] = 0] = "BUFFER";
})(BodyCompressionMethod || (exports.BodyCompressionMethod = BodyCompressionMethod = {})); //# sourceMappingURL=body-compression-method.js.map
}),
"[project]/node_modules/apache-arrow/fb/compression-type.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CompressionType = void 0;
var CompressionType;
(function(CompressionType) {
    CompressionType[CompressionType["LZ4_FRAME"] = 0] = "LZ4_FRAME";
    CompressionType[CompressionType["ZSTD"] = 1] = "ZSTD";
})(CompressionType || (exports.CompressionType = CompressionType = {})); //# sourceMappingURL=compression-type.js.map
}),
"[project]/node_modules/apache-arrow/fb/body-compression.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BodyCompression = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const body_compression_method_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/body-compression-method.js [app-ssr] (ecmascript)");
const compression_type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/compression-type.js [app-ssr] (ecmascript)");
/**
 * Optional compression for the memory buffers constituting IPC message
 * bodies. Intended for use with RecordBatch but could be used for other
 * message types
 */ class BodyCompression {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBodyCompression(bb, obj) {
        return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBodyCompression(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Compressor library.
     * For LZ4_FRAME, each compressed buffer must consist of a single frame.
     */ codec() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : compression_type_js_1.CompressionType.LZ4_FRAME;
    }
    /**
     * Indicates the way the record batch body was compressed
     */ method() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : body_compression_method_js_1.BodyCompressionMethod.BUFFER;
    }
    static startBodyCompression(builder) {
        builder.startObject(2);
    }
    static addCodec(builder, codec) {
        builder.addFieldInt8(0, codec, compression_type_js_1.CompressionType.LZ4_FRAME);
    }
    static addMethod(builder, method) {
        builder.addFieldInt8(1, method, body_compression_method_js_1.BodyCompressionMethod.BUFFER);
    }
    static endBodyCompression(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBodyCompression(builder, codec, method) {
        BodyCompression.startBodyCompression(builder);
        BodyCompression.addCodec(builder, codec);
        BodyCompression.addMethod(builder, method);
        return BodyCompression.endBodyCompression(builder);
    }
}
exports.BodyCompression = BodyCompression; //# sourceMappingURL=body-compression.js.map
}),
"[project]/node_modules/apache-arrow/fb/buffer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Buffer = void 0;
/**
 * ----------------------------------------------------------------------
 * A Buffer represents a single contiguous memory segment
 */ class Buffer {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    /**
     * The relative offset into the shared memory page where the bytes for this
     * buffer starts
     */ offset() {
        return this.bb.readInt64(this.bb_pos);
    }
    /**
     * The absolute length (in bytes) of the memory buffer. The memory is found
     * from offset (inclusive) to offset + length (non-inclusive). When building
     * messages using the encapsulated IPC message, padding bytes may be written
     * after a buffer, but such padding bytes do not need to be accounted for in
     * the size here.
     */ length() {
        return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
        return 16;
    }
    static createBuffer(builder, offset, length) {
        builder.prep(8, 16);
        builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
        builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));
        return builder.offset();
    }
}
exports.Buffer = Buffer; //# sourceMappingURL=buffer.js.map
}),
"[project]/node_modules/apache-arrow/fb/field-node.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FieldNode = void 0;
/**
 * ----------------------------------------------------------------------
 * Data structures for describing a table row batch (a collection of
 * equal-length Arrow arrays)
 * Metadata about a field at some level of a nested type tree (but not
 * its children).
 *
 * For example, a List<Int16> with values `[[1, 2, 3], null, [4], [5, 6], null]`
 * would have {length: 5, null_count: 2} for its List node, and {length: 6,
 * null_count: 0} for its Int16 node, as separate FieldNode structs
 */ class FieldNode {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    /**
     * The number of value slots in the Arrow array at this level of a nested
     * tree
     */ length() {
        return this.bb.readInt64(this.bb_pos);
    }
    /**
     * The number of observed nulls. Fields with null_count == 0 may choose not
     * to write their physical validity bitmap out as a materialized buffer,
     * instead setting the length of the bitmap buffer to 0.
     */ nullCount() {
        return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
        return 16;
    }
    static createFieldNode(builder, length, null_count) {
        builder.prep(8, 16);
        builder.writeInt64(BigInt(null_count !== null && null_count !== void 0 ? null_count : 0));
        builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
        return builder.offset();
    }
}
exports.FieldNode = FieldNode; //# sourceMappingURL=field-node.js.map
}),
"[project]/node_modules/apache-arrow/fb/record-batch.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RecordBatch = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const body_compression_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/body-compression.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/buffer.js [app-ssr] (ecmascript)");
const field_node_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/field-node.js [app-ssr] (ecmascript)");
/**
 * A data header describing the shared memory layout of a "record" or "row"
 * batch. Some systems call this a "row batch" internally and others a "record
 * batch".
 */ class RecordBatch {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRecordBatch(bb, obj) {
        return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRecordBatch(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * number of records / rows. The arrays in the batch should all have this
     * length
     */ length() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    /**
     * Nodes correspond to the pre-ordered flattened logical schema
     */ nodes(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new field_node_js_1.FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    nodesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Buffers correspond to the pre-ordered flattened buffer tree
     *
     * The number of buffers appended to this list depends on the schema. For
     * example, most primitive arrays will have 2 buffers, 1 for the validity
     * bitmap and 1 for the values. For struct arrays, there will only be a
     * single buffer for the validity (nulls) bitmap
     */ buffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    buffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Optional compression of the message body
     */ compression(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new body_compression_js_1.BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startRecordBatch(builder) {
        builder.startObject(4);
    }
    static addLength(builder, length) {
        builder.addFieldInt64(0, length, BigInt('0'));
    }
    static addNodes(builder, nodesOffset) {
        builder.addFieldOffset(1, nodesOffset, 0);
    }
    static startNodesVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addBuffers(builder, buffersOffset) {
        builder.addFieldOffset(2, buffersOffset, 0);
    }
    static startBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addCompression(builder, compressionOffset) {
        builder.addFieldOffset(3, compressionOffset, 0);
    }
    static endRecordBatch(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.RecordBatch = RecordBatch; //# sourceMappingURL=record-batch.js.map
}),
"[project]/node_modules/apache-arrow/fb/dictionary-batch.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DictionaryBatch = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const record_batch_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/record-batch.js [app-ssr] (ecmascript)");
/**
 * For sending dictionary encoding information. Any Field can be
 * dictionary-encoded, but in this case none of its children may be
 * dictionary-encoded.
 * There is one vector / column per dictionary, but that vector / column
 * may be spread across multiple dictionary batches by using the isDelta
 * flag
 */ class DictionaryBatch {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDictionaryBatch(bb, obj) {
        return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryBatch(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new record_batch_js_1.RecordBatch()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * If isDelta is true the values in the dictionary are to be appended to a
     * dictionary with the indicated id. If isDelta is false this dictionary
     * should replace the existing dictionary.
     */ isDelta() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startDictionaryBatch(builder) {
        builder.startObject(3);
    }
    static addId(builder, id) {
        builder.addFieldInt64(0, id, BigInt('0'));
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(1, dataOffset, 0);
    }
    static addIsDelta(builder, isDelta) {
        builder.addFieldInt8(2, +isDelta, +false);
    }
    static endDictionaryBatch(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.DictionaryBatch = DictionaryBatch; //# sourceMappingURL=dictionary-batch.js.map
}),
"[project]/node_modules/apache-arrow/fb/endianness.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Endianness = void 0;
/**
 * ----------------------------------------------------------------------
 * Endianness of the platform producing the data
 */ var Endianness;
(function(Endianness) {
    Endianness[Endianness["Little"] = 0] = "Little";
    Endianness[Endianness["Big"] = 1] = "Big";
})(Endianness || (exports.Endianness = Endianness = {})); //# sourceMappingURL=endianness.js.map
}),
"[project]/node_modules/apache-arrow/fb/dictionary-kind.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DictionaryKind = void 0;
/**
 * ----------------------------------------------------------------------
 * Dictionary encoding metadata
 * Maintained for forwards compatibility, in the future
 * Dictionaries might be explicit maps between integers and values
 * allowing for non-contiguous index values
 */ var DictionaryKind;
(function(DictionaryKind) {
    DictionaryKind[DictionaryKind["DenseArray"] = 0] = "DenseArray";
})(DictionaryKind || (exports.DictionaryKind = DictionaryKind = {})); //# sourceMappingURL=dictionary-kind.js.map
}),
"[project]/node_modules/apache-arrow/fb/int.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Int = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
class Int {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsInt(bb, obj) {
        return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInt(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    bitWidth() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    isSigned() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startInt(builder) {
        builder.startObject(2);
    }
    static addBitWidth(builder, bitWidth) {
        builder.addFieldInt32(0, bitWidth, 0);
    }
    static addIsSigned(builder, isSigned) {
        builder.addFieldInt8(1, +isSigned, +false);
    }
    static endInt(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createInt(builder, bitWidth, isSigned) {
        Int.startInt(builder);
        Int.addBitWidth(builder, bitWidth);
        Int.addIsSigned(builder, isSigned);
        return Int.endInt(builder);
    }
}
exports.Int = Int; //# sourceMappingURL=int.js.map
}),
"[project]/node_modules/apache-arrow/fb/dictionary-encoding.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DictionaryEncoding = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const dictionary_kind_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/dictionary-kind.js [app-ssr] (ecmascript)");
const int_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/int.js [app-ssr] (ecmascript)");
class DictionaryEncoding {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDictionaryEncoding(bb, obj) {
        return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * The known dictionary id in the application where this data is used. In
     * the file or streaming formats, the dictionary ids are found in the
     * DictionaryBatch messages
     */ id() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    /**
     * The dictionary indices are constrained to be non-negative integers. If
     * this field is null, the indices must be signed int32. To maximize
     * cross-language compatibility and performance, implementations are
     * recommended to prefer signed integer types over unsigned integer types
     * and to avoid uint64 indices unless they are required by an application.
     */ indexType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * By default, dictionaries are not ordered, or the order does not have
     * semantic meaning. In some statistical, applications, dictionary-encoding
     * is used to represent ordered categorical data, and we provide a way to
     * preserve that metadata here
     */ isOrdered() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    dictionaryKind() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : dictionary_kind_js_1.DictionaryKind.DenseArray;
    }
    static startDictionaryEncoding(builder) {
        builder.startObject(4);
    }
    static addId(builder, id) {
        builder.addFieldInt64(0, id, BigInt('0'));
    }
    static addIndexType(builder, indexTypeOffset) {
        builder.addFieldOffset(1, indexTypeOffset, 0);
    }
    static addIsOrdered(builder, isOrdered) {
        builder.addFieldInt8(2, +isOrdered, +false);
    }
    static addDictionaryKind(builder, dictionaryKind) {
        builder.addFieldInt16(3, dictionaryKind, dictionary_kind_js_1.DictionaryKind.DenseArray);
    }
    static endDictionaryEncoding(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.DictionaryEncoding = DictionaryEncoding; //# sourceMappingURL=dictionary-encoding.js.map
}),
"[project]/node_modules/apache-arrow/fb/key-value.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KeyValue = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
/**
 * ----------------------------------------------------------------------
 * user defined key value pairs to add custom metadata to arrow
 * key namespacing is the responsibility of the user
 */ class KeyValue {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsKeyValue(bb, obj) {
        return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsKeyValue(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    value(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startKeyValue(builder) {
        builder.startObject(2);
    }
    static addKey(builder, keyOffset) {
        builder.addFieldOffset(0, keyOffset, 0);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(1, valueOffset, 0);
    }
    static endKeyValue(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createKeyValue(builder, keyOffset, valueOffset) {
        KeyValue.startKeyValue(builder);
        KeyValue.addKey(builder, keyOffset);
        KeyValue.addValue(builder, valueOffset);
        return KeyValue.endKeyValue(builder);
    }
}
exports.KeyValue = KeyValue; //# sourceMappingURL=key-value.js.map
}),
"[project]/node_modules/apache-arrow/fb/binary.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Binary = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
/**
 * Opaque binary data
 */ class Binary {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBinary(bb, obj) {
        return (obj || new Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBinary(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBinary(builder) {
        builder.startObject(0);
    }
    static endBinary(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBinary(builder) {
        Binary.startBinary(builder);
        return Binary.endBinary(builder);
    }
}
exports.Binary = Binary; //# sourceMappingURL=binary.js.map
}),
"[project]/node_modules/apache-arrow/fb/bool.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Bool = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
class Bool {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBool(bb, obj) {
        return (obj || new Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBool(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBool(builder) {
        builder.startObject(0);
    }
    static endBool(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBool(builder) {
        Bool.startBool(builder);
        return Bool.endBool(builder);
    }
}
exports.Bool = Bool; //# sourceMappingURL=bool.js.map
}),
"[project]/node_modules/apache-arrow/fb/date.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Date = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const date_unit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/date-unit.js [app-ssr] (ecmascript)");
/**
 * Date is either a 32-bit or 64-bit signed integer type representing an
 * elapsed time since UNIX epoch (1970-01-01), stored in either of two units:
 *
 * * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no
 *   leap seconds), where the values are evenly divisible by 86400000
 * * Days (32 bits) since the UNIX epoch
 */ class Date {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDate(bb, obj) {
        return (obj || new Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDate(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : date_unit_js_1.DateUnit.MILLISECOND;
    }
    static startDate(builder) {
        builder.startObject(1);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, date_unit_js_1.DateUnit.MILLISECOND);
    }
    static endDate(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDate(builder, unit) {
        Date.startDate(builder);
        Date.addUnit(builder, unit);
        return Date.endDate(builder);
    }
}
exports.Date = Date; //# sourceMappingURL=date.js.map
}),
"[project]/node_modules/apache-arrow/fb/decimal.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Decimal = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
/**
 * Exact decimal value represented as an integer value in two's
 * complement. Currently only 128-bit (16-byte) and 256-bit (32-byte) integers
 * are used. The representation uses the endianness indicated
 * in the Schema.
 */ class Decimal {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDecimal(bb, obj) {
        return (obj || new Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDecimal(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Total number of decimal digits
     */ precision() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of digits after the decimal point "."
     */ scale() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of bits per value. The only accepted widths are 128 and 256.
     * We use bitWidth for consistency with Int::bitWidth.
     */ bitWidth() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 128;
    }
    static startDecimal(builder) {
        builder.startObject(3);
    }
    static addPrecision(builder, precision) {
        builder.addFieldInt32(0, precision, 0);
    }
    static addScale(builder, scale) {
        builder.addFieldInt32(1, scale, 0);
    }
    static addBitWidth(builder, bitWidth) {
        builder.addFieldInt32(2, bitWidth, 128);
    }
    static endDecimal(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDecimal(builder, precision, scale, bitWidth) {
        Decimal.startDecimal(builder);
        Decimal.addPrecision(builder, precision);
        Decimal.addScale(builder, scale);
        Decimal.addBitWidth(builder, bitWidth);
        return Decimal.endDecimal(builder);
    }
}
exports.Decimal = Decimal; //# sourceMappingURL=decimal.js.map
}),
"[project]/node_modules/apache-arrow/fb/duration.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Duration = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const time_unit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/time-unit.js [app-ssr] (ecmascript)");
class Duration {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDuration(bb, obj) {
        return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDuration(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : time_unit_js_1.TimeUnit.MILLISECOND;
    }
    static startDuration(builder) {
        builder.startObject(1);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, time_unit_js_1.TimeUnit.MILLISECOND);
    }
    static endDuration(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDuration(builder, unit) {
        Duration.startDuration(builder);
        Duration.addUnit(builder, unit);
        return Duration.endDuration(builder);
    }
}
exports.Duration = Duration; //# sourceMappingURL=duration.js.map
}),
"[project]/node_modules/apache-arrow/fb/fixed-size-binary.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FixedSizeBinary = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
class FixedSizeBinary {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFixedSizeBinary(bb, obj) {
        return (obj || new FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeBinary(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Number of bytes per value
     */ byteWidth() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeBinary(builder) {
        builder.startObject(1);
    }
    static addByteWidth(builder, byteWidth) {
        builder.addFieldInt32(0, byteWidth, 0);
    }
    static endFixedSizeBinary(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createFixedSizeBinary(builder, byteWidth) {
        FixedSizeBinary.startFixedSizeBinary(builder);
        FixedSizeBinary.addByteWidth(builder, byteWidth);
        return FixedSizeBinary.endFixedSizeBinary(builder);
    }
}
exports.FixedSizeBinary = FixedSizeBinary; //# sourceMappingURL=fixed-size-binary.js.map
}),
"[project]/node_modules/apache-arrow/fb/fixed-size-list.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FixedSizeList = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
class FixedSizeList {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFixedSizeList(bb, obj) {
        return (obj || new FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeList(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Number of list items per value
     */ listSize() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeList(builder) {
        builder.startObject(1);
    }
    static addListSize(builder, listSize) {
        builder.addFieldInt32(0, listSize, 0);
    }
    static endFixedSizeList(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createFixedSizeList(builder, listSize) {
        FixedSizeList.startFixedSizeList(builder);
        FixedSizeList.addListSize(builder, listSize);
        return FixedSizeList.endFixedSizeList(builder);
    }
}
exports.FixedSizeList = FixedSizeList; //# sourceMappingURL=fixed-size-list.js.map
}),
"[project]/node_modules/apache-arrow/fb/floating-point.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FloatingPoint = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const precision_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/precision.js [app-ssr] (ecmascript)");
class FloatingPoint {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFloatingPoint(bb, obj) {
        return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFloatingPoint(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    precision() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : precision_js_1.Precision.HALF;
    }
    static startFloatingPoint(builder) {
        builder.startObject(1);
    }
    static addPrecision(builder, precision) {
        builder.addFieldInt16(0, precision, precision_js_1.Precision.HALF);
    }
    static endFloatingPoint(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createFloatingPoint(builder, precision) {
        FloatingPoint.startFloatingPoint(builder);
        FloatingPoint.addPrecision(builder, precision);
        return FloatingPoint.endFloatingPoint(builder);
    }
}
exports.FloatingPoint = FloatingPoint; //# sourceMappingURL=floating-point.js.map
}),
"[project]/node_modules/apache-arrow/fb/interval.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Interval = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const interval_unit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/interval-unit.js [app-ssr] (ecmascript)");
class Interval {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsInterval(bb, obj) {
        return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInterval(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : interval_unit_js_1.IntervalUnit.YEAR_MONTH;
    }
    static startInterval(builder) {
        builder.startObject(1);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, interval_unit_js_1.IntervalUnit.YEAR_MONTH);
    }
    static endInterval(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createInterval(builder, unit) {
        Interval.startInterval(builder);
        Interval.addUnit(builder, unit);
        return Interval.endInterval(builder);
    }
}
exports.Interval = Interval; //# sourceMappingURL=interval.js.map
}),
"[project]/node_modules/apache-arrow/fb/large-binary.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LargeBinary = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
/**
 * Same as Binary, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 */ class LargeBinary {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsLargeBinary(bb, obj) {
        return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLargeBinary(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startLargeBinary(builder) {
        builder.startObject(0);
    }
    static endLargeBinary(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createLargeBinary(builder) {
        LargeBinary.startLargeBinary(builder);
        return LargeBinary.endLargeBinary(builder);
    }
}
exports.LargeBinary = LargeBinary; //# sourceMappingURL=large-binary.js.map
}),
"[project]/node_modules/apache-arrow/fb/large-list.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LargeList = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
/**
 * Same as List, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 */ class LargeList {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsLargeList(bb, obj) {
        return (obj || new LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLargeList(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startLargeList(builder) {
        builder.startObject(0);
    }
    static endLargeList(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createLargeList(builder) {
        LargeList.startLargeList(builder);
        return LargeList.endLargeList(builder);
    }
}
exports.LargeList = LargeList; //# sourceMappingURL=large-list.js.map
}),
"[project]/node_modules/apache-arrow/fb/large-utf8.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LargeUtf8 = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
/**
 * Same as Utf8, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 */ class LargeUtf8 {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsLargeUtf8(bb, obj) {
        return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLargeUtf8(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startLargeUtf8(builder) {
        builder.startObject(0);
    }
    static endLargeUtf8(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createLargeUtf8(builder) {
        LargeUtf8.startLargeUtf8(builder);
        return LargeUtf8.endLargeUtf8(builder);
    }
}
exports.LargeUtf8 = LargeUtf8; //# sourceMappingURL=large-utf8.js.map
}),
"[project]/node_modules/apache-arrow/fb/list.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.List = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
class List {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsList(bb, obj) {
        return (obj || new List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsList(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startList(builder) {
        builder.startObject(0);
    }
    static endList(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createList(builder) {
        List.startList(builder);
        return List.endList(builder);
    }
}
exports.List = List; //# sourceMappingURL=list.js.map
}),
"[project]/node_modules/apache-arrow/fb/map.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Map = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
/**
 * A Map is a logical nested type that is represented as
 *
 * List<entries: Struct<key: K, value: V>>
 *
 * In this layout, the keys and values are each respectively contiguous. We do
 * not constrain the key and value types, so the application is responsible
 * for ensuring that the keys are hashable and unique. Whether the keys are sorted
 * may be set in the metadata for this field.
 *
 * In a field with Map type, the field has a child Struct field, which then
 * has two children: key type and the second the value type. The names of the
 * child fields may be respectively "entries", "key", and "value", but this is
 * not enforced.
 *
 * Map
 * ```text
 *   - child[0] entries: Struct
 *     - child[0] key: K
 *     - child[1] value: V
 * ```
 * Neither the "entries" field nor the "key" field may be nullable.
 *
 * The metadata is structured so that Arrow systems without special handling
 * for Map can make Map an alias for List. The "layout" attribute for the Map
 * field must have the same contents as a List.
 */ class Map {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMap(bb, obj) {
        return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMap(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Set to true if the keys within each value are sorted
     */ keysSorted() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startMap(builder) {
        builder.startObject(1);
    }
    static addKeysSorted(builder, keysSorted) {
        builder.addFieldInt8(0, +keysSorted, +false);
    }
    static endMap(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createMap(builder, keysSorted) {
        Map.startMap(builder);
        Map.addKeysSorted(builder, keysSorted);
        return Map.endMap(builder);
    }
}
exports.Map = Map; //# sourceMappingURL=map.js.map
}),
"[project]/node_modules/apache-arrow/fb/null.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Null = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
/**
 * These are stored in the flatbuffer in the Type union below
 */ class Null {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsNull(bb, obj) {
        return (obj || new Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsNull(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startNull(builder) {
        builder.startObject(0);
    }
    static endNull(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createNull(builder) {
        Null.startNull(builder);
        return Null.endNull(builder);
    }
}
exports.Null = Null; //# sourceMappingURL=null.js.map
}),
"[project]/node_modules/apache-arrow/fb/run-end-encoded.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RunEndEncoded = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
/**
 * Contains two child arrays, run_ends and values.
 * The run_ends child array must be a 16/32/64-bit integer array
 * which encodes the indices at which the run with the value in
 * each corresponding index in the values child array ends.
 * Like list/struct types, the value array can be of any type.
 */ class RunEndEncoded {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRunEndEncoded(bb, obj) {
        return (obj || new RunEndEncoded()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRunEndEncoded(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RunEndEncoded()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startRunEndEncoded(builder) {
        builder.startObject(0);
    }
    static endRunEndEncoded(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRunEndEncoded(builder) {
        RunEndEncoded.startRunEndEncoded(builder);
        return RunEndEncoded.endRunEndEncoded(builder);
    }
}
exports.RunEndEncoded = RunEndEncoded; //# sourceMappingURL=run-end-encoded.js.map
}),
"[project]/node_modules/apache-arrow/fb/struct-.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Struct_ = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
/**
 * A Struct_ in the flatbuffer metadata is the same as an Arrow Struct
 * (according to the physical memory layout). We used Struct_ here as
 * Struct is a reserved word in Flatbuffers
 */ class Struct_ {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsStruct_(bb, obj) {
        return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStruct_(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startStruct_(builder) {
        builder.startObject(0);
    }
    static endStruct_(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createStruct_(builder) {
        Struct_.startStruct_(builder);
        return Struct_.endStruct_(builder);
    }
}
exports.Struct_ = Struct_; //# sourceMappingURL=struct-.js.map
}),
"[project]/node_modules/apache-arrow/fb/time.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Time = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const time_unit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/time-unit.js [app-ssr] (ecmascript)");
/**
 * Time is either a 32-bit or 64-bit signed integer type representing an
 * elapsed time since midnight, stored in either of four units: seconds,
 * milliseconds, microseconds or nanoseconds.
 *
 * The integer `bitWidth` depends on the `unit` and must be one of the following:
 * * SECOND and MILLISECOND: 32 bits
 * * MICROSECOND and NANOSECOND: 64 bits
 *
 * The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds
 * (exclusive), adjusted for the time unit (for example, up to 86400000
 * exclusive for the MILLISECOND unit).
 * This definition doesn't allow for leap seconds. Time values from
 * measurements with leap seconds will need to be corrected when ingesting
 * into Arrow (for example by replacing the value 86400 with 86399).
 */ class Time {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTime(bb, obj) {
        return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTime(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : time_unit_js_1.TimeUnit.MILLISECOND;
    }
    bitWidth() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
    }
    static startTime(builder) {
        builder.startObject(2);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, time_unit_js_1.TimeUnit.MILLISECOND);
    }
    static addBitWidth(builder, bitWidth) {
        builder.addFieldInt32(1, bitWidth, 32);
    }
    static endTime(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTime(builder, unit, bitWidth) {
        Time.startTime(builder);
        Time.addUnit(builder, unit);
        Time.addBitWidth(builder, bitWidth);
        return Time.endTime(builder);
    }
}
exports.Time = Time; //# sourceMappingURL=time.js.map
}),
"[project]/node_modules/apache-arrow/fb/timestamp.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Timestamp = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const time_unit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/time-unit.js [app-ssr] (ecmascript)");
/**
 * Timestamp is a 64-bit signed integer representing an elapsed time since a
 * fixed epoch, stored in either of four units: seconds, milliseconds,
 * microseconds or nanoseconds, and is optionally annotated with a timezone.
 *
 * Timestamp values do not include any leap seconds (in other words, all
 * days are considered 86400 seconds long).
 *
 * Timestamps with a non-empty timezone
 * ------------------------------------
 *
 * If a Timestamp column has a non-empty timezone value, its epoch is
 * 1970-01-01 00:00:00 (January 1st 1970, midnight) in the *UTC* timezone
 * (the Unix epoch), regardless of the Timestamp's own timezone.
 *
 * Therefore, timestamp values with a non-empty timezone correspond to
 * physical points in time together with some additional information about
 * how the data was obtained and/or how to display it (the timezone).
 *
 *   For example, the timestamp value 0 with the timezone string "Europe/Paris"
 *   corresponds to "January 1st 1970, 00h00" in the UTC timezone, but the
 *   application may prefer to display it as "January 1st 1970, 01h00" in
 *   the Europe/Paris timezone (which is the same physical point in time).
 *
 * One consequence is that timestamp values with a non-empty timezone
 * can be compared and ordered directly, since they all share the same
 * well-known point of reference (the Unix epoch).
 *
 * Timestamps with an unset / empty timezone
 * -----------------------------------------
 *
 * If a Timestamp column has no timezone value, its epoch is
 * 1970-01-01 00:00:00 (January 1st 1970, midnight) in an *unknown* timezone.
 *
 * Therefore, timestamp values without a timezone cannot be meaningfully
 * interpreted as physical points in time, but only as calendar / clock
 * indications ("wall clock time") in an unspecified timezone.
 *
 *   For example, the timestamp value 0 with an empty timezone string
 *   corresponds to "January 1st 1970, 00h00" in an unknown timezone: there
 *   is not enough information to interpret it as a well-defined physical
 *   point in time.
 *
 * One consequence is that timestamp values without a timezone cannot
 * be reliably compared or ordered, since they may have different points of
 * reference.  In particular, it is *not* possible to interpret an unset
 * or empty timezone as the same as "UTC".
 *
 * Conversion between timezones
 * ----------------------------
 *
 * If a Timestamp column has a non-empty timezone, changing the timezone
 * to a different non-empty value is a metadata-only operation:
 * the timestamp values need not change as their point of reference remains
 * the same (the Unix epoch).
 *
 * However, if a Timestamp column has no timezone value, changing it to a
 * non-empty value requires to think about the desired semantics.
 * One possibility is to assume that the original timestamp values are
 * relative to the epoch of the timezone being set; timestamp values should
 * then adjusted to the Unix epoch (for example, changing the timezone from
 * empty to "Europe/Paris" would require converting the timestamp values
 * from "Europe/Paris" to "UTC", which seems counter-intuitive but is
 * nevertheless correct).
 *
 * Guidelines for encoding data from external libraries
 * ----------------------------------------------------
 *
 * Date & time libraries often have multiple different data types for temporal
 * data. In order to ease interoperability between different implementations the
 * Arrow project has some recommendations for encoding these types into a Timestamp
 * column.
 *
 * An "instant" represents a physical point in time that has no relevant timezone
 * (for example, astronomical data). To encode an instant, use a Timestamp with
 * the timezone string set to "UTC", and make sure the Timestamp values
 * are relative to the UTC epoch (January 1st 1970, midnight).
 *
 * A "zoned date-time" represents a physical point in time annotated with an
 * informative timezone (for example, the timezone in which the data was
 * recorded).  To encode a zoned date-time, use a Timestamp with the timezone
 * string set to the name of the timezone, and make sure the Timestamp values
 * are relative to the UTC epoch (January 1st 1970, midnight).
 *
 *  (There is some ambiguity between an instant and a zoned date-time with the
 *   UTC timezone.  Both of these are stored the same in Arrow.  Typically,
 *   this distinction does not matter.  If it does, then an application should
 *   use custom metadata or an extension type to distinguish between the two cases.)
 *
 * An "offset date-time" represents a physical point in time combined with an
 * explicit offset from UTC.  To encode an offset date-time, use a Timestamp
 * with the timezone string set to the numeric timezone offset string
 * (e.g. "+03:00"), and make sure the Timestamp values are relative to
 * the UTC epoch (January 1st 1970, midnight).
 *
 * A "naive date-time" (also called "local date-time" in some libraries)
 * represents a wall clock time combined with a calendar date, but with
 * no indication of how to map this information to a physical point in time.
 * Naive date-times must be handled with care because of this missing
 * information, and also because daylight saving time (DST) may make
 * some values ambiguous or nonexistent. A naive date-time may be
 * stored as a struct with Date and Time fields. However, it may also be
 * encoded into a Timestamp column with an empty timezone. The timestamp
 * values should be computed "as if" the timezone of the date-time values
 * was UTC; for example, the naive date-time "January 1st 1970, 00h00" would
 * be encoded as timestamp value 0.
 */ class Timestamp {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTimestamp(bb, obj) {
        return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTimestamp(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : time_unit_js_1.TimeUnit.SECOND;
    }
    timezone(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTimestamp(builder) {
        builder.startObject(2);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, time_unit_js_1.TimeUnit.SECOND);
    }
    static addTimezone(builder, timezoneOffset) {
        builder.addFieldOffset(1, timezoneOffset, 0);
    }
    static endTimestamp(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTimestamp(builder, unit, timezoneOffset) {
        Timestamp.startTimestamp(builder);
        Timestamp.addUnit(builder, unit);
        Timestamp.addTimezone(builder, timezoneOffset);
        return Timestamp.endTimestamp(builder);
    }
}
exports.Timestamp = Timestamp; //# sourceMappingURL=timestamp.js.map
}),
"[project]/node_modules/apache-arrow/fb/union.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Union = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const union_mode_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/union-mode.js [app-ssr] (ecmascript)");
/**
 * A union is a complex type with children in Field
 * By default ids in the type vector refer to the offsets in the children
 * optionally typeIds provides an indirection between the child offset and the type id
 * for each child `typeIds[offset]` is the id used in the type vector
 */ class Union {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsUnion(bb, obj) {
        return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUnion(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    mode() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : union_mode_js_1.UnionMode.Sparse;
    }
    typeIds(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    typeIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    typeIdsArray() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startUnion(builder) {
        builder.startObject(2);
    }
    static addMode(builder, mode) {
        builder.addFieldInt16(0, mode, union_mode_js_1.UnionMode.Sparse);
    }
    static addTypeIds(builder, typeIdsOffset) {
        builder.addFieldOffset(1, typeIdsOffset, 0);
    }
    static createTypeIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addInt32(data[i]);
        }
        return builder.endVector();
    }
    static startTypeIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endUnion(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createUnion(builder, mode, typeIdsOffset) {
        Union.startUnion(builder);
        Union.addMode(builder, mode);
        Union.addTypeIds(builder, typeIdsOffset);
        return Union.endUnion(builder);
    }
}
exports.Union = Union; //# sourceMappingURL=union.js.map
}),
"[project]/node_modules/apache-arrow/fb/utf8.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Utf8 = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
/**
 * Unicode with UTF-8 encoding
 */ class Utf8 {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsUtf8(bb, obj) {
        return (obj || new Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUtf8(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startUtf8(builder) {
        builder.startObject(0);
    }
    static endUtf8(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createUtf8(builder) {
        Utf8.startUtf8(builder);
        return Utf8.endUtf8(builder);
    }
}
exports.Utf8 = Utf8; //# sourceMappingURL=utf8.js.map
}),
"[project]/node_modules/apache-arrow/fb/type.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unionListToType = exports.unionToType = exports.Type = void 0;
const binary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/binary.js [app-ssr] (ecmascript)");
const bool_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/bool.js [app-ssr] (ecmascript)");
const date_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/date.js [app-ssr] (ecmascript)");
const decimal_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/decimal.js [app-ssr] (ecmascript)");
const duration_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/duration.js [app-ssr] (ecmascript)");
const fixed_size_binary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/fixed-size-binary.js [app-ssr] (ecmascript)");
const fixed_size_list_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/fixed-size-list.js [app-ssr] (ecmascript)");
const floating_point_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/floating-point.js [app-ssr] (ecmascript)");
const int_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/int.js [app-ssr] (ecmascript)");
const interval_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/interval.js [app-ssr] (ecmascript)");
const large_binary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/large-binary.js [app-ssr] (ecmascript)");
const large_list_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/large-list.js [app-ssr] (ecmascript)");
const large_utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/large-utf8.js [app-ssr] (ecmascript)");
const list_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/list.js [app-ssr] (ecmascript)");
const map_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/map.js [app-ssr] (ecmascript)");
const null_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/null.js [app-ssr] (ecmascript)");
const run_end_encoded_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/run-end-encoded.js [app-ssr] (ecmascript)");
const struct__js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/struct-.js [app-ssr] (ecmascript)");
const time_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/time.js [app-ssr] (ecmascript)");
const timestamp_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/timestamp.js [app-ssr] (ecmascript)");
const union_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/union.js [app-ssr] (ecmascript)");
const utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/utf8.js [app-ssr] (ecmascript)");
/**
 * ----------------------------------------------------------------------
 * Top-level Type value, enabling extensible type-specific metadata. We can
 * add new logical types to Type without breaking backwards compatibility
 */ var Type;
(function(Type) {
    Type[Type["NONE"] = 0] = "NONE";
    Type[Type["Null"] = 1] = "Null";
    Type[Type["Int"] = 2] = "Int";
    Type[Type["FloatingPoint"] = 3] = "FloatingPoint";
    Type[Type["Binary"] = 4] = "Binary";
    Type[Type["Utf8"] = 5] = "Utf8";
    Type[Type["Bool"] = 6] = "Bool";
    Type[Type["Decimal"] = 7] = "Decimal";
    Type[Type["Date"] = 8] = "Date";
    Type[Type["Time"] = 9] = "Time";
    Type[Type["Timestamp"] = 10] = "Timestamp";
    Type[Type["Interval"] = 11] = "Interval";
    Type[Type["List"] = 12] = "List";
    Type[Type["Struct_"] = 13] = "Struct_";
    Type[Type["Union"] = 14] = "Union";
    Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
    Type[Type["Map"] = 17] = "Map";
    Type[Type["Duration"] = 18] = "Duration";
    Type[Type["LargeBinary"] = 19] = "LargeBinary";
    Type[Type["LargeUtf8"] = 20] = "LargeUtf8";
    Type[Type["LargeList"] = 21] = "LargeList";
    Type[Type["RunEndEncoded"] = 22] = "RunEndEncoded";
})(Type || (exports.Type = Type = {}));
function unionToType(type, accessor) {
    switch(Type[type]){
        case 'NONE':
            return null;
        case 'Null':
            return accessor(new null_js_1.Null());
        case 'Int':
            return accessor(new int_js_1.Int());
        case 'FloatingPoint':
            return accessor(new floating_point_js_1.FloatingPoint());
        case 'Binary':
            return accessor(new binary_js_1.Binary());
        case 'Utf8':
            return accessor(new utf8_js_1.Utf8());
        case 'Bool':
            return accessor(new bool_js_1.Bool());
        case 'Decimal':
            return accessor(new decimal_js_1.Decimal());
        case 'Date':
            return accessor(new date_js_1.Date());
        case 'Time':
            return accessor(new time_js_1.Time());
        case 'Timestamp':
            return accessor(new timestamp_js_1.Timestamp());
        case 'Interval':
            return accessor(new interval_js_1.Interval());
        case 'List':
            return accessor(new list_js_1.List());
        case 'Struct_':
            return accessor(new struct__js_1.Struct_());
        case 'Union':
            return accessor(new union_js_1.Union());
        case 'FixedSizeBinary':
            return accessor(new fixed_size_binary_js_1.FixedSizeBinary());
        case 'FixedSizeList':
            return accessor(new fixed_size_list_js_1.FixedSizeList());
        case 'Map':
            return accessor(new map_js_1.Map());
        case 'Duration':
            return accessor(new duration_js_1.Duration());
        case 'LargeBinary':
            return accessor(new large_binary_js_1.LargeBinary());
        case 'LargeUtf8':
            return accessor(new large_utf8_js_1.LargeUtf8());
        case 'LargeList':
            return accessor(new large_list_js_1.LargeList());
        case 'RunEndEncoded':
            return accessor(new run_end_encoded_js_1.RunEndEncoded());
        default:
            return null;
    }
}
exports.unionToType = unionToType;
function unionListToType(type, accessor, index) {
    switch(Type[type]){
        case 'NONE':
            return null;
        case 'Null':
            return accessor(index, new null_js_1.Null());
        case 'Int':
            return accessor(index, new int_js_1.Int());
        case 'FloatingPoint':
            return accessor(index, new floating_point_js_1.FloatingPoint());
        case 'Binary':
            return accessor(index, new binary_js_1.Binary());
        case 'Utf8':
            return accessor(index, new utf8_js_1.Utf8());
        case 'Bool':
            return accessor(index, new bool_js_1.Bool());
        case 'Decimal':
            return accessor(index, new decimal_js_1.Decimal());
        case 'Date':
            return accessor(index, new date_js_1.Date());
        case 'Time':
            return accessor(index, new time_js_1.Time());
        case 'Timestamp':
            return accessor(index, new timestamp_js_1.Timestamp());
        case 'Interval':
            return accessor(index, new interval_js_1.Interval());
        case 'List':
            return accessor(index, new list_js_1.List());
        case 'Struct_':
            return accessor(index, new struct__js_1.Struct_());
        case 'Union':
            return accessor(index, new union_js_1.Union());
        case 'FixedSizeBinary':
            return accessor(index, new fixed_size_binary_js_1.FixedSizeBinary());
        case 'FixedSizeList':
            return accessor(index, new fixed_size_list_js_1.FixedSizeList());
        case 'Map':
            return accessor(index, new map_js_1.Map());
        case 'Duration':
            return accessor(index, new duration_js_1.Duration());
        case 'LargeBinary':
            return accessor(index, new large_binary_js_1.LargeBinary());
        case 'LargeUtf8':
            return accessor(index, new large_utf8_js_1.LargeUtf8());
        case 'LargeList':
            return accessor(index, new large_list_js_1.LargeList());
        case 'RunEndEncoded':
            return accessor(index, new run_end_encoded_js_1.RunEndEncoded());
        default:
            return null;
    }
}
exports.unionListToType = unionListToType; //# sourceMappingURL=type.js.map
}),
"[project]/node_modules/apache-arrow/fb/field.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Field = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const dictionary_encoding_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/dictionary-encoding.js [app-ssr] (ecmascript)");
const key_value_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/key-value.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/type.js [app-ssr] (ecmascript)");
/**
 * ----------------------------------------------------------------------
 * A field represents a named column in a record / row batch or child of a
 * nested type.
 */ class Field {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsField(bb, obj) {
        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsField(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Whether or not this field can contain nulls. Should be true in general.
     */ nullable() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    typeType() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
    }
    /**
     * This is the type of the decoded value if the field is dictionary encoded.
     */ type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * Present only if the field is dictionary encoded.
     */ dictionary(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new dictionary_encoding_js_1.DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * children apply only to nested data types like Struct, List and Union. For
     * primitive types children will have length 0.
     */ children(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    childrenLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * User-defined metadata
     */ customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startField(builder) {
        builder.startObject(7);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addNullable(builder, nullable) {
        builder.addFieldInt8(1, +nullable, +false);
    }
    static addTypeType(builder, typeType) {
        builder.addFieldInt8(2, typeType, type_js_1.Type.NONE);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(3, typeOffset, 0);
    }
    static addDictionary(builder, dictionaryOffset) {
        builder.addFieldOffset(4, dictionaryOffset, 0);
    }
    static addChildren(builder, childrenOffset) {
        builder.addFieldOffset(5, childrenOffset, 0);
    }
    static createChildrenVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startChildrenVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(6, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endField(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.Field = Field; //# sourceMappingURL=field.js.map
}),
"[project]/node_modules/apache-arrow/fb/schema.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Schema = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const endianness_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/endianness.js [app-ssr] (ecmascript)");
const field_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/field.js [app-ssr] (ecmascript)");
const key_value_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/key-value.js [app-ssr] (ecmascript)");
/**
 * ----------------------------------------------------------------------
 * A Schema describes the columns in a row batch
 */ class Schema {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSchema(bb, obj) {
        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSchema(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * endianness of the buffer
     * it is Little Endian by default
     * if endianness doesn't match the underlying system then the vectors need to be converted
     */ endianness() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : endianness_js_1.Endianness.Little;
    }
    fields(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new field_js_1.Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    fieldsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Features used in the stream/file.
     */ features(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    featuresLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startSchema(builder) {
        builder.startObject(4);
    }
    static addEndianness(builder, endianness) {
        builder.addFieldInt16(0, endianness, endianness_js_1.Endianness.Little);
    }
    static addFields(builder, fieldsOffset) {
        builder.addFieldOffset(1, fieldsOffset, 0);
    }
    static createFieldsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startFieldsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(2, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addFeatures(builder, featuresOffset) {
        builder.addFieldOffset(3, featuresOffset, 0);
    }
    static createFeaturesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startFeaturesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static endSchema(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishSchemaBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedSchemaBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
    static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
        Schema.startSchema(builder);
        Schema.addEndianness(builder, endianness);
        Schema.addFields(builder, fieldsOffset);
        Schema.addCustomMetadata(builder, customMetadataOffset);
        Schema.addFeatures(builder, featuresOffset);
        return Schema.endSchema(builder);
    }
}
exports.Schema = Schema; //# sourceMappingURL=schema.js.map
}),
"[project]/node_modules/apache-arrow/fb/sparse-matrix-compressed-axis.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SparseMatrixCompressedAxis = void 0;
var SparseMatrixCompressedAxis;
(function(SparseMatrixCompressedAxis) {
    SparseMatrixCompressedAxis[SparseMatrixCompressedAxis["Row"] = 0] = "Row";
    SparseMatrixCompressedAxis[SparseMatrixCompressedAxis["Column"] = 1] = "Column";
})(SparseMatrixCompressedAxis || (exports.SparseMatrixCompressedAxis = SparseMatrixCompressedAxis = {})); //# sourceMappingURL=sparse-matrix-compressed-axis.js.map
}),
"[project]/node_modules/apache-arrow/fb/sparse-matrix-index-csx.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SparseMatrixIndexCSX = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/buffer.js [app-ssr] (ecmascript)");
const int_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/int.js [app-ssr] (ecmascript)");
const sparse_matrix_compressed_axis_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/sparse-matrix-compressed-axis.js [app-ssr] (ecmascript)");
/**
 * Compressed Sparse format, that is matrix-specific.
 */ class SparseMatrixIndexCSX {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseMatrixIndexCSX(bb, obj) {
        return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseMatrixIndexCSX(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Which axis, row or column, is compressed
     */ compressedAxis() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : sparse_matrix_compressed_axis_js_1.SparseMatrixCompressedAxis.Row;
    }
    /**
     * The type of values in indptrBuffer
     */ indptrType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indptrBuffer stores the location and size of indptr array that
     * represents the range of the rows.
     * The i-th row spans from `indptr[i]` to `indptr[i+1]` in the data.
     * The length of this array is 1 + (the number of rows), and the type
     * of index value is long.
     *
     * For example, let X be the following 6x4 matrix:
     * ```text
     *   X := [[0, 1, 2, 0],
     *         [0, 0, 3, 0],
     *         [0, 4, 0, 5],
     *         [0, 0, 0, 0],
     *         [6, 0, 7, 8],
     *         [0, 9, 0, 0]].
     * ```
     * The array of non-zero values in X is:
     * ```text
     *   values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].
     * ```
     * And the indptr of X is:
     * ```text
     *   indptr(X) = [0, 2, 3, 5, 5, 8, 10].
     * ```
     */ indptrBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    /**
     * The type of values in indicesBuffer
     */ indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indicesBuffer stores the location and size of the array that
     * contains the column indices of the corresponding non-zero values.
     * The type of index value is long.
     *
     * For example, the indices of the above X is:
     * ```text
     *   indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].
     * ```
     * Note that the indices are sorted in lexicographical order for each row.
     */ indicesBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    static startSparseMatrixIndexCSX(builder) {
        builder.startObject(5);
    }
    static addCompressedAxis(builder, compressedAxis) {
        builder.addFieldInt16(0, compressedAxis, sparse_matrix_compressed_axis_js_1.SparseMatrixCompressedAxis.Row);
    }
    static addIndptrType(builder, indptrTypeOffset) {
        builder.addFieldOffset(1, indptrTypeOffset, 0);
    }
    static addIndptrBuffer(builder, indptrBufferOffset) {
        builder.addFieldStruct(2, indptrBufferOffset, 0);
    }
    static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(3, indicesTypeOffset, 0);
    }
    static addIndicesBuffer(builder, indicesBufferOffset) {
        builder.addFieldStruct(4, indicesBufferOffset, 0);
    }
    static endSparseMatrixIndexCSX(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // indptrType
        builder.requiredField(offset, 8); // indptrBuffer
        builder.requiredField(offset, 10); // indicesType
        builder.requiredField(offset, 12); // indicesBuffer
        return offset;
    }
}
exports.SparseMatrixIndexCSX = SparseMatrixIndexCSX; //# sourceMappingURL=sparse-matrix-index-csx.js.map
}),
"[project]/node_modules/apache-arrow/fb/sparse-tensor-index-coo.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SparseTensorIndexCOO = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/buffer.js [app-ssr] (ecmascript)");
const int_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/int.js [app-ssr] (ecmascript)");
/**
 * ----------------------------------------------------------------------
 * EXPERIMENTAL: Data structures for sparse tensors
 * Coordinate (COO) format of sparse tensor index.
 *
 * COO's index list are represented as a NxM matrix,
 * where N is the number of non-zero values,
 * and M is the number of dimensions of a sparse tensor.
 *
 * indicesBuffer stores the location and size of the data of this indices
 * matrix.  The value type and the stride of the indices matrix is
 * specified in indicesType and indicesStrides fields.
 *
 * For example, let X be a 2x3x4x5 tensor, and it has the following
 * 6 non-zero values:
 * ```text
 *   X[0, 1, 2, 0] := 1
 *   X[1, 1, 2, 3] := 2
 *   X[0, 2, 1, 0] := 3
 *   X[0, 1, 3, 0] := 4
 *   X[0, 1, 2, 1] := 5
 *   X[1, 2, 0, 4] := 6
 * ```
 * In COO format, the index matrix of X is the following 4x6 matrix:
 * ```text
 *   [[0, 0, 0, 0, 1, 1],
 *    [1, 1, 1, 2, 1, 2],
 *    [2, 2, 3, 1, 2, 0],
 *    [0, 1, 0, 0, 3, 4]]
 * ```
 * When isCanonical is true, the indices is sorted in lexicographical order
 * (row-major order), and it does not have duplicated entries.  Otherwise,
 * the indices may not be sorted, or may have duplicated entries.
 */ class SparseTensorIndexCOO {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseTensorIndexCOO(bb, obj) {
        return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseTensorIndexCOO(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * The type of values in indicesBuffer
     */ indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Non-negative byte offsets to advance one value cell along each dimension
     * If omitted, default to row-major order (C-like).
     */ indicesStrides(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    indicesStridesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The location and size of the indices matrix's data
     */ indicesBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    /**
     * This flag is true if and only if the indices matrix is sorted in
     * row-major order, and does not have duplicated entries.
     * This sort order is the same as of Tensorflow's SparseTensor,
     * but it is inverse order of SciPy's canonical coo_matrix
     * (SciPy employs column-major order for its coo_matrix).
     */ isCanonical() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startSparseTensorIndexCOO(builder) {
        builder.startObject(4);
    }
    static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(0, indicesTypeOffset, 0);
    }
    static addIndicesStrides(builder, indicesStridesOffset) {
        builder.addFieldOffset(1, indicesStridesOffset, 0);
    }
    static createIndicesStridesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startIndicesStridesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addIndicesBuffer(builder, indicesBufferOffset) {
        builder.addFieldStruct(2, indicesBufferOffset, 0);
    }
    static addIsCanonical(builder, isCanonical) {
        builder.addFieldInt8(3, +isCanonical, +false);
    }
    static endSparseTensorIndexCOO(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // indicesType
        builder.requiredField(offset, 8); // indicesBuffer
        return offset;
    }
}
exports.SparseTensorIndexCOO = SparseTensorIndexCOO; //# sourceMappingURL=sparse-tensor-index-coo.js.map
}),
"[project]/node_modules/apache-arrow/fb/sparse-tensor-index-csf.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SparseTensorIndexCSF = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/buffer.js [app-ssr] (ecmascript)");
const int_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/int.js [app-ssr] (ecmascript)");
/**
 * Compressed Sparse Fiber (CSF) sparse tensor index.
 */ class SparseTensorIndexCSF {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseTensorIndexCSF(bb, obj) {
        return (obj || new SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseTensorIndexCSF(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * CSF is a generalization of compressed sparse row (CSR) index.
     * See [smith2017knl](http://shaden.io/pub-files/smith2017knl.pdf)
     *
     * CSF index recursively compresses each dimension of a tensor into a set
     * of prefix trees. Each path from a root to leaf forms one tensor
     * non-zero index. CSF is implemented with two arrays of buffers and one
     * arrays of integers.
     *
     * For example, let X be a 2x3x4x5 tensor and let it have the following
     * 8 non-zero values:
     * ```text
     *   X[0, 0, 0, 1] := 1
     *   X[0, 0, 0, 2] := 2
     *   X[0, 1, 0, 0] := 3
     *   X[0, 1, 0, 2] := 4
     *   X[0, 1, 1, 0] := 5
     *   X[1, 1, 1, 0] := 6
     *   X[1, 1, 1, 1] := 7
     *   X[1, 1, 1, 2] := 8
     * ```
     * As a prefix tree this would be represented as:
     * ```text
     *         0          1
     *        / \         |
     *       0   1        1
     *      /   / \       |
     *     0   0   1      1
     *    /|  /|   |    /| |
     *   1 2 0 2   0   0 1 2
     * ```
     * The type of values in indptrBuffers
     */ indptrType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indptrBuffers stores the sparsity structure.
     * Each two consecutive dimensions in a tensor correspond to a buffer in
     * indptrBuffers. A pair of consecutive values at `indptrBuffers[dim][i]`
     * and `indptrBuffers[dim][i + 1]` signify a range of nodes in
     * `indicesBuffers[dim + 1]` who are children of `indicesBuffers[dim][i]` node.
     *
     * For example, the indptrBuffers for the above X is:
     * ```text
     *   indptrBuffer(X) = [
     *                       [0, 2, 3],
     *                       [0, 1, 3, 4],
     *                       [0, 2, 4, 5, 8]
     *                     ].
     * ```
     */ indptrBuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    indptrBuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The type of values in indicesBuffers
     */ indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indicesBuffers stores values of nodes.
     * Each tensor dimension corresponds to a buffer in indicesBuffers.
     * For example, the indicesBuffers for the above X is:
     * ```text
     *   indicesBuffer(X) = [
     *                        [0, 1],
     *                        [0, 1, 1],
     *                        [0, 0, 1, 1],
     *                        [1, 2, 0, 2, 0, 0, 1, 2]
     *                      ].
     * ```
     */ indicesBuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    indicesBuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * axisOrder stores the sequence in which dimensions were traversed to
     * produce the prefix tree.
     * For example, the axisOrder for the above X is:
     * ```text
     *   axisOrder(X) = [0, 1, 2, 3].
     * ```
     */ axisOrder(index) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    axisOrderLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    axisOrderArray() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startSparseTensorIndexCSF(builder) {
        builder.startObject(5);
    }
    static addIndptrType(builder, indptrTypeOffset) {
        builder.addFieldOffset(0, indptrTypeOffset, 0);
    }
    static addIndptrBuffers(builder, indptrBuffersOffset) {
        builder.addFieldOffset(1, indptrBuffersOffset, 0);
    }
    static startIndptrBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(2, indicesTypeOffset, 0);
    }
    static addIndicesBuffers(builder, indicesBuffersOffset) {
        builder.addFieldOffset(3, indicesBuffersOffset, 0);
    }
    static startIndicesBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addAxisOrder(builder, axisOrderOffset) {
        builder.addFieldOffset(4, axisOrderOffset, 0);
    }
    static createAxisOrderVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addInt32(data[i]);
        }
        return builder.endVector();
    }
    static startAxisOrderVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endSparseTensorIndexCSF(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // indptrType
        builder.requiredField(offset, 6); // indptrBuffers
        builder.requiredField(offset, 8); // indicesType
        builder.requiredField(offset, 10); // indicesBuffers
        builder.requiredField(offset, 12); // axisOrder
        return offset;
    }
}
exports.SparseTensorIndexCSF = SparseTensorIndexCSF; //# sourceMappingURL=sparse-tensor-index-csf.js.map
}),
"[project]/node_modules/apache-arrow/fb/sparse-tensor-index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unionListToSparseTensorIndex = exports.unionToSparseTensorIndex = exports.SparseTensorIndex = void 0;
const sparse_matrix_index_csx_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/sparse-matrix-index-csx.js [app-ssr] (ecmascript)");
const sparse_tensor_index_coo_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/sparse-tensor-index-coo.js [app-ssr] (ecmascript)");
const sparse_tensor_index_csf_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/sparse-tensor-index-csf.js [app-ssr] (ecmascript)");
var SparseTensorIndex;
(function(SparseTensorIndex) {
    SparseTensorIndex[SparseTensorIndex["NONE"] = 0] = "NONE";
    SparseTensorIndex[SparseTensorIndex["SparseTensorIndexCOO"] = 1] = "SparseTensorIndexCOO";
    SparseTensorIndex[SparseTensorIndex["SparseMatrixIndexCSX"] = 2] = "SparseMatrixIndexCSX";
    SparseTensorIndex[SparseTensorIndex["SparseTensorIndexCSF"] = 3] = "SparseTensorIndexCSF";
})(SparseTensorIndex || (exports.SparseTensorIndex = SparseTensorIndex = {}));
function unionToSparseTensorIndex(type, accessor) {
    switch(SparseTensorIndex[type]){
        case 'NONE':
            return null;
        case 'SparseTensorIndexCOO':
            return accessor(new sparse_tensor_index_coo_js_1.SparseTensorIndexCOO());
        case 'SparseMatrixIndexCSX':
            return accessor(new sparse_matrix_index_csx_js_1.SparseMatrixIndexCSX());
        case 'SparseTensorIndexCSF':
            return accessor(new sparse_tensor_index_csf_js_1.SparseTensorIndexCSF());
        default:
            return null;
    }
}
exports.unionToSparseTensorIndex = unionToSparseTensorIndex;
function unionListToSparseTensorIndex(type, accessor, index) {
    switch(SparseTensorIndex[type]){
        case 'NONE':
            return null;
        case 'SparseTensorIndexCOO':
            return accessor(index, new sparse_tensor_index_coo_js_1.SparseTensorIndexCOO());
        case 'SparseMatrixIndexCSX':
            return accessor(index, new sparse_matrix_index_csx_js_1.SparseMatrixIndexCSX());
        case 'SparseTensorIndexCSF':
            return accessor(index, new sparse_tensor_index_csf_js_1.SparseTensorIndexCSF());
        default:
            return null;
    }
}
exports.unionListToSparseTensorIndex = unionListToSparseTensorIndex; //# sourceMappingURL=sparse-tensor-index.js.map
}),
"[project]/node_modules/apache-arrow/fb/tensor-dim.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TensorDim = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
/**
 * ----------------------------------------------------------------------
 * Data structures for dense tensors
 * Shape data for a single axis in a tensor
 */ class TensorDim {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTensorDim(bb, obj) {
        return (obj || new TensorDim()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTensorDim(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new TensorDim()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Length of dimension
     */ size() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTensorDim(builder) {
        builder.startObject(2);
    }
    static addSize(builder, size) {
        builder.addFieldInt64(0, size, BigInt('0'));
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(1, nameOffset, 0);
    }
    static endTensorDim(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTensorDim(builder, size, nameOffset) {
        TensorDim.startTensorDim(builder);
        TensorDim.addSize(builder, size);
        TensorDim.addName(builder, nameOffset);
        return TensorDim.endTensorDim(builder);
    }
}
exports.TensorDim = TensorDim; //# sourceMappingURL=tensor-dim.js.map
}),
"[project]/node_modules/apache-arrow/fb/sparse-tensor.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SparseTensor = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/buffer.js [app-ssr] (ecmascript)");
const sparse_tensor_index_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/sparse-tensor-index.js [app-ssr] (ecmascript)");
const tensor_dim_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/tensor-dim.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/type.js [app-ssr] (ecmascript)");
class SparseTensor {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseTensor(bb, obj) {
        return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseTensor(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    typeType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
    }
    /**
     * The type of data contained in a value cell.
     * Currently only fixed-width value types are supported,
     * no strings or nested types.
     */ type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * The dimensions of the tensor, optionally named.
     */ shape(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new tensor_dim_js_1.TensorDim()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    shapeLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The number of non-zero values in a sparse tensor.
     */ nonZeroLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    sparseIndexType() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : sparse_tensor_index_js_1.SparseTensorIndex.NONE;
    }
    /**
     * Sparse tensor index
     */ sparseIndex(obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * The location and size of the tensor's data
     */ data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    static startSparseTensor(builder) {
        builder.startObject(7);
    }
    static addTypeType(builder, typeType) {
        builder.addFieldInt8(0, typeType, type_js_1.Type.NONE);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(1, typeOffset, 0);
    }
    static addShape(builder, shapeOffset) {
        builder.addFieldOffset(2, shapeOffset, 0);
    }
    static createShapeVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startShapeVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addNonZeroLength(builder, nonZeroLength) {
        builder.addFieldInt64(3, nonZeroLength, BigInt('0'));
    }
    static addSparseIndexType(builder, sparseIndexType) {
        builder.addFieldInt8(4, sparseIndexType, sparse_tensor_index_js_1.SparseTensorIndex.NONE);
    }
    static addSparseIndex(builder, sparseIndexOffset) {
        builder.addFieldOffset(5, sparseIndexOffset, 0);
    }
    static addData(builder, dataOffset) {
        builder.addFieldStruct(6, dataOffset, 0);
    }
    static endSparseTensor(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // type
        builder.requiredField(offset, 8); // shape
        builder.requiredField(offset, 14); // sparseIndex
        builder.requiredField(offset, 16); // data
        return offset;
    }
    static finishSparseTensorBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedSparseTensorBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
}
exports.SparseTensor = SparseTensor; //# sourceMappingURL=sparse-tensor.js.map
}),
"[project]/node_modules/apache-arrow/fb/tensor.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tensor = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/buffer.js [app-ssr] (ecmascript)");
const tensor_dim_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/tensor-dim.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/type.js [app-ssr] (ecmascript)");
class Tensor {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTensor(bb, obj) {
        return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTensor(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    typeType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
    }
    /**
     * The type of data contained in a value cell. Currently only fixed-width
     * value types are supported, no strings or nested types
     */ type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * The dimensions of the tensor, optionally named
     */ shape(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new tensor_dim_js_1.TensorDim()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    shapeLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Non-negative byte offsets to advance one value cell along each dimension
     * If omitted, default to row-major order (C-like).
     */ strides(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    stridesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The location and size of the tensor's data
     */ data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    static startTensor(builder) {
        builder.startObject(5);
    }
    static addTypeType(builder, typeType) {
        builder.addFieldInt8(0, typeType, type_js_1.Type.NONE);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(1, typeOffset, 0);
    }
    static addShape(builder, shapeOffset) {
        builder.addFieldOffset(2, shapeOffset, 0);
    }
    static createShapeVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startShapeVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addStrides(builder, stridesOffset) {
        builder.addFieldOffset(3, stridesOffset, 0);
    }
    static createStridesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startStridesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addData(builder, dataOffset) {
        builder.addFieldStruct(4, dataOffset, 0);
    }
    static endTensor(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // type
        builder.requiredField(offset, 8); // shape
        builder.requiredField(offset, 12); // data
        return offset;
    }
    static finishTensorBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedTensorBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
}
exports.Tensor = Tensor; //# sourceMappingURL=tensor.js.map
}),
"[project]/node_modules/apache-arrow/fb/message-header.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unionListToMessageHeader = exports.unionToMessageHeader = exports.MessageHeader = void 0;
const dictionary_batch_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/dictionary-batch.js [app-ssr] (ecmascript)");
const record_batch_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/record-batch.js [app-ssr] (ecmascript)");
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/schema.js [app-ssr] (ecmascript)");
const sparse_tensor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/sparse-tensor.js [app-ssr] (ecmascript)");
const tensor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/tensor.js [app-ssr] (ecmascript)");
/**
 * ----------------------------------------------------------------------
 * The root Message type
 * This union enables us to easily send different message types without
 * redundant storage, and in the future we can easily add new message types.
 *
 * Arrow implementations do not need to implement all of the message types,
 * which may include experimental metadata types. For maximum compatibility,
 * it is best to send data using RecordBatch
 */ var MessageHeader;
(function(MessageHeader) {
    MessageHeader[MessageHeader["NONE"] = 0] = "NONE";
    MessageHeader[MessageHeader["Schema"] = 1] = "Schema";
    MessageHeader[MessageHeader["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader[MessageHeader["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader[MessageHeader["Tensor"] = 4] = "Tensor";
    MessageHeader[MessageHeader["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader || (exports.MessageHeader = MessageHeader = {}));
function unionToMessageHeader(type, accessor) {
    switch(MessageHeader[type]){
        case 'NONE':
            return null;
        case 'Schema':
            return accessor(new schema_js_1.Schema());
        case 'DictionaryBatch':
            return accessor(new dictionary_batch_js_1.DictionaryBatch());
        case 'RecordBatch':
            return accessor(new record_batch_js_1.RecordBatch());
        case 'Tensor':
            return accessor(new tensor_js_1.Tensor());
        case 'SparseTensor':
            return accessor(new sparse_tensor_js_1.SparseTensor());
        default:
            return null;
    }
}
exports.unionToMessageHeader = unionToMessageHeader;
function unionListToMessageHeader(type, accessor, index) {
    switch(MessageHeader[type]){
        case 'NONE':
            return null;
        case 'Schema':
            return accessor(index, new schema_js_1.Schema());
        case 'DictionaryBatch':
            return accessor(index, new dictionary_batch_js_1.DictionaryBatch());
        case 'RecordBatch':
            return accessor(index, new record_batch_js_1.RecordBatch());
        case 'Tensor':
            return accessor(index, new tensor_js_1.Tensor());
        case 'SparseTensor':
            return accessor(index, new sparse_tensor_js_1.SparseTensor());
        default:
            return null;
    }
}
exports.unionListToMessageHeader = unionListToMessageHeader; //# sourceMappingURL=message-header.js.map
}),
"[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BufferType = exports.Type = exports.MessageHeader = exports.IntervalUnit = exports.TimeUnit = exports.DateUnit = exports.Precision = exports.UnionMode = exports.MetadataVersion = void 0;
var metadata_version_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/metadata-version.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "MetadataVersion", {
    enumerable: true,
    get: function() {
        return metadata_version_js_1.MetadataVersion;
    }
});
var union_mode_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/union-mode.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "UnionMode", {
    enumerable: true,
    get: function() {
        return union_mode_js_1.UnionMode;
    }
});
var precision_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/precision.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Precision", {
    enumerable: true,
    get: function() {
        return precision_js_1.Precision;
    }
});
var date_unit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/date-unit.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "DateUnit", {
    enumerable: true,
    get: function() {
        return date_unit_js_1.DateUnit;
    }
});
var time_unit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/time-unit.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "TimeUnit", {
    enumerable: true,
    get: function() {
        return time_unit_js_1.TimeUnit;
    }
});
var interval_unit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/interval-unit.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "IntervalUnit", {
    enumerable: true,
    get: function() {
        return interval_unit_js_1.IntervalUnit;
    }
});
var message_header_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/message-header.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "MessageHeader", {
    enumerable: true,
    get: function() {
        return message_header_js_1.MessageHeader;
    }
});
/**
 * Main data type enumeration.
 *
 * Data types in this library are all *logical*. They can be expressed as
 * either a primitive physical type (bytes or bits of some fixed size), a
 * nested type consisting of other data types, or another data type (e.g. a
 * timestamp encoded as an int64).
 *
 * **Note**: Only non-negative enum values are written to an Arrow IPC payload.
 *
 * The rest of the values are specified here so TypeScript can narrow the type
 * signatures further beyond the base Arrow Types. The Arrow DataTypes include
 * metadata like `bitWidth` that impact the type signatures of the values we
 * accept and return.
 *
 * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an
 * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`
 * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the
 * underlying `Int32Array`.
 *
 * Library consumers benefit by knowing the narrowest type, since we can ensure
 * the types across all public methods are propagated, and never bail to `any`.
 * These values are _never_ used at runtime, and they will _never_ be written
 * to the flatbuffers metadata of serialized Arrow IPC payloads.
 */ var Type;
(function(Type) {
    Type[Type["NONE"] = 0] = "NONE";
    Type[Type["Null"] = 1] = "Null";
    Type[Type["Int"] = 2] = "Int";
    Type[Type["Float"] = 3] = "Float";
    Type[Type["Binary"] = 4] = "Binary";
    Type[Type["Utf8"] = 5] = "Utf8";
    Type[Type["Bool"] = 6] = "Bool";
    Type[Type["Decimal"] = 7] = "Decimal";
    Type[Type["Date"] = 8] = "Date";
    Type[Type["Time"] = 9] = "Time";
    Type[Type["Timestamp"] = 10] = "Timestamp";
    Type[Type["Interval"] = 11] = "Interval";
    Type[Type["List"] = 12] = "List";
    Type[Type["Struct"] = 13] = "Struct";
    Type[Type["Union"] = 14] = "Union";
    Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
    Type[Type["Map"] = 17] = "Map";
    Type[Type["Duration"] = 18] = "Duration";
    Type[Type["LargeBinary"] = 19] = "LargeBinary";
    Type[Type["LargeUtf8"] = 20] = "LargeUtf8";
    Type[Type["Dictionary"] = -1] = "Dictionary";
    Type[Type["Int8"] = -2] = "Int8";
    Type[Type["Int16"] = -3] = "Int16";
    Type[Type["Int32"] = -4] = "Int32";
    Type[Type["Int64"] = -5] = "Int64";
    Type[Type["Uint8"] = -6] = "Uint8";
    Type[Type["Uint16"] = -7] = "Uint16";
    Type[Type["Uint32"] = -8] = "Uint32";
    Type[Type["Uint64"] = -9] = "Uint64";
    Type[Type["Float16"] = -10] = "Float16";
    Type[Type["Float32"] = -11] = "Float32";
    Type[Type["Float64"] = -12] = "Float64";
    Type[Type["DateDay"] = -13] = "DateDay";
    Type[Type["DateMillisecond"] = -14] = "DateMillisecond";
    Type[Type["TimestampSecond"] = -15] = "TimestampSecond";
    Type[Type["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type[Type["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type[Type["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type[Type["TimeSecond"] = -19] = "TimeSecond";
    Type[Type["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type[Type["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type[Type["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type[Type["DenseUnion"] = -23] = "DenseUnion";
    Type[Type["SparseUnion"] = -24] = "SparseUnion";
    Type[Type["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type[Type["IntervalYearMonth"] = -26] = "IntervalYearMonth";
    Type[Type["DurationSecond"] = -27] = "DurationSecond";
    Type[Type["DurationMillisecond"] = -28] = "DurationMillisecond";
    Type[Type["DurationMicrosecond"] = -29] = "DurationMicrosecond";
    Type[Type["DurationNanosecond"] = -30] = "DurationNanosecond";
})(Type || (exports.Type = Type = {}));
var BufferType;
(function(BufferType) {
    /**
     * used in List type, Dense Union and variable length primitive types (String, Binary)
     */ BufferType[BufferType["OFFSET"] = 0] = "OFFSET";
    /**
     * actual data, either fixed width primitive types in slots or variable width delimited by an OFFSET vector
     */ BufferType[BufferType["DATA"] = 1] = "DATA";
    /**
     * Bit vector indicating if each value is null
     */ BufferType[BufferType["VALIDITY"] = 2] = "VALIDITY";
    /**
     * Type vector used in Union type
     */ BufferType[BufferType["TYPE"] = 3] = "TYPE";
})(BufferType || (exports.BufferType = BufferType = {})); //# sourceMappingURL=enum.js.map
}),
"[project]/node_modules/apache-arrow/util/pretty.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.valueToString = void 0;
/** @ignore */ const undf = void 0;
/** @ignore */ function valueToString(x) {
    if (x === null) {
        return 'null';
    }
    if (x === undf) {
        return 'undefined';
    }
    switch(typeof x){
        case 'number':
            return `${x}`;
        case 'bigint':
            return `${x}`;
        case 'string':
            return `"${x}"`;
    }
    // If [Symbol.toPrimitive] is implemented (like in BN)
    // use it instead of JSON.stringify(). This ensures we
    // print BigInts, Decimals, and Binary in their native
    // representation
    if (typeof x[Symbol.toPrimitive] === 'function') {
        return x[Symbol.toPrimitive]('string');
    }
    if (ArrayBuffer.isView(x)) {
        if (x instanceof BigInt64Array || x instanceof BigUint64Array) {
            return `[${[
                ...x
            ].map((x)=>valueToString(x))}]`;
        }
        return `[${x}]`;
    }
    return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y)=>typeof y === 'bigint' ? `${y}` : y);
}
exports.valueToString = valueToString; //# sourceMappingURL=pretty.js.map
}),
"[project]/node_modules/apache-arrow/util/bigint.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.divideBigInts = exports.bigIntToNumber = void 0;
/**
 * Converts an integer as a number or bigint to a number, throwing an error if the input cannot safely be represented as a number.
 */ function bigIntToNumber(number) {
    if (typeof number === 'bigint' && (number < Number.MIN_SAFE_INTEGER || number > Number.MAX_SAFE_INTEGER)) {
        throw new TypeError(`${number} is not safe to convert to a number.`);
    }
    return Number(number);
}
exports.bigIntToNumber = bigIntToNumber;
/**
 * Duivides the bigint number by the divisor and returns the result as a number.
 * Dividing bigints always results in bigints so we don't get the remainder.
 * This function gives us the remainder but assumes that the result fits into a number.
 *
 * @param number The number to divide.
 * @param divisor The divisor.
 * @returns The result of the division as a number.
 */ function divideBigInts(number, divisor) {
    return bigIntToNumber(number / divisor) + bigIntToNumber(number % divisor) / bigIntToNumber(divisor);
}
exports.divideBigInts = divideBigInts; //# sourceMappingURL=bigint.js.map
}),
"[project]/node_modules/apache-arrow/util/bn.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BN = exports.bigNumToBigInt = exports.bigNumToString = exports.bigNumToNumber = exports.isArrowBigNumSymbol = void 0;
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
const bigint_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bigint.js [app-ssr] (ecmascript)");
/** @ignore */ exports.isArrowBigNumSymbol = Symbol.for('isArrowBigNum');
/** @ignore */ function BigNum(x, ...xs) {
    if (xs.length === 0) {
        return Object.setPrototypeOf((0, buffer_js_1.toArrayBufferView)(this['TypedArray'], x), this.constructor.prototype);
    }
    return Object.setPrototypeOf(new this['TypedArray'](x, ...xs), this.constructor.prototype);
}
BigNum.prototype[exports.isArrowBigNumSymbol] = true;
BigNum.prototype.toJSON = function() {
    return `"${bigNumToString(this)}"`;
};
BigNum.prototype.valueOf = function(scale) {
    return bigNumToNumber(this, scale);
};
BigNum.prototype.toString = function() {
    return bigNumToString(this);
};
BigNum.prototype[Symbol.toPrimitive] = function(hint = 'default') {
    switch(hint){
        case 'number':
            return bigNumToNumber(this);
        case 'string':
            return bigNumToString(this);
        case 'default':
            return bigNumToBigInt(this);
    }
    // @ts-ignore
    return bigNumToString(this);
};
/** @ignore */ function SignedBigNum(...args) {
    return BigNum.apply(this, args);
}
/** @ignore */ function UnsignedBigNum(...args) {
    return BigNum.apply(this, args);
}
/** @ignore */ function DecimalBigNum(...args) {
    return BigNum.apply(this, args);
}
Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
Object.assign(SignedBigNum.prototype, BigNum.prototype, {
    'constructor': SignedBigNum,
    'signed': true,
    'TypedArray': Int32Array,
    'BigIntArray': BigInt64Array
});
Object.assign(UnsignedBigNum.prototype, BigNum.prototype, {
    'constructor': UnsignedBigNum,
    'signed': false,
    'TypedArray': Uint32Array,
    'BigIntArray': BigUint64Array
});
Object.assign(DecimalBigNum.prototype, BigNum.prototype, {
    'constructor': DecimalBigNum,
    'signed': true,
    'TypedArray': Uint32Array,
    'BigIntArray': BigUint64Array
});
//FOR ES2020 COMPATIBILITY
const TWO_TO_THE_64 = BigInt(4294967296) * BigInt(4294967296); // 2^64 = 0x10000000000000000n
const TWO_TO_THE_64_MINUS_1 = TWO_TO_THE_64 - BigInt(1); // (2^32 * 2^32) - 1 = 0xFFFFFFFFFFFFFFFFn
/** @ignore */ function bigNumToNumber(bn, scale) {
    const { buffer, byteOffset, byteLength, 'signed': signed } = bn;
    const words = new BigUint64Array(buffer, byteOffset, byteLength / 8);
    const negative = signed && words.at(-1) & BigInt(1) << BigInt(63);
    let number = BigInt(0);
    let i = 0;
    if (negative) {
        for (const word of words){
            number |= (word ^ TWO_TO_THE_64_MINUS_1) * (BigInt(1) << BigInt(64 * i++));
        }
        number *= BigInt(-1);
        number -= BigInt(1);
    } else {
        for (const word of words){
            number |= word * (BigInt(1) << BigInt(64 * i++));
        }
    }
    if (typeof scale === 'number') {
        const denominator = BigInt(Math.pow(10, scale));
        const quotient = number / denominator;
        const remainder = number % denominator;
        return (0, bigint_js_1.bigIntToNumber)(quotient) + (0, bigint_js_1.bigIntToNumber)(remainder) / (0, bigint_js_1.bigIntToNumber)(denominator);
    }
    return (0, bigint_js_1.bigIntToNumber)(number);
}
exports.bigNumToNumber = bigNumToNumber;
/** @ignore */ function bigNumToString(a) {
    // use BigInt native implementation
    if (a.byteLength === 8) {
        const bigIntArray = new a['BigIntArray'](a.buffer, a.byteOffset, 1);
        return `${bigIntArray[0]}`;
    }
    // unsigned numbers
    if (!a['signed']) {
        return unsignedBigNumToString(a);
    }
    let array = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    // detect positive numbers
    const highOrderWord = new Int16Array([
        array.at(-1)
    ])[0];
    if (highOrderWord >= 0) {
        return unsignedBigNumToString(a);
    }
    // flip the negative value
    array = array.slice();
    let carry = 1;
    for(let i = 0; i < array.length; i++){
        const elem = array[i];
        const updated = ~elem + carry;
        array[i] = updated;
        carry &= elem === 0 ? 1 : 0;
    }
    const negated = unsignedBigNumToString(array);
    return `-${negated}`;
}
exports.bigNumToString = bigNumToString;
/** @ignore */ function bigNumToBigInt(a) {
    if (a.byteLength === 8) {
        const bigIntArray = new a['BigIntArray'](a.buffer, a.byteOffset, 1);
        return bigIntArray[0];
    } else {
        return bigNumToString(a);
    }
}
exports.bigNumToBigInt = bigNumToBigInt;
/** @ignore */ function unsignedBigNumToString(a) {
    let digits = '';
    const base64 = new Uint32Array(2);
    let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
    let i = -1;
    const n = base32.length - 1;
    do {
        for(base64[0] = base32[i = 0]; i < n;){
            base32[i++] = base64[1] = base64[0] / 10;
            base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];
        }
        base32[i] = base64[1] = base64[0] / 10;
        base64[0] = base64[0] - base64[1] * 10;
        digits = `${base64[0]}${digits}`;
    }while (checks[0] || checks[1] || checks[2] || checks[3])
    return digits !== null && digits !== void 0 ? digits : `0`;
}
/** @ignore */ class BN {
    /** @nocollapse */ static new(num, isSigned) {
        switch(isSigned){
            case true:
                return new SignedBigNum(num);
            case false:
                return new UnsignedBigNum(num);
        }
        switch(num.constructor){
            case Int8Array:
            case Int16Array:
            case Int32Array:
            case BigInt64Array:
                return new SignedBigNum(num);
        }
        if (num.byteLength === 16) {
            return new DecimalBigNum(num);
        }
        return new UnsignedBigNum(num);
    }
    /** @nocollapse */ static signed(num) {
        return new SignedBigNum(num);
    }
    /** @nocollapse */ static unsigned(num) {
        return new UnsignedBigNum(num);
    }
    /** @nocollapse */ static decimal(num) {
        return new DecimalBigNum(num);
    }
    constructor(num, isSigned){
        return BN.new(num, isSigned);
    }
}
exports.BN = BN; //# sourceMappingURL=bn.js.map
}),
"[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Map_ = exports.FixedSizeList = exports.FixedSizeBinary = exports.SparseUnion = exports.DenseUnion = exports.Union = exports.Struct = exports.List = exports.DurationNanosecond = exports.DurationMicrosecond = exports.DurationMillisecond = exports.DurationSecond = exports.Duration = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.TimeNanosecond = exports.TimeMicrosecond = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.DateMillisecond = exports.DateDay = exports.Date_ = exports.Decimal = exports.Bool = exports.LargeUtf8 = exports.Utf8 = exports.LargeBinary = exports.Binary = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Null = exports.DataType = void 0;
exports.strideForType = exports.Dictionary = void 0;
const bigint_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bigint.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
/**
 * An abstract base class for classes that encapsulate metadata about each of
 * the logical types that Arrow can represent.
 */ class DataType {
    /** @nocollapse */ static isNull(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Null;
    }
    /** @nocollapse */ static isInt(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Int;
    }
    /** @nocollapse */ static isFloat(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Float;
    }
    /** @nocollapse */ static isBinary(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Binary;
    }
    /** @nocollapse */ static isLargeBinary(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.LargeBinary;
    }
    /** @nocollapse */ static isUtf8(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Utf8;
    }
    /** @nocollapse */ static isLargeUtf8(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.LargeUtf8;
    }
    /** @nocollapse */ static isBool(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Bool;
    }
    /** @nocollapse */ static isDecimal(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Decimal;
    }
    /** @nocollapse */ static isDate(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Date;
    }
    /** @nocollapse */ static isTime(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Time;
    }
    /** @nocollapse */ static isTimestamp(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Timestamp;
    }
    /** @nocollapse */ static isInterval(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Interval;
    }
    /** @nocollapse */ static isDuration(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Duration;
    }
    /** @nocollapse */ static isList(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.List;
    }
    /** @nocollapse */ static isStruct(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Struct;
    }
    /** @nocollapse */ static isUnion(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Union;
    }
    /** @nocollapse */ static isFixedSizeBinary(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.FixedSizeBinary;
    }
    /** @nocollapse */ static isFixedSizeList(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.FixedSizeList;
    }
    /** @nocollapse */ static isMap(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Map;
    }
    /** @nocollapse */ static isDictionary(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Dictionary;
    }
    /** @nocollapse */ static isDenseUnion(x) {
        return DataType.isUnion(x) && x.mode === enum_js_1.UnionMode.Dense;
    }
    /** @nocollapse */ static isSparseUnion(x) {
        return DataType.isUnion(x) && x.mode === enum_js_1.UnionMode.Sparse;
    }
    constructor(typeId){
        this.typeId = typeId;
    }
}
exports.DataType = DataType;
_a = Symbol.toStringTag;
DataType[_a] = ((proto)=>{
    proto.children = null;
    proto.ArrayType = Array;
    proto.OffsetArrayType = Int32Array;
    return proto[Symbol.toStringTag] = 'DataType';
})(DataType.prototype);
/** @ignore */ class Null extends DataType {
    constructor(){
        super(enum_js_1.Type.Null);
    }
    toString() {
        return `Null`;
    }
}
exports.Null = Null;
_b = Symbol.toStringTag;
Null[_b] = ((proto)=>proto[Symbol.toStringTag] = 'Null')(Null.prototype);
/** @ignore */ class Int_ extends DataType {
    constructor(isSigned, bitWidth){
        super(enum_js_1.Type.Int);
        this.isSigned = isSigned;
        this.bitWidth = bitWidth;
    }
    get ArrayType() {
        switch(this.bitWidth){
            case 8:
                return this.isSigned ? Int8Array : Uint8Array;
            case 16:
                return this.isSigned ? Int16Array : Uint16Array;
            case 32:
                return this.isSigned ? Int32Array : Uint32Array;
            case 64:
                return this.isSigned ? BigInt64Array : BigUint64Array;
        }
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() {
        return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
    }
}
exports.Int = Int_;
_c = Symbol.toStringTag;
Int_[_c] = ((proto)=>{
    proto.isSigned = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = 'Int';
})(Int_.prototype);
/** @ignore */ class Int8 extends Int_ {
    constructor(){
        super(true, 8);
    }
    get ArrayType() {
        return Int8Array;
    }
}
exports.Int8 = Int8;
/** @ignore */ class Int16 extends Int_ {
    constructor(){
        super(true, 16);
    }
    get ArrayType() {
        return Int16Array;
    }
}
exports.Int16 = Int16;
/** @ignore */ class Int32 extends Int_ {
    constructor(){
        super(true, 32);
    }
    get ArrayType() {
        return Int32Array;
    }
}
exports.Int32 = Int32;
/** @ignore */ class Int64 extends Int_ {
    constructor(){
        super(true, 64);
    }
    get ArrayType() {
        return BigInt64Array;
    }
}
exports.Int64 = Int64;
/** @ignore */ class Uint8 extends Int_ {
    constructor(){
        super(false, 8);
    }
    get ArrayType() {
        return Uint8Array;
    }
}
exports.Uint8 = Uint8;
/** @ignore */ class Uint16 extends Int_ {
    constructor(){
        super(false, 16);
    }
    get ArrayType() {
        return Uint16Array;
    }
}
exports.Uint16 = Uint16;
/** @ignore */ class Uint32 extends Int_ {
    constructor(){
        super(false, 32);
    }
    get ArrayType() {
        return Uint32Array;
    }
}
exports.Uint32 = Uint32;
/** @ignore */ class Uint64 extends Int_ {
    constructor(){
        super(false, 64);
    }
    get ArrayType() {
        return BigUint64Array;
    }
}
exports.Uint64 = Uint64;
Object.defineProperty(Int8.prototype, 'ArrayType', {
    value: Int8Array
});
Object.defineProperty(Int16.prototype, 'ArrayType', {
    value: Int16Array
});
Object.defineProperty(Int32.prototype, 'ArrayType', {
    value: Int32Array
});
Object.defineProperty(Int64.prototype, 'ArrayType', {
    value: BigInt64Array
});
Object.defineProperty(Uint8.prototype, 'ArrayType', {
    value: Uint8Array
});
Object.defineProperty(Uint16.prototype, 'ArrayType', {
    value: Uint16Array
});
Object.defineProperty(Uint32.prototype, 'ArrayType', {
    value: Uint32Array
});
Object.defineProperty(Uint64.prototype, 'ArrayType', {
    value: BigUint64Array
});
/** @ignore */ class Float extends DataType {
    constructor(precision){
        super(enum_js_1.Type.Float);
        this.precision = precision;
    }
    get ArrayType() {
        switch(this.precision){
            case enum_js_1.Precision.HALF:
                return Uint16Array;
            case enum_js_1.Precision.SINGLE:
                return Float32Array;
            case enum_js_1.Precision.DOUBLE:
                return Float64Array;
        }
        // @ts-ignore
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() {
        return `Float${this.precision << 5 || 16}`;
    }
}
exports.Float = Float;
_d = Symbol.toStringTag;
Float[_d] = ((proto)=>{
    proto.precision = null;
    return proto[Symbol.toStringTag] = 'Float';
})(Float.prototype);
/** @ignore */ class Float16 extends Float {
    constructor(){
        super(enum_js_1.Precision.HALF);
    }
}
exports.Float16 = Float16;
/** @ignore */ class Float32 extends Float {
    constructor(){
        super(enum_js_1.Precision.SINGLE);
    }
}
exports.Float32 = Float32;
/** @ignore */ class Float64 extends Float {
    constructor(){
        super(enum_js_1.Precision.DOUBLE);
    }
}
exports.Float64 = Float64;
Object.defineProperty(Float16.prototype, 'ArrayType', {
    value: Uint16Array
});
Object.defineProperty(Float32.prototype, 'ArrayType', {
    value: Float32Array
});
Object.defineProperty(Float64.prototype, 'ArrayType', {
    value: Float64Array
});
/** @ignore */ class Binary extends DataType {
    constructor(){
        super(enum_js_1.Type.Binary);
    }
    toString() {
        return `Binary`;
    }
}
exports.Binary = Binary;
_e = Symbol.toStringTag;
Binary[_e] = ((proto)=>{
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'Binary';
})(Binary.prototype);
/** @ignore */ class LargeBinary extends DataType {
    constructor(){
        super(enum_js_1.Type.LargeBinary);
    }
    toString() {
        return `LargeBinary`;
    }
}
exports.LargeBinary = LargeBinary;
_f = Symbol.toStringTag;
LargeBinary[_f] = ((proto)=>{
    proto.ArrayType = Uint8Array;
    proto.OffsetArrayType = BigInt64Array;
    return proto[Symbol.toStringTag] = 'LargeBinary';
})(LargeBinary.prototype);
/** @ignore */ class Utf8 extends DataType {
    constructor(){
        super(enum_js_1.Type.Utf8);
    }
    toString() {
        return `Utf8`;
    }
}
exports.Utf8 = Utf8;
_g = Symbol.toStringTag;
Utf8[_g] = ((proto)=>{
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'Utf8';
})(Utf8.prototype);
/** @ignore */ class LargeUtf8 extends DataType {
    constructor(){
        super(enum_js_1.Type.LargeUtf8);
    }
    toString() {
        return `LargeUtf8`;
    }
}
exports.LargeUtf8 = LargeUtf8;
_h = Symbol.toStringTag;
LargeUtf8[_h] = ((proto)=>{
    proto.ArrayType = Uint8Array;
    proto.OffsetArrayType = BigInt64Array;
    return proto[Symbol.toStringTag] = 'LargeUtf8';
})(LargeUtf8.prototype);
/** @ignore */ class Bool extends DataType {
    constructor(){
        super(enum_js_1.Type.Bool);
    }
    toString() {
        return `Bool`;
    }
}
exports.Bool = Bool;
_j = Symbol.toStringTag;
Bool[_j] = ((proto)=>{
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'Bool';
})(Bool.prototype);
/** @ignore */ class Decimal extends DataType {
    constructor(scale, precision, bitWidth = 128){
        super(enum_js_1.Type.Decimal);
        this.scale = scale;
        this.precision = precision;
        this.bitWidth = bitWidth;
    }
    toString() {
        return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
    }
}
exports.Decimal = Decimal;
_k = Symbol.toStringTag;
Decimal[_k] = ((proto)=>{
    proto.scale = null;
    proto.precision = null;
    proto.ArrayType = Uint32Array;
    return proto[Symbol.toStringTag] = 'Decimal';
})(Decimal.prototype);
/** @ignore */ class Date_ extends DataType {
    constructor(unit){
        super(enum_js_1.Type.Date);
        this.unit = unit;
    }
    toString() {
        return `Date${(this.unit + 1) * 32}<${enum_js_1.DateUnit[this.unit]}>`;
    }
    get ArrayType() {
        return this.unit === enum_js_1.DateUnit.DAY ? Int32Array : BigInt64Array;
    }
}
exports.Date_ = Date_;
_l = Symbol.toStringTag;
Date_[_l] = ((proto)=>{
    proto.unit = null;
    return proto[Symbol.toStringTag] = 'Date';
})(Date_.prototype);
/** @ignore */ class DateDay extends Date_ {
    constructor(){
        super(enum_js_1.DateUnit.DAY);
    }
}
exports.DateDay = DateDay;
/**
 * A signed 64-bit date representing the elapsed time since UNIX epoch (1970-01-01) in milliseconds.
 * According to the specification, this should be treated as the number of days, in milliseconds,  since the UNIX epoch.
 * Therefore, values must be evenly divisible by `86_400_000` (the number of milliseconds in a standard day).
 *
 * Practically, validation that values of this type are evenly divisible by `86_400_000` is not enforced by this library
 * for performance and usability reasons.
 *
 * Users should prefer to use {@link DateDay} to cleanly represent the number of days. For JS dates,
 * {@link TimestampMillisecond} is the preferred type.
 *
 * @ignore
 */ class DateMillisecond extends Date_ {
    constructor(){
        super(enum_js_1.DateUnit.MILLISECOND);
    }
}
exports.DateMillisecond = DateMillisecond;
/** @ignore */ class Time_ extends DataType {
    constructor(unit, bitWidth){
        super(enum_js_1.Type.Time);
        this.unit = unit;
        this.bitWidth = bitWidth;
    }
    toString() {
        return `Time${this.bitWidth}<${enum_js_1.TimeUnit[this.unit]}>`;
    }
    get ArrayType() {
        switch(this.bitWidth){
            case 32:
                return Int32Array;
            case 64:
                return BigInt64Array;
        }
        // @ts-ignore
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
}
exports.Time = Time_;
_m = Symbol.toStringTag;
Time_[_m] = ((proto)=>{
    proto.unit = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = 'Time';
})(Time_.prototype);
/** @ignore */ class TimeSecond extends Time_ {
    constructor(){
        super(enum_js_1.TimeUnit.SECOND, 32);
    }
}
exports.TimeSecond = TimeSecond;
/** @ignore */ class TimeMillisecond extends Time_ {
    constructor(){
        super(enum_js_1.TimeUnit.MILLISECOND, 32);
    }
}
exports.TimeMillisecond = TimeMillisecond;
/** @ignore */ class TimeMicrosecond extends Time_ {
    constructor(){
        super(enum_js_1.TimeUnit.MICROSECOND, 64);
    }
}
exports.TimeMicrosecond = TimeMicrosecond;
/** @ignore */ class TimeNanosecond extends Time_ {
    constructor(){
        super(enum_js_1.TimeUnit.NANOSECOND, 64);
    }
}
exports.TimeNanosecond = TimeNanosecond;
/** @ignore */ class Timestamp_ extends DataType {
    constructor(unit, timezone){
        super(enum_js_1.Type.Timestamp);
        this.unit = unit;
        this.timezone = timezone;
    }
    toString() {
        return `Timestamp<${enum_js_1.TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
    }
}
exports.Timestamp = Timestamp_;
_o = Symbol.toStringTag;
Timestamp_[_o] = ((proto)=>{
    proto.unit = null;
    proto.timezone = null;
    proto.ArrayType = BigInt64Array;
    return proto[Symbol.toStringTag] = 'Timestamp';
})(Timestamp_.prototype);
/** @ignore */ class TimestampSecond extends Timestamp_ {
    constructor(timezone){
        super(enum_js_1.TimeUnit.SECOND, timezone);
    }
}
exports.TimestampSecond = TimestampSecond;
/** @ignore */ class TimestampMillisecond extends Timestamp_ {
    constructor(timezone){
        super(enum_js_1.TimeUnit.MILLISECOND, timezone);
    }
}
exports.TimestampMillisecond = TimestampMillisecond;
/** @ignore */ class TimestampMicrosecond extends Timestamp_ {
    constructor(timezone){
        super(enum_js_1.TimeUnit.MICROSECOND, timezone);
    }
}
exports.TimestampMicrosecond = TimestampMicrosecond;
/** @ignore */ class TimestampNanosecond extends Timestamp_ {
    constructor(timezone){
        super(enum_js_1.TimeUnit.NANOSECOND, timezone);
    }
}
exports.TimestampNanosecond = TimestampNanosecond;
/** @ignore */ class Interval_ extends DataType {
    constructor(unit){
        super(enum_js_1.Type.Interval);
        this.unit = unit;
    }
    toString() {
        return `Interval<${enum_js_1.IntervalUnit[this.unit]}>`;
    }
}
exports.Interval = Interval_;
_p = Symbol.toStringTag;
Interval_[_p] = ((proto)=>{
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = 'Interval';
})(Interval_.prototype);
/** @ignore */ class IntervalDayTime extends Interval_ {
    constructor(){
        super(enum_js_1.IntervalUnit.DAY_TIME);
    }
}
exports.IntervalDayTime = IntervalDayTime;
/** @ignore */ class IntervalYearMonth extends Interval_ {
    constructor(){
        super(enum_js_1.IntervalUnit.YEAR_MONTH);
    }
}
exports.IntervalYearMonth = IntervalYearMonth;
/** @ignore */ class Duration extends DataType {
    constructor(unit){
        super(enum_js_1.Type.Duration);
        this.unit = unit;
    }
    toString() {
        return `Duration<${enum_js_1.TimeUnit[this.unit]}>`;
    }
}
exports.Duration = Duration;
_q = Symbol.toStringTag;
Duration[_q] = ((proto)=>{
    proto.unit = null;
    proto.ArrayType = BigInt64Array;
    return proto[Symbol.toStringTag] = 'Duration';
})(Duration.prototype);
/** @ignore */ class DurationSecond extends Duration {
    constructor(){
        super(enum_js_1.TimeUnit.SECOND);
    }
}
exports.DurationSecond = DurationSecond;
/** @ignore */ class DurationMillisecond extends Duration {
    constructor(){
        super(enum_js_1.TimeUnit.MILLISECOND);
    }
}
exports.DurationMillisecond = DurationMillisecond;
/** @ignore */ class DurationMicrosecond extends Duration {
    constructor(){
        super(enum_js_1.TimeUnit.MICROSECOND);
    }
}
exports.DurationMicrosecond = DurationMicrosecond;
/** @ignore */ class DurationNanosecond extends Duration {
    constructor(){
        super(enum_js_1.TimeUnit.NANOSECOND);
    }
}
exports.DurationNanosecond = DurationNanosecond;
/** @ignore */ class List extends DataType {
    constructor(child){
        super(enum_js_1.Type.List);
        this.children = [
            child
        ];
    }
    toString() {
        return `List<${this.valueType}>`;
    }
    get valueType() {
        return this.children[0].type;
    }
    get valueField() {
        return this.children[0];
    }
    get ArrayType() {
        return this.valueType.ArrayType;
    }
}
exports.List = List;
_r = Symbol.toStringTag;
List[_r] = ((proto)=>{
    proto.children = null;
    return proto[Symbol.toStringTag] = 'List';
})(List.prototype);
/** @ignore */ class Struct extends DataType {
    constructor(children){
        super(enum_js_1.Type.Struct);
        this.children = children;
    }
    toString() {
        return `Struct<{${this.children.map((f)=>`${f.name}:${f.type}`).join(`, `)}}>`;
    }
}
exports.Struct = Struct;
_s = Symbol.toStringTag;
Struct[_s] = ((proto)=>{
    proto.children = null;
    return proto[Symbol.toStringTag] = 'Struct';
})(Struct.prototype);
/** @ignore */ class Union_ extends DataType {
    constructor(mode, typeIds, children){
        super(enum_js_1.Type.Union);
        this.mode = mode;
        this.children = children;
        this.typeIds = typeIds = Int32Array.from(typeIds);
        this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx)=>(typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, Object.create(null));
    }
    toString() {
        return `${this[Symbol.toStringTag]}<${this.children.map((x)=>`${x.type}`).join(` | `)}>`;
    }
}
exports.Union = Union_;
_t = Symbol.toStringTag;
Union_[_t] = ((proto)=>{
    proto.mode = null;
    proto.typeIds = null;
    proto.children = null;
    proto.typeIdToChildIndex = null;
    proto.ArrayType = Int8Array;
    return proto[Symbol.toStringTag] = 'Union';
})(Union_.prototype);
/** @ignore */ class DenseUnion extends Union_ {
    constructor(typeIds, children){
        super(enum_js_1.UnionMode.Dense, typeIds, children);
    }
}
exports.DenseUnion = DenseUnion;
/** @ignore */ class SparseUnion extends Union_ {
    constructor(typeIds, children){
        super(enum_js_1.UnionMode.Sparse, typeIds, children);
    }
}
exports.SparseUnion = SparseUnion;
/** @ignore */ class FixedSizeBinary extends DataType {
    constructor(byteWidth){
        super(enum_js_1.Type.FixedSizeBinary);
        this.byteWidth = byteWidth;
    }
    toString() {
        return `FixedSizeBinary[${this.byteWidth}]`;
    }
}
exports.FixedSizeBinary = FixedSizeBinary;
_u = Symbol.toStringTag;
FixedSizeBinary[_u] = ((proto)=>{
    proto.byteWidth = null;
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'FixedSizeBinary';
})(FixedSizeBinary.prototype);
/** @ignore */ class FixedSizeList extends DataType {
    constructor(listSize, child){
        super(enum_js_1.Type.FixedSizeList);
        this.listSize = listSize;
        this.children = [
            child
        ];
    }
    get valueType() {
        return this.children[0].type;
    }
    get valueField() {
        return this.children[0];
    }
    get ArrayType() {
        return this.valueType.ArrayType;
    }
    toString() {
        return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
    }
}
exports.FixedSizeList = FixedSizeList;
_v = Symbol.toStringTag;
FixedSizeList[_v] = ((proto)=>{
    proto.children = null;
    proto.listSize = null;
    return proto[Symbol.toStringTag] = 'FixedSizeList';
})(FixedSizeList.prototype);
/** @ignore */ class Map_ extends DataType {
    constructor(entries, keysSorted = false){
        var _y, _z, _0;
        super(enum_js_1.Type.Map);
        this.children = [
            entries
        ];
        this.keysSorted = keysSorted;
        // ARROW-8716
        // https://github.com/apache/arrow/issues/17168
        if (entries) {
            entries['name'] = 'entries';
            if ((_y = entries === null || entries === void 0 ? void 0 : entries.type) === null || _y === void 0 ? void 0 : _y.children) {
                const key = (_z = entries === null || entries === void 0 ? void 0 : entries.type) === null || _z === void 0 ? void 0 : _z.children[0];
                if (key) {
                    key['name'] = 'key';
                }
                const val = (_0 = entries === null || entries === void 0 ? void 0 : entries.type) === null || _0 === void 0 ? void 0 : _0.children[1];
                if (val) {
                    val['name'] = 'value';
                }
            }
        }
    }
    get keyType() {
        return this.children[0].type.children[0].type;
    }
    get valueType() {
        return this.children[0].type.children[1].type;
    }
    get childType() {
        return this.children[0].type;
    }
    toString() {
        return `Map<{${this.children[0].type.children.map((f)=>`${f.name}:${f.type}`).join(`, `)}}>`;
    }
}
exports.Map_ = Map_;
_w = Symbol.toStringTag;
Map_[_w] = ((proto)=>{
    proto.children = null;
    proto.keysSorted = null;
    return proto[Symbol.toStringTag] = 'Map_';
})(Map_.prototype);
/** @ignore */ const getId = ((atomicDictionaryId)=>()=>++atomicDictionaryId)(-1);
/** @ignore */ class Dictionary extends DataType {
    constructor(dictionary, indices, id, isOrdered){
        super(enum_js_1.Type.Dictionary);
        this.indices = indices;
        this.dictionary = dictionary;
        this.isOrdered = isOrdered || false;
        this.id = id == null ? getId() : (0, bigint_js_1.bigIntToNumber)(id);
    }
    get children() {
        return this.dictionary.children;
    }
    get valueType() {
        return this.dictionary;
    }
    get ArrayType() {
        return this.dictionary.ArrayType;
    }
    toString() {
        return `Dictionary<${this.indices}, ${this.dictionary}>`;
    }
}
exports.Dictionary = Dictionary;
_x = Symbol.toStringTag;
Dictionary[_x] = ((proto)=>{
    proto.id = null;
    proto.indices = null;
    proto.isOrdered = null;
    proto.dictionary = null;
    return proto[Symbol.toStringTag] = 'Dictionary';
})(Dictionary.prototype);
/** @ignore */ function strideForType(type) {
    const t = type;
    switch(type.typeId){
        case enum_js_1.Type.Decimal:
            return type.bitWidth / 32;
        case enum_js_1.Type.Interval:
            return 1 + t.unit;
        // case Type.Int: return 1 + +((t as Int_).bitWidth > 32);
        // case Type.Time: return 1 + +((t as Time_).bitWidth > 32);
        case enum_js_1.Type.FixedSizeList:
            return t.listSize;
        case enum_js_1.Type.FixedSizeBinary:
            return t.byteWidth;
        default:
            return 1;
    }
}
exports.strideForType = strideForType; //# sourceMappingURL=type.js.map
}),
"[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Visitor = void 0;
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
class Visitor {
    visitMany(nodes, ...args) {
        return nodes.map((node, i)=>this.visit(node, ...args.map((x)=>x[i])));
    }
    visit(...args) {
        return this.getVisitFn(args[0], false).apply(this, args);
    }
    getVisitFn(node, throwIfNotFound = true) {
        return getVisitFn(this, node, throwIfNotFound);
    }
    getVisitFnByTypeId(typeId, throwIfNotFound = true) {
        return getVisitFnByTypeId(this, typeId, throwIfNotFound);
    }
    visitNull(_node, ..._args) {
        return null;
    }
    visitBool(_node, ..._args) {
        return null;
    }
    visitInt(_node, ..._args) {
        return null;
    }
    visitFloat(_node, ..._args) {
        return null;
    }
    visitUtf8(_node, ..._args) {
        return null;
    }
    visitLargeUtf8(_node, ..._args) {
        return null;
    }
    visitBinary(_node, ..._args) {
        return null;
    }
    visitLargeBinary(_node, ..._args) {
        return null;
    }
    visitFixedSizeBinary(_node, ..._args) {
        return null;
    }
    visitDate(_node, ..._args) {
        return null;
    }
    visitTimestamp(_node, ..._args) {
        return null;
    }
    visitTime(_node, ..._args) {
        return null;
    }
    visitDecimal(_node, ..._args) {
        return null;
    }
    visitList(_node, ..._args) {
        return null;
    }
    visitStruct(_node, ..._args) {
        return null;
    }
    visitUnion(_node, ..._args) {
        return null;
    }
    visitDictionary(_node, ..._args) {
        return null;
    }
    visitInterval(_node, ..._args) {
        return null;
    }
    visitDuration(_node, ..._args) {
        return null;
    }
    visitFixedSizeList(_node, ..._args) {
        return null;
    }
    visitMap(_node, ..._args) {
        return null;
    }
}
exports.Visitor = Visitor;
/** @ignore */ function getVisitFn(visitor, node, throwIfNotFound = true) {
    if (typeof node === 'number') {
        return getVisitFnByTypeId(visitor, node, throwIfNotFound);
    }
    if (typeof node === 'string' && node in enum_js_1.Type) {
        return getVisitFnByTypeId(visitor, enum_js_1.Type[node], throwIfNotFound);
    }
    if (node && node instanceof type_js_1.DataType) {
        return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
    }
    if ((node === null || node === void 0 ? void 0 : node.type) && node.type instanceof type_js_1.DataType) {
        return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
    }
    return getVisitFnByTypeId(visitor, enum_js_1.Type.NONE, throwIfNotFound);
}
/** @ignore */ function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
    let fn = null;
    switch(dtype){
        case enum_js_1.Type.Null:
            fn = visitor.visitNull;
            break;
        case enum_js_1.Type.Bool:
            fn = visitor.visitBool;
            break;
        case enum_js_1.Type.Int:
            fn = visitor.visitInt;
            break;
        case enum_js_1.Type.Int8:
            fn = visitor.visitInt8 || visitor.visitInt;
            break;
        case enum_js_1.Type.Int16:
            fn = visitor.visitInt16 || visitor.visitInt;
            break;
        case enum_js_1.Type.Int32:
            fn = visitor.visitInt32 || visitor.visitInt;
            break;
        case enum_js_1.Type.Int64:
            fn = visitor.visitInt64 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint8:
            fn = visitor.visitUint8 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint16:
            fn = visitor.visitUint16 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint32:
            fn = visitor.visitUint32 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint64:
            fn = visitor.visitUint64 || visitor.visitInt;
            break;
        case enum_js_1.Type.Float:
            fn = visitor.visitFloat;
            break;
        case enum_js_1.Type.Float16:
            fn = visitor.visitFloat16 || visitor.visitFloat;
            break;
        case enum_js_1.Type.Float32:
            fn = visitor.visitFloat32 || visitor.visitFloat;
            break;
        case enum_js_1.Type.Float64:
            fn = visitor.visitFloat64 || visitor.visitFloat;
            break;
        case enum_js_1.Type.Utf8:
            fn = visitor.visitUtf8;
            break;
        case enum_js_1.Type.LargeUtf8:
            fn = visitor.visitLargeUtf8;
            break;
        case enum_js_1.Type.Binary:
            fn = visitor.visitBinary;
            break;
        case enum_js_1.Type.LargeBinary:
            fn = visitor.visitLargeBinary;
            break;
        case enum_js_1.Type.FixedSizeBinary:
            fn = visitor.visitFixedSizeBinary;
            break;
        case enum_js_1.Type.Date:
            fn = visitor.visitDate;
            break;
        case enum_js_1.Type.DateDay:
            fn = visitor.visitDateDay || visitor.visitDate;
            break;
        case enum_js_1.Type.DateMillisecond:
            fn = visitor.visitDateMillisecond || visitor.visitDate;
            break;
        case enum_js_1.Type.Timestamp:
            fn = visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampSecond:
            fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampMillisecond:
            fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampMicrosecond:
            fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampNanosecond:
            fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.Time:
            fn = visitor.visitTime;
            break;
        case enum_js_1.Type.TimeSecond:
            fn = visitor.visitTimeSecond || visitor.visitTime;
            break;
        case enum_js_1.Type.TimeMillisecond:
            fn = visitor.visitTimeMillisecond || visitor.visitTime;
            break;
        case enum_js_1.Type.TimeMicrosecond:
            fn = visitor.visitTimeMicrosecond || visitor.visitTime;
            break;
        case enum_js_1.Type.TimeNanosecond:
            fn = visitor.visitTimeNanosecond || visitor.visitTime;
            break;
        case enum_js_1.Type.Decimal:
            fn = visitor.visitDecimal;
            break;
        case enum_js_1.Type.List:
            fn = visitor.visitList;
            break;
        case enum_js_1.Type.Struct:
            fn = visitor.visitStruct;
            break;
        case enum_js_1.Type.Union:
            fn = visitor.visitUnion;
            break;
        case enum_js_1.Type.DenseUnion:
            fn = visitor.visitDenseUnion || visitor.visitUnion;
            break;
        case enum_js_1.Type.SparseUnion:
            fn = visitor.visitSparseUnion || visitor.visitUnion;
            break;
        case enum_js_1.Type.Dictionary:
            fn = visitor.visitDictionary;
            break;
        case enum_js_1.Type.Interval:
            fn = visitor.visitInterval;
            break;
        case enum_js_1.Type.IntervalDayTime:
            fn = visitor.visitIntervalDayTime || visitor.visitInterval;
            break;
        case enum_js_1.Type.IntervalYearMonth:
            fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
            break;
        case enum_js_1.Type.Duration:
            fn = visitor.visitDuration;
            break;
        case enum_js_1.Type.DurationSecond:
            fn = visitor.visitDurationSecond || visitor.visitDuration;
            break;
        case enum_js_1.Type.DurationMillisecond:
            fn = visitor.visitDurationMillisecond || visitor.visitDuration;
            break;
        case enum_js_1.Type.DurationMicrosecond:
            fn = visitor.visitDurationMicrosecond || visitor.visitDuration;
            break;
        case enum_js_1.Type.DurationNanosecond:
            fn = visitor.visitDurationNanosecond || visitor.visitDuration;
            break;
        case enum_js_1.Type.FixedSizeList:
            fn = visitor.visitFixedSizeList;
            break;
        case enum_js_1.Type.Map:
            fn = visitor.visitMap;
            break;
    }
    if (typeof fn === 'function') return fn;
    if (!throwIfNotFound) return ()=>null;
    throw new Error(`Unrecognized type '${enum_js_1.Type[dtype]}'`);
}
/** @ignore */ function inferDType(type) {
    switch(type.typeId){
        case enum_js_1.Type.Null:
            return enum_js_1.Type.Null;
        case enum_js_1.Type.Int:
            {
                const { bitWidth, isSigned } = type;
                switch(bitWidth){
                    case 8:
                        return isSigned ? enum_js_1.Type.Int8 : enum_js_1.Type.Uint8;
                    case 16:
                        return isSigned ? enum_js_1.Type.Int16 : enum_js_1.Type.Uint16;
                    case 32:
                        return isSigned ? enum_js_1.Type.Int32 : enum_js_1.Type.Uint32;
                    case 64:
                        return isSigned ? enum_js_1.Type.Int64 : enum_js_1.Type.Uint64;
                }
                // @ts-ignore
                return enum_js_1.Type.Int;
            }
        case enum_js_1.Type.Float:
            switch(type.precision){
                case enum_js_1.Precision.HALF:
                    return enum_js_1.Type.Float16;
                case enum_js_1.Precision.SINGLE:
                    return enum_js_1.Type.Float32;
                case enum_js_1.Precision.DOUBLE:
                    return enum_js_1.Type.Float64;
            }
            // @ts-ignore
            return enum_js_1.Type.Float;
        case enum_js_1.Type.Binary:
            return enum_js_1.Type.Binary;
        case enum_js_1.Type.LargeBinary:
            return enum_js_1.Type.LargeBinary;
        case enum_js_1.Type.Utf8:
            return enum_js_1.Type.Utf8;
        case enum_js_1.Type.LargeUtf8:
            return enum_js_1.Type.LargeUtf8;
        case enum_js_1.Type.Bool:
            return enum_js_1.Type.Bool;
        case enum_js_1.Type.Decimal:
            return enum_js_1.Type.Decimal;
        case enum_js_1.Type.Time:
            switch(type.unit){
                case enum_js_1.TimeUnit.SECOND:
                    return enum_js_1.Type.TimeSecond;
                case enum_js_1.TimeUnit.MILLISECOND:
                    return enum_js_1.Type.TimeMillisecond;
                case enum_js_1.TimeUnit.MICROSECOND:
                    return enum_js_1.Type.TimeMicrosecond;
                case enum_js_1.TimeUnit.NANOSECOND:
                    return enum_js_1.Type.TimeNanosecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Time;
        case enum_js_1.Type.Timestamp:
            switch(type.unit){
                case enum_js_1.TimeUnit.SECOND:
                    return enum_js_1.Type.TimestampSecond;
                case enum_js_1.TimeUnit.MILLISECOND:
                    return enum_js_1.Type.TimestampMillisecond;
                case enum_js_1.TimeUnit.MICROSECOND:
                    return enum_js_1.Type.TimestampMicrosecond;
                case enum_js_1.TimeUnit.NANOSECOND:
                    return enum_js_1.Type.TimestampNanosecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Timestamp;
        case enum_js_1.Type.Date:
            switch(type.unit){
                case enum_js_1.DateUnit.DAY:
                    return enum_js_1.Type.DateDay;
                case enum_js_1.DateUnit.MILLISECOND:
                    return enum_js_1.Type.DateMillisecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Date;
        case enum_js_1.Type.Interval:
            switch(type.unit){
                case enum_js_1.IntervalUnit.DAY_TIME:
                    return enum_js_1.Type.IntervalDayTime;
                case enum_js_1.IntervalUnit.YEAR_MONTH:
                    return enum_js_1.Type.IntervalYearMonth;
            }
            // @ts-ignore
            return enum_js_1.Type.Interval;
        case enum_js_1.Type.Duration:
            switch(type.unit){
                case enum_js_1.TimeUnit.SECOND:
                    return enum_js_1.Type.DurationSecond;
                case enum_js_1.TimeUnit.MILLISECOND:
                    return enum_js_1.Type.DurationMillisecond;
                case enum_js_1.TimeUnit.MICROSECOND:
                    return enum_js_1.Type.DurationMicrosecond;
                case enum_js_1.TimeUnit.NANOSECOND:
                    return enum_js_1.Type.DurationNanosecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Duration;
        case enum_js_1.Type.Map:
            return enum_js_1.Type.Map;
        case enum_js_1.Type.List:
            return enum_js_1.Type.List;
        case enum_js_1.Type.Struct:
            return enum_js_1.Type.Struct;
        case enum_js_1.Type.Union:
            switch(type.mode){
                case enum_js_1.UnionMode.Dense:
                    return enum_js_1.Type.DenseUnion;
                case enum_js_1.UnionMode.Sparse:
                    return enum_js_1.Type.SparseUnion;
            }
            // @ts-ignore
            return enum_js_1.Type.Union;
        case enum_js_1.Type.FixedSizeBinary:
            return enum_js_1.Type.FixedSizeBinary;
        case enum_js_1.Type.FixedSizeList:
            return enum_js_1.Type.FixedSizeList;
        case enum_js_1.Type.Dictionary:
            return enum_js_1.Type.Dictionary;
    }
    throw new Error(`Unrecognized type '${enum_js_1.Type[type.typeId]}'`);
}
// Add these here so they're picked up by the externs creator
// in the build, and closure-compiler doesn't minify them away
Visitor.prototype.visitInt8 = null;
Visitor.prototype.visitInt16 = null;
Visitor.prototype.visitInt32 = null;
Visitor.prototype.visitInt64 = null;
Visitor.prototype.visitUint8 = null;
Visitor.prototype.visitUint16 = null;
Visitor.prototype.visitUint32 = null;
Visitor.prototype.visitUint64 = null;
Visitor.prototype.visitFloat16 = null;
Visitor.prototype.visitFloat32 = null;
Visitor.prototype.visitFloat64 = null;
Visitor.prototype.visitDateDay = null;
Visitor.prototype.visitDateMillisecond = null;
Visitor.prototype.visitTimestampSecond = null;
Visitor.prototype.visitTimestampMillisecond = null;
Visitor.prototype.visitTimestampMicrosecond = null;
Visitor.prototype.visitTimestampNanosecond = null;
Visitor.prototype.visitTimeSecond = null;
Visitor.prototype.visitTimeMillisecond = null;
Visitor.prototype.visitTimeMicrosecond = null;
Visitor.prototype.visitTimeNanosecond = null;
Visitor.prototype.visitDenseUnion = null;
Visitor.prototype.visitSparseUnion = null;
Visitor.prototype.visitIntervalDayTime = null;
Visitor.prototype.visitIntervalYearMonth = null;
Visitor.prototype.visitDuration = null;
Visitor.prototype.visitDurationSecond = null;
Visitor.prototype.visitDurationMillisecond = null;
Visitor.prototype.visitDurationMicrosecond = null;
Visitor.prototype.visitDurationNanosecond = null; //# sourceMappingURL=visitor.js.map
}),
"[project]/node_modules/apache-arrow/util/math.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.float64ToUint16 = exports.uint16ToFloat64 = void 0;
const f64 = new Float64Array(1);
const u32 = new Uint32Array(f64.buffer);
/**
 * Convert uint16 (logically a float16) to a JS float64. Inspired by numpy's `npy_half_to_double`:
 * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L29
 * @param h {number} the uint16 to convert
 * @private
 * @ignore
 */ function uint16ToFloat64(h) {
    const expo = (h & 0x7C00) >> 10;
    const sigf = (h & 0x03FF) / 1024;
    const sign = Math.pow(-1, (h & 0x8000) >> 15);
    switch(expo){
        case 0x1F:
            return sign * (sigf ? Number.NaN : 1 / 0);
        case 0x00:
            return sign * (sigf ? 6.103515625e-5 * sigf : 0);
    }
    return sign * Math.pow(2, expo - 15) * (1 + sigf);
}
exports.uint16ToFloat64 = uint16ToFloat64;
/**
 * Convert a float64 to uint16 (assuming the float64 is logically a float16). Inspired by numpy's `npy_double_to_half`:
 * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L43
 * @param d {number} The float64 to convert
 * @private
 * @ignore
 */ function float64ToUint16(d) {
    if (d !== d) {
        return 0x7E00;
    } // NaN
    f64[0] = d;
    // Magic numbers:
    // 0x80000000 = 10000000 00000000 00000000 00000000 -- masks the 32nd bit
    // 0x7ff00000 = 01111111 11110000 00000000 00000000 -- masks the 21st-31st bits
    // 0x000fffff = 00000000 00001111 11111111 11111111 -- masks the 1st-20th bit
    const sign = (u32[1] & 0x80000000) >> 16 & 0xFFFF;
    let expo = u32[1] & 0x7FF00000, sigf = 0x0000;
    if (expo >= 0x40F00000) {
        //
        // If exponent overflowed, the float16 is either NaN or Infinity.
        // Rules to propagate the sign bit: mantissa > 0 ? NaN : +/-Infinity
        //
        // Magic numbers:
        // 0x40F00000 = 01000000 11110000 00000000 00000000 -- 6-bit exponent overflow
        // 0x7C000000 = 01111100 00000000 00000000 00000000 -- masks the 27th-31st bits
        //
        // returns:
        // qNaN, aka 32256 decimal, 0x7E00 hex, or 01111110 00000000 binary
        // sNaN, aka 32000 decimal, 0x7D00 hex, or 01111101 00000000 binary
        // +inf, aka 31744 decimal, 0x7C00 hex, or 01111100 00000000 binary
        // -inf, aka 64512 decimal, 0xFC00 hex, or 11111100 00000000 binary
        //
        // If mantissa is greater than 23 bits, set to +Infinity like numpy
        if (u32[0] > 0) {
            expo = 0x7C00;
        } else {
            expo = (expo & 0x7C000000) >> 16;
            sigf = (u32[1] & 0x000FFFFF) >> 10;
        }
    } else if (expo <= 0x3F000000) {
        //
        // If exponent underflowed, the float is either signed zero or subnormal.
        //
        // Magic numbers:
        // 0x3F000000 = 00111111 00000000 00000000 00000000 -- 6-bit exponent underflow
        //
        sigf = 0x100000 + (u32[1] & 0x000FFFFF);
        sigf = 0x100000 + (sigf << (expo >> 20) - 998) >> 21;
        expo = 0;
    } else {
        //
        // No overflow or underflow, rebase the exponent and round the mantissa
        // Magic numbers:
        // 0x200 = 00000010 00000000 -- masks off the 10th bit
        //
        // Ensure the first mantissa bit (the 10th one) is 1 and round
        expo = expo - 0x3F000000 >> 10;
        sigf = (u32[1] & 0x000FFFFF) + 0x200 >> 10;
    }
    return sign | expo | sigf & 0xFFFF;
}
exports.float64ToUint16 = float64ToUint16; //# sourceMappingURL=math.js.map
}),
"[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.instance = exports.setDuration = exports.setDurationNanosecond = exports.setDurationMicrosecond = exports.setDurationMillisecond = exports.setDurationSecond = exports.setIntervalYearMonth = exports.setIntervalDayTime = exports.setIntervalValue = exports.setDecimal = exports.setTime = exports.setTimeNanosecond = exports.setTimeMicrosecond = exports.setTimeMillisecond = exports.setTimeSecond = exports.setTimestamp = exports.setTimestampNanosecond = exports.setTimestampMicrosecond = exports.setTimestampMillisecond = exports.setTimestampSecond = exports.setDate = exports.setFixedSizeBinary = exports.setDateMillisecond = exports.setDateDay = exports.setAnyFloat = exports.setFloat16 = exports.setFloat = exports.setInt = exports.setVariableWidthBytes = exports.setEpochMsToDays = exports.SetVisitor = void 0;
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
const bigint_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bigint.js [app-ssr] (ecmascript)");
const utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/utf8.js [app-ssr] (ecmascript)");
const math_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/math.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
/** @ignore */ class SetVisitor extends visitor_js_1.Visitor {
}
exports.SetVisitor = SetVisitor;
/** @ignore */ function wrapSet(fn) {
    return (data, _1, _2)=>{
        if (data.setValid(_1, _2 != null)) {
            return fn(data, _1, _2);
        }
    };
}
/** @ignore */ const setEpochMsToDays = (data, index, epochMs)=>{
    data[index] = Math.floor(epochMs / 86400000);
};
exports.setEpochMsToDays = setEpochMsToDays;
/** @ignore */ const setVariableWidthBytes = (values, valueOffsets, index, value)=>{
    if (index + 1 < valueOffsets.length) {
        const x = (0, bigint_js_1.bigIntToNumber)(valueOffsets[index]);
        const y = (0, bigint_js_1.bigIntToNumber)(valueOffsets[index + 1]);
        values.set(value.subarray(0, y - x), x);
    }
};
exports.setVariableWidthBytes = setVariableWidthBytes;
/** @ignore */ const setBool = ({ offset, values }, index, val)=>{
    const idx = offset + index;
    val ? values[idx >> 3] |= 1 << idx % 8 : values[idx >> 3] &= ~(1 << idx % 8); // false
};
/** @ignore */ const setInt = ({ values }, index, value)=>{
    values[index] = value;
};
exports.setInt = setInt;
/** @ignore */ const setFloat = ({ values }, index, value)=>{
    values[index] = value;
};
exports.setFloat = setFloat;
/** @ignore */ const setFloat16 = ({ values }, index, value)=>{
    values[index] = (0, math_js_1.float64ToUint16)(value);
};
exports.setFloat16 = setFloat16;
/* istanbul ignore next */ /** @ignore */ const setAnyFloat = (data, index, value)=>{
    switch(data.type.precision){
        case enum_js_1.Precision.HALF:
            return (0, exports.setFloat16)(data, index, value);
        case enum_js_1.Precision.SINGLE:
        case enum_js_1.Precision.DOUBLE:
            return (0, exports.setFloat)(data, index, value);
    }
};
exports.setAnyFloat = setAnyFloat;
/** @ignore */ const setDateDay = ({ values }, index, value)=>{
    (0, exports.setEpochMsToDays)(values, index, value.valueOf());
};
exports.setDateDay = setDateDay;
/** @ignore */ const setDateMillisecond = ({ values }, index, value)=>{
    values[index] = BigInt(value);
};
exports.setDateMillisecond = setDateMillisecond;
/** @ignore */ const setFixedSizeBinary = ({ stride, values }, index, value)=>{
    values.set(value.subarray(0, stride), stride * index);
};
exports.setFixedSizeBinary = setFixedSizeBinary;
/** @ignore */ const setBinary = ({ values, valueOffsets }, index, value)=>(0, exports.setVariableWidthBytes)(values, valueOffsets, index, value);
/** @ignore */ const setUtf8 = ({ values, valueOffsets }, index, value)=>(0, exports.setVariableWidthBytes)(values, valueOffsets, index, (0, utf8_js_1.encodeUtf8)(value));
/* istanbul ignore next */ const setDate = (data, index, value)=>{
    data.type.unit === enum_js_1.DateUnit.DAY ? (0, exports.setDateDay)(data, index, value) : (0, exports.setDateMillisecond)(data, index, value);
};
exports.setDate = setDate;
/** @ignore */ const setTimestampSecond = ({ values }, index, value)=>{
    values[index] = BigInt(value / 1000);
};
exports.setTimestampSecond = setTimestampSecond;
/** @ignore */ const setTimestampMillisecond = ({ values }, index, value)=>{
    values[index] = BigInt(value);
};
exports.setTimestampMillisecond = setTimestampMillisecond;
/** @ignore */ const setTimestampMicrosecond = ({ values }, index, value)=>{
    values[index] = BigInt(value * 1000);
};
exports.setTimestampMicrosecond = setTimestampMicrosecond;
/** @ignore */ const setTimestampNanosecond = ({ values }, index, value)=>{
    values[index] = BigInt(value * 1000000);
};
exports.setTimestampNanosecond = setTimestampNanosecond;
/* istanbul ignore next */ /** @ignore */ const setTimestamp = (data, index, value)=>{
    switch(data.type.unit){
        case enum_js_1.TimeUnit.SECOND:
            return (0, exports.setTimestampSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND:
            return (0, exports.setTimestampMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND:
            return (0, exports.setTimestampMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND:
            return (0, exports.setTimestampNanosecond)(data, index, value);
    }
};
exports.setTimestamp = setTimestamp;
/** @ignore */ const setTimeSecond = ({ values }, index, value)=>{
    values[index] = value;
};
exports.setTimeSecond = setTimeSecond;
/** @ignore */ const setTimeMillisecond = ({ values }, index, value)=>{
    values[index] = value;
};
exports.setTimeMillisecond = setTimeMillisecond;
/** @ignore */ const setTimeMicrosecond = ({ values }, index, value)=>{
    values[index] = value;
};
exports.setTimeMicrosecond = setTimeMicrosecond;
/** @ignore */ const setTimeNanosecond = ({ values }, index, value)=>{
    values[index] = value;
};
exports.setTimeNanosecond = setTimeNanosecond;
/* istanbul ignore next */ /** @ignore */ const setTime = (data, index, value)=>{
    switch(data.type.unit){
        case enum_js_1.TimeUnit.SECOND:
            return (0, exports.setTimeSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND:
            return (0, exports.setTimeMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND:
            return (0, exports.setTimeMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND:
            return (0, exports.setTimeNanosecond)(data, index, value);
    }
};
exports.setTime = setTime;
/** @ignore */ const setDecimal = ({ values, stride }, index, value)=>{
    values.set(value.subarray(0, stride), stride * index);
};
exports.setDecimal = setDecimal;
/** @ignore */ const setList = (data, index, value)=>{
    const values = data.children[0];
    const valueOffsets = data.valueOffsets;
    const set = exports.instance.getVisitFn(values);
    if (Array.isArray(value)) {
        for(let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end;){
            set(values, itr++, value[++idx]);
        }
    } else {
        for(let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end;){
            set(values, itr++, value.get(++idx));
        }
    }
};
/** @ignore */ const setMap = (data, index, value)=>{
    const values = data.children[0];
    const { valueOffsets } = data;
    const set = exports.instance.getVisitFn(values);
    let { [index]: idx, [index + 1]: end } = valueOffsets;
    const entries = value instanceof Map ? value.entries() : Object.entries(value);
    for (const val of entries){
        set(values, idx, val);
        if (++idx >= end) break;
    }
};
/** @ignore */ const _setStructArrayValue = (o, v)=>(set, c, _, i)=>c && set(c, o, v[i]);
/** @ignore */ const _setStructVectorValue = (o, v)=>(set, c, _, i)=>c && set(c, o, v.get(i));
/** @ignore */ const _setStructMapValue = (o, v)=>(set, c, f, _)=>c && set(c, o, v.get(f.name));
/** @ignore */ const _setStructObjectValue = (o, v)=>(set, c, f, _)=>c && set(c, o, v[f.name]);
/** @ignore */ const setStruct = (data, index, value)=>{
    const childSetters = data.type.children.map((f)=>exports.instance.getVisitFn(f.type));
    const set = value instanceof Map ? _setStructMapValue(index, value) : value instanceof vector_js_1.Vector ? _setStructVectorValue(index, value) : Array.isArray(value) ? _setStructArrayValue(index, value) : _setStructObjectValue(index, value);
    // eslint-disable-next-line unicorn/no-array-for-each
    data.type.children.forEach((f, i)=>set(childSetters[i], data.children[i], f, i));
};
/* istanbul ignore next */ /** @ignore */ const setUnion = (data, index, value)=>{
    data.type.mode === enum_js_1.UnionMode.Dense ? setDenseUnion(data, index, value) : setSparseUnion(data, index, value);
};
/** @ignore */ const setDenseUnion = (data, index, value)=>{
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    exports.instance.visit(child, data.valueOffsets[index], value);
};
/** @ignore */ const setSparseUnion = (data, index, value)=>{
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    exports.instance.visit(child, index, value);
};
/** @ignore */ const setDictionary = (data, index, value)=>{
    var _a;
    (_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.set(data.values[index], value);
};
/* istanbul ignore next */ /** @ignore */ const setIntervalValue = (data, index, value)=>{
    data.type.unit === enum_js_1.IntervalUnit.DAY_TIME ? (0, exports.setIntervalDayTime)(data, index, value) : (0, exports.setIntervalYearMonth)(data, index, value);
};
exports.setIntervalValue = setIntervalValue;
/** @ignore */ const setIntervalDayTime = ({ values }, index, value)=>{
    values.set(value.subarray(0, 2), 2 * index);
};
exports.setIntervalDayTime = setIntervalDayTime;
/** @ignore */ const setIntervalYearMonth = ({ values }, index, value)=>{
    values[index] = value[0] * 12 + value[1] % 12;
};
exports.setIntervalYearMonth = setIntervalYearMonth;
/** @ignore */ const setDurationSecond = ({ values }, index, value)=>{
    values[index] = value;
};
exports.setDurationSecond = setDurationSecond;
/** @ignore */ const setDurationMillisecond = ({ values }, index, value)=>{
    values[index] = value;
};
exports.setDurationMillisecond = setDurationMillisecond;
/** @ignore */ const setDurationMicrosecond = ({ values }, index, value)=>{
    values[index] = value;
};
exports.setDurationMicrosecond = setDurationMicrosecond;
/** @ignore */ const setDurationNanosecond = ({ values }, index, value)=>{
    values[index] = value;
};
exports.setDurationNanosecond = setDurationNanosecond;
/* istanbul ignore next */ /** @ignore */ const setDuration = (data, index, value)=>{
    switch(data.type.unit){
        case enum_js_1.TimeUnit.SECOND:
            return (0, exports.setDurationSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND:
            return (0, exports.setDurationMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND:
            return (0, exports.setDurationMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND:
            return (0, exports.setDurationNanosecond)(data, index, value);
    }
};
exports.setDuration = setDuration;
/** @ignore */ const setFixedSizeList = (data, index, value)=>{
    const { stride } = data;
    const child = data.children[0];
    const set = exports.instance.getVisitFn(child);
    if (Array.isArray(value)) {
        for(let idx = -1, offset = index * stride; ++idx < stride;){
            set(child, offset + idx, value[idx]);
        }
    } else {
        for(let idx = -1, offset = index * stride; ++idx < stride;){
            set(child, offset + idx, value.get(idx));
        }
    }
};
SetVisitor.prototype.visitBool = wrapSet(setBool);
SetVisitor.prototype.visitInt = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt8 = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt16 = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt32 = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt64 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint8 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint16 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint32 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint64 = wrapSet(exports.setInt);
SetVisitor.prototype.visitFloat = wrapSet(exports.setAnyFloat);
SetVisitor.prototype.visitFloat16 = wrapSet(exports.setFloat16);
SetVisitor.prototype.visitFloat32 = wrapSet(exports.setFloat);
SetVisitor.prototype.visitFloat64 = wrapSet(exports.setFloat);
SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
SetVisitor.prototype.visitLargeUtf8 = wrapSet(setUtf8);
SetVisitor.prototype.visitBinary = wrapSet(setBinary);
SetVisitor.prototype.visitLargeBinary = wrapSet(setBinary);
SetVisitor.prototype.visitFixedSizeBinary = wrapSet(exports.setFixedSizeBinary);
SetVisitor.prototype.visitDate = wrapSet(exports.setDate);
SetVisitor.prototype.visitDateDay = wrapSet(exports.setDateDay);
SetVisitor.prototype.visitDateMillisecond = wrapSet(exports.setDateMillisecond);
SetVisitor.prototype.visitTimestamp = wrapSet(exports.setTimestamp);
SetVisitor.prototype.visitTimestampSecond = wrapSet(exports.setTimestampSecond);
SetVisitor.prototype.visitTimestampMillisecond = wrapSet(exports.setTimestampMillisecond);
SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(exports.setTimestampMicrosecond);
SetVisitor.prototype.visitTimestampNanosecond = wrapSet(exports.setTimestampNanosecond);
SetVisitor.prototype.visitTime = wrapSet(exports.setTime);
SetVisitor.prototype.visitTimeSecond = wrapSet(exports.setTimeSecond);
SetVisitor.prototype.visitTimeMillisecond = wrapSet(exports.setTimeMillisecond);
SetVisitor.prototype.visitTimeMicrosecond = wrapSet(exports.setTimeMicrosecond);
SetVisitor.prototype.visitTimeNanosecond = wrapSet(exports.setTimeNanosecond);
SetVisitor.prototype.visitDecimal = wrapSet(exports.setDecimal);
SetVisitor.prototype.visitList = wrapSet(setList);
SetVisitor.prototype.visitStruct = wrapSet(setStruct);
SetVisitor.prototype.visitUnion = wrapSet(setUnion);
SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
SetVisitor.prototype.visitInterval = wrapSet(exports.setIntervalValue);
SetVisitor.prototype.visitIntervalDayTime = wrapSet(exports.setIntervalDayTime);
SetVisitor.prototype.visitIntervalYearMonth = wrapSet(exports.setIntervalYearMonth);
SetVisitor.prototype.visitDuration = wrapSet(exports.setDuration);
SetVisitor.prototype.visitDurationSecond = wrapSet(exports.setDurationSecond);
SetVisitor.prototype.visitDurationMillisecond = wrapSet(exports.setDurationMillisecond);
SetVisitor.prototype.visitDurationMicrosecond = wrapSet(exports.setDurationMicrosecond);
SetVisitor.prototype.visitDurationNanosecond = wrapSet(exports.setDurationNanosecond);
SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
SetVisitor.prototype.visitMap = wrapSet(setMap);
/** @ignore */ exports.instance = new SetVisitor(); //# sourceMappingURL=set.js.map
}),
"[project]/node_modules/apache-arrow/row/struct.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StructRow = void 0;
const pretty_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/pretty.js [app-ssr] (ecmascript)");
const get_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/get.js [app-ssr] (ecmascript)");
const set_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)");
/** @ignore */ const kParent = Symbol.for('parent');
/** @ignore */ const kRowIndex = Symbol.for('rowIndex');
class StructRow {
    constructor(parent, rowIndex){
        this[kParent] = parent;
        this[kRowIndex] = rowIndex;
        return new Proxy(this, new StructRowProxyHandler());
    }
    toArray() {
        return Object.values(this.toJSON());
    }
    toJSON() {
        const i = this[kRowIndex];
        const parent = this[kParent];
        const keys = parent.type.children;
        const json = {};
        for(let j = -1, n = keys.length; ++j < n;){
            json[keys[j].name] = get_js_1.instance.visit(parent.children[j], i);
        }
        return json;
    }
    toString() {
        return `{${[
            ...this
        ].map(([key, val])=>`${(0, pretty_js_1.valueToString)(key)}: ${(0, pretty_js_1.valueToString)(val)}`).join(', ')}}`;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return this.toString();
    }
    [Symbol.iterator]() {
        return new StructRowIterator(this[kParent], this[kRowIndex]);
    }
}
exports.StructRow = StructRow;
class StructRowIterator {
    constructor(data, rowIndex){
        this.childIndex = 0;
        this.children = data.children;
        this.rowIndex = rowIndex;
        this.childFields = data.type.children;
        this.numChildren = this.childFields.length;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        const i = this.childIndex;
        if (i < this.numChildren) {
            this.childIndex = i + 1;
            return {
                done: false,
                value: [
                    this.childFields[i].name,
                    get_js_1.instance.visit(this.children[i], this.rowIndex)
                ]
            };
        }
        return {
            done: true,
            value: null
        };
    }
}
Object.defineProperties(StructRow.prototype, {
    [Symbol.toStringTag]: {
        enumerable: false,
        configurable: false,
        value: 'Row'
    },
    [kParent]: {
        writable: true,
        enumerable: false,
        configurable: false,
        value: null
    },
    [kRowIndex]: {
        writable: true,
        enumerable: false,
        configurable: false,
        value: -1
    }
});
class StructRowProxyHandler {
    isExtensible() {
        return false;
    }
    deleteProperty() {
        return false;
    }
    preventExtensions() {
        return true;
    }
    ownKeys(row) {
        return row[kParent].type.children.map((f)=>f.name);
    }
    has(row, key) {
        return row[kParent].type.children.findIndex((f)=>f.name === key) !== -1;
    }
    getOwnPropertyDescriptor(row, key) {
        if (row[kParent].type.children.findIndex((f)=>f.name === key) !== -1) {
            return {
                writable: true,
                enumerable: true,
                configurable: true
            };
        }
        return;
    }
    get(row, key) {
        // Look up key in row first
        if (Reflect.has(row, key)) {
            return row[key];
        }
        const idx = row[kParent].type.children.findIndex((f)=>f.name === key);
        if (idx !== -1) {
            const val = get_js_1.instance.visit(row[kParent].children[idx], row[kRowIndex]);
            // Cache key/val lookups
            Reflect.set(row, key, val);
            return val;
        }
    }
    set(row, key, val) {
        const idx = row[kParent].type.children.findIndex((f)=>f.name === key);
        if (idx !== -1) {
            set_js_1.instance.visit(row[kParent].children[idx], row[kRowIndex], val);
            // Cache key/val lookups
            return Reflect.set(row, key, val);
        } else if (Reflect.has(row, key) || typeof key === 'symbol') {
            return Reflect.set(row, key, val);
        }
        return false;
    }
} //# sourceMappingURL=struct.js.map
}),
"[project]/node_modules/apache-arrow/visitor/get.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.instance = exports.GetVisitor = void 0;
const bn_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bn.js [app-ssr] (ecmascript)");
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
const map_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/row/map.js [app-ssr] (ecmascript)");
const struct_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/row/struct.js [app-ssr] (ecmascript)");
const bigint_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bigint.js [app-ssr] (ecmascript)");
const utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/utf8.js [app-ssr] (ecmascript)");
const math_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/math.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
/** @ignore */ class GetVisitor extends visitor_js_1.Visitor {
}
exports.GetVisitor = GetVisitor;
/** @ignore */ function wrapGet(fn) {
    return (data, _1)=>data.getValid(_1) ? fn(data, _1) : null;
}
/** @ignore */ const epochDaysToMs = (data, index)=>86400000 * data[index];
/** @ignore */ const getNull = (_data, _index)=>null;
/** @ignore */ const getVariableWidthBytes = (values, valueOffsets, index)=>{
    if (index + 1 >= valueOffsets.length) {
        return null;
    }
    const x = (0, bigint_js_1.bigIntToNumber)(valueOffsets[index]);
    const y = (0, bigint_js_1.bigIntToNumber)(valueOffsets[index + 1]);
    return values.subarray(x, y);
};
/** @ignore */ const getBool = ({ offset, values }, index)=>{
    const idx = offset + index;
    const byte = values[idx >> 3];
    return (byte & 1 << idx % 8) !== 0;
};
/** @ignore */ const getDateDay = ({ values }, index)=>epochDaysToMs(values, index);
/** @ignore */ const getDateMillisecond = ({ values }, index)=>(0, bigint_js_1.bigIntToNumber)(values[index]);
/** @ignore */ const getNumeric = ({ stride, values }, index)=>values[stride * index];
/** @ignore */ const getFloat16 = ({ stride, values }, index)=>(0, math_js_1.uint16ToFloat64)(values[stride * index]);
/** @ignore */ const getBigInts = ({ values }, index)=>values[index];
/** @ignore */ const getFixedSizeBinary = ({ stride, values }, index)=>values.subarray(stride * index, stride * (index + 1));
/** @ignore */ const getBinary = ({ values, valueOffsets }, index)=>getVariableWidthBytes(values, valueOffsets, index);
/** @ignore */ const getUtf8 = ({ values, valueOffsets }, index)=>{
    const bytes = getVariableWidthBytes(values, valueOffsets, index);
    return bytes !== null ? (0, utf8_js_1.decodeUtf8)(bytes) : null;
};
/* istanbul ignore next */ /** @ignore */ const getInt = ({ values }, index)=>values[index];
/* istanbul ignore next */ /** @ignore */ const getFloat = ({ type, values }, index)=>type.precision !== enum_js_1.Precision.HALF ? values[index] : (0, math_js_1.uint16ToFloat64)(values[index]);
/* istanbul ignore next */ /** @ignore */ const getDate = (data, index)=>data.type.unit === enum_js_1.DateUnit.DAY ? getDateDay(data, index) : getDateMillisecond(data, index);
/** @ignore */ const getTimestampSecond = ({ values }, index)=>1000 * (0, bigint_js_1.bigIntToNumber)(values[index]);
/** @ignore */ const getTimestampMillisecond = ({ values }, index)=>(0, bigint_js_1.bigIntToNumber)(values[index]);
/** @ignore */ const getTimestampMicrosecond = ({ values }, index)=>(0, bigint_js_1.divideBigInts)(values[index], BigInt(1000));
/** @ignore */ const getTimestampNanosecond = ({ values }, index)=>(0, bigint_js_1.divideBigInts)(values[index], BigInt(1000000));
/* istanbul ignore next */ /** @ignore */ const getTimestamp = (data, index)=>{
    switch(data.type.unit){
        case enum_js_1.TimeUnit.SECOND:
            return getTimestampSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND:
            return getTimestampMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND:
            return getTimestampMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND:
            return getTimestampNanosecond(data, index);
    }
};
/** @ignore */ const getTimeSecond = ({ values }, index)=>values[index];
/** @ignore */ const getTimeMillisecond = ({ values }, index)=>values[index];
/** @ignore */ const getTimeMicrosecond = ({ values }, index)=>values[index];
/** @ignore */ const getTimeNanosecond = ({ values }, index)=>values[index];
/* istanbul ignore next */ /** @ignore */ const getTime = (data, index)=>{
    switch(data.type.unit){
        case enum_js_1.TimeUnit.SECOND:
            return getTimeSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND:
            return getTimeMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND:
            return getTimeMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND:
            return getTimeNanosecond(data, index);
    }
};
/** @ignore */ const getDecimal = ({ values, stride }, index)=>bn_js_1.BN.decimal(values.subarray(stride * index, stride * (index + 1)));
/** @ignore */ const getList = (data, index)=>{
    const { valueOffsets, stride, children } = data;
    const { [index * stride]: begin, [index * stride + 1]: end } = valueOffsets;
    const child = children[0];
    const slice = child.slice(begin, end - begin);
    return new vector_js_1.Vector([
        slice
    ]);
};
/** @ignore */ const getMap = (data, index)=>{
    const { valueOffsets, children } = data;
    const { [index]: begin, [index + 1]: end } = valueOffsets;
    const child = children[0];
    return new map_js_1.MapRow(child.slice(begin, end - begin));
};
/** @ignore */ const getStruct = (data, index)=>{
    return new struct_js_1.StructRow(data, index);
};
/* istanbul ignore next */ /** @ignore */ const getUnion = (data, index)=>{
    return data.type.mode === enum_js_1.UnionMode.Dense ? getDenseUnion(data, index) : getSparseUnion(data, index);
};
/** @ignore */ const getDenseUnion = (data, index)=>{
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return exports.instance.visit(child, data.valueOffsets[index]);
};
/** @ignore */ const getSparseUnion = (data, index)=>{
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return exports.instance.visit(child, index);
};
/** @ignore */ const getDictionary = (data, index)=>{
    var _a;
    return (_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.get(data.values[index]);
};
/* istanbul ignore next */ /** @ignore */ const getInterval = (data, index)=>data.type.unit === enum_js_1.IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index) : getIntervalYearMonth(data, index);
/** @ignore */ const getIntervalDayTime = ({ values }, index)=>values.subarray(2 * index, 2 * (index + 1));
/** @ignore */ const getIntervalYearMonth = ({ values }, index)=>{
    const interval = values[index];
    const int32s = new Int32Array(2);
    int32s[0] = Math.trunc(interval / 12); /* years */ 
    int32s[1] = Math.trunc(interval % 12); /* months */ 
    return int32s;
};
/** @ignore */ const getDurationSecond = ({ values }, index)=>values[index];
/** @ignore */ const getDurationMillisecond = ({ values }, index)=>values[index];
/** @ignore */ const getDurationMicrosecond = ({ values }, index)=>values[index];
/** @ignore */ const getDurationNanosecond = ({ values }, index)=>values[index];
/* istanbul ignore next */ /** @ignore */ const getDuration = (data, index)=>{
    switch(data.type.unit){
        case enum_js_1.TimeUnit.SECOND:
            return getDurationSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND:
            return getDurationMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND:
            return getDurationMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND:
            return getDurationNanosecond(data, index);
    }
};
/** @ignore */ const getFixedSizeList = (data, index)=>{
    const { stride, children } = data;
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    return new vector_js_1.Vector([
        slice
    ]);
};
GetVisitor.prototype.visitNull = wrapGet(getNull);
GetVisitor.prototype.visitBool = wrapGet(getBool);
GetVisitor.prototype.visitInt = wrapGet(getInt);
GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
GetVisitor.prototype.visitFloat = wrapGet(getFloat);
GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
GetVisitor.prototype.visitLargeUtf8 = wrapGet(getUtf8);
GetVisitor.prototype.visitBinary = wrapGet(getBinary);
GetVisitor.prototype.visitLargeBinary = wrapGet(getBinary);
GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
GetVisitor.prototype.visitDate = wrapGet(getDate);
GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
GetVisitor.prototype.visitTime = wrapGet(getTime);
GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
GetVisitor.prototype.visitList = wrapGet(getList);
GetVisitor.prototype.visitStruct = wrapGet(getStruct);
GetVisitor.prototype.visitUnion = wrapGet(getUnion);
GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
GetVisitor.prototype.visitInterval = wrapGet(getInterval);
GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
GetVisitor.prototype.visitDuration = wrapGet(getDuration);
GetVisitor.prototype.visitDurationSecond = wrapGet(getDurationSecond);
GetVisitor.prototype.visitDurationMillisecond = wrapGet(getDurationMillisecond);
GetVisitor.prototype.visitDurationMicrosecond = wrapGet(getDurationMicrosecond);
GetVisitor.prototype.visitDurationNanosecond = wrapGet(getDurationNanosecond);
GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
GetVisitor.prototype.visitMap = wrapGet(getMap);
/** @ignore */ exports.instance = new GetVisitor(); //# sourceMappingURL=get.js.map
}),
"[project]/node_modules/apache-arrow/row/map.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MapRow = exports._kKeysAsStrings = exports.kKeysAsStrings = exports.kVals = exports.kKeys = void 0;
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const pretty_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/pretty.js [app-ssr] (ecmascript)");
const get_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/get.js [app-ssr] (ecmascript)");
const set_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)");
/** @ignore */ exports.kKeys = Symbol.for('keys');
/** @ignore */ exports.kVals = Symbol.for('vals');
/** @ignore */ exports.kKeysAsStrings = Symbol.for('kKeysAsStrings');
/** @ignore */ exports._kKeysAsStrings = Symbol.for('_kKeysAsStrings');
class MapRow {
    constructor(slice){
        this[exports.kKeys] = new vector_js_1.Vector([
            slice.children[0]
        ]).memoize();
        this[exports.kVals] = slice.children[1];
        return new Proxy(this, new MapRowProxyHandler());
    }
    /** @ignore */ get [exports.kKeysAsStrings]() {
        return this[exports._kKeysAsStrings] || (this[exports._kKeysAsStrings] = Array.from(this[exports.kKeys].toArray(), String));
    }
    [Symbol.iterator]() {
        return new MapRowIterator(this[exports.kKeys], this[exports.kVals]);
    }
    get size() {
        return this[exports.kKeys].length;
    }
    toArray() {
        return Object.values(this.toJSON());
    }
    toJSON() {
        const keys = this[exports.kKeys];
        const vals = this[exports.kVals];
        const json = {};
        for(let i = -1, n = keys.length; ++i < n;){
            json[keys.get(i)] = get_js_1.instance.visit(vals, i);
        }
        return json;
    }
    toString() {
        return `{${[
            ...this
        ].map(([key, val])=>`${(0, pretty_js_1.valueToString)(key)}: ${(0, pretty_js_1.valueToString)(val)}`).join(', ')}}`;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return this.toString();
    }
}
exports.MapRow = MapRow;
class MapRowIterator {
    constructor(keys, vals){
        this.keys = keys;
        this.vals = vals;
        this.keyIndex = 0;
        this.numKeys = keys.length;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        const i = this.keyIndex;
        if (i === this.numKeys) {
            return {
                done: true,
                value: null
            };
        }
        this.keyIndex++;
        return {
            done: false,
            value: [
                this.keys.get(i),
                get_js_1.instance.visit(this.vals, i)
            ]
        };
    }
}
/** @ignore */ class MapRowProxyHandler {
    isExtensible() {
        return false;
    }
    deleteProperty() {
        return false;
    }
    preventExtensions() {
        return true;
    }
    ownKeys(row) {
        return row[exports.kKeysAsStrings];
    }
    has(row, key) {
        return row[exports.kKeysAsStrings].includes(key);
    }
    getOwnPropertyDescriptor(row, key) {
        const idx = row[exports.kKeysAsStrings].indexOf(key);
        if (idx !== -1) {
            return {
                writable: true,
                enumerable: true,
                configurable: true
            };
        }
        return;
    }
    get(row, key) {
        // Look up key in row first
        if (Reflect.has(row, key)) {
            return row[key];
        }
        const idx = row[exports.kKeysAsStrings].indexOf(key);
        if (idx !== -1) {
            const val = get_js_1.instance.visit(Reflect.get(row, exports.kVals), idx);
            // Cache key/val lookups
            Reflect.set(row, key, val);
            return val;
        }
    }
    set(row, key, val) {
        const idx = row[exports.kKeysAsStrings].indexOf(key);
        if (idx !== -1) {
            set_js_1.instance.visit(Reflect.get(row, exports.kVals), idx, val);
            // Cache key/val lookups
            return Reflect.set(row, key, val);
        } else if (Reflect.has(row, key)) {
            return Reflect.set(row, key, val);
        }
        return false;
    }
}
Object.defineProperties(MapRow.prototype, {
    [Symbol.toStringTag]: {
        enumerable: false,
        configurable: false,
        value: 'Row'
    },
    [exports.kKeys]: {
        writable: true,
        enumerable: false,
        configurable: false,
        value: null
    },
    [exports.kVals]: {
        writable: true,
        enumerable: false,
        configurable: false,
        value: null
    },
    [exports._kKeysAsStrings]: {
        writable: true,
        enumerable: false,
        configurable: false,
        value: null
    }
}); //# sourceMappingURL=map.js.map
}),
"[project]/node_modules/apache-arrow/util/vector.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createElementComparator = exports.wrapIndex = exports.clampRange = void 0;
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const map_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/row/map.js [app-ssr] (ecmascript)");
const struct_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/row/struct.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
/** @ignore */ let tmp;
/** @ignore */ function clampRange(source, begin, end, then) {
    // Adjust args similar to Array.prototype.slice. Normalize begin/end to
    // clamp between 0 and length, and wrap around on negative indices, e.g.
    // slice(-1, 5) or slice(5, -1)
    const { length: len = 0 } = source;
    let lhs = typeof begin !== 'number' ? 0 : begin;
    let rhs = typeof end !== 'number' ? len : end;
    // wrap around on negative start/end positions
    lhs < 0 && (lhs = (lhs % len + len) % len);
    rhs < 0 && (rhs = (rhs % len + len) % len);
    // ensure lhs <= rhs
    rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);
    // ensure rhs <= length
    rhs > len && (rhs = len);
    return then ? then(source, lhs, rhs) : [
        lhs,
        rhs
    ];
}
exports.clampRange = clampRange;
/** @ignore */ const wrapIndex = (index, len)=>index < 0 ? len + index : index;
exports.wrapIndex = wrapIndex;
const isNaNFast = (value)=>value !== value;
/** @ignore */ function createElementComparator(search) {
    const typeofSearch = typeof search;
    // Compare primitives
    if (typeofSearch !== 'object' || search === null) {
        // Compare NaN
        if (isNaNFast(search)) {
            return isNaNFast;
        }
        return (value)=>value === search;
    }
    // Compare Dates
    if (search instanceof Date) {
        const valueOfSearch = search.valueOf();
        return (value)=>value instanceof Date ? value.valueOf() === valueOfSearch : false;
    }
    // Compare TypedArrays
    if (ArrayBuffer.isView(search)) {
        return (value)=>value ? (0, buffer_js_1.compareArrayLike)(search, value) : false;
    }
    // Compare Maps and Rows
    if (search instanceof Map) {
        return createMapComparator(search);
    }
    // Compare Array-likes
    if (Array.isArray(search)) {
        return createArrayLikeComparator(search);
    }
    // Compare Vectors
    if (search instanceof vector_js_1.Vector) {
        return createVectorComparator(search);
    }
    return createObjectComparator(search, true);
// Compare non-empty Objects
// return createObjectComparator(search, search instanceof Proxy);
}
exports.createElementComparator = createElementComparator;
/** @ignore */ function createArrayLikeComparator(lhs) {
    const comparators = [];
    for(let i = -1, n = lhs.length; ++i < n;){
        comparators[i] = createElementComparator(lhs[i]);
    }
    return createSubElementsComparator(comparators);
}
/** @ignore */ function createMapComparator(lhs) {
    let i = -1;
    const comparators = [];
    for (const v of lhs.values())comparators[++i] = createElementComparator(v);
    return createSubElementsComparator(comparators);
}
/** @ignore */ function createVectorComparator(lhs) {
    const comparators = [];
    for(let i = -1, n = lhs.length; ++i < n;){
        comparators[i] = createElementComparator(lhs.get(i));
    }
    return createSubElementsComparator(comparators);
}
/** @ignore */ function createObjectComparator(lhs, allowEmpty = false) {
    const keys = Object.keys(lhs);
    // Only compare non-empty Objects
    if (!allowEmpty && keys.length === 0) {
        return ()=>false;
    }
    const comparators = [];
    for(let i = -1, n = keys.length; ++i < n;){
        comparators[i] = createElementComparator(lhs[keys[i]]);
    }
    return createSubElementsComparator(comparators, keys);
}
function createSubElementsComparator(comparators, keys) {
    return (rhs)=>{
        if (!rhs || typeof rhs !== 'object') {
            return false;
        }
        switch(rhs.constructor){
            case Array:
                return compareArray(comparators, rhs);
            case Map:
                return compareObject(comparators, rhs, rhs.keys());
            case map_js_1.MapRow:
            case struct_js_1.StructRow:
            case Object:
            case undefined:
                return compareObject(comparators, rhs, keys || Object.keys(rhs));
        }
        return rhs instanceof vector_js_1.Vector ? compareVector(comparators, rhs) : false;
    };
}
function compareArray(comparators, arr) {
    const n = comparators.length;
    if (arr.length !== n) {
        return false;
    }
    for(let i = -1; ++i < n;){
        if (!comparators[i](arr[i])) {
            return false;
        }
    }
    return true;
}
function compareVector(comparators, vec) {
    const n = comparators.length;
    if (vec.length !== n) {
        return false;
    }
    for(let i = -1; ++i < n;){
        if (!comparators[i](vec.get(i))) {
            return false;
        }
    }
    return true;
}
function compareObject(comparators, obj, keys) {
    const lKeyItr = keys[Symbol.iterator]();
    const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
    const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
    let i = 0;
    const n = comparators.length;
    let rVal = rValItr.next();
    let lKey = lKeyItr.next();
    let rKey = rKeyItr.next();
    for(; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()){
        if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {
            break;
        }
    }
    if (i === n && lKey.done && rKey.done && rVal.done) {
        return true;
    }
    lKeyItr.return && lKeyItr.return();
    rKeyItr.return && rKeyItr.return();
    rValItr.return && rValItr.return();
    return false;
} //# sourceMappingURL=vector.js.map
}),
"[project]/node_modules/apache-arrow/util/bit.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.popcnt_uint32 = exports.popcnt_array = exports.popcnt_bit_range = exports.BitIterator = exports.packBools = exports.truncateBitmap = exports.setBool = exports.getBit = exports.getBool = void 0;
/** @ignore */ function getBool(_data, _index, byte, bit) {
    return (byte & 1 << bit) !== 0;
}
exports.getBool = getBool;
/** @ignore */ function getBit(_data, _index, byte, bit) {
    return (byte & 1 << bit) >> bit;
}
exports.getBit = getBit;
/** @ignore */ function setBool(bytes, index, value) {
    return value ? !!(bytes[index >> 3] |= 1 << index % 8) || true : !(bytes[index >> 3] &= ~(1 << index % 8)) && false;
}
exports.setBool = setBool;
/** @ignore */ function truncateBitmap(offset, length, bitmap) {
    const alignedSize = bitmap.byteLength + 7 & ~7;
    if (offset > 0 || bitmap.byteLength < alignedSize) {
        const bytes = new Uint8Array(alignedSize);
        // If the offset is a multiple of 8 bits, it's safe to slice the bitmap
        bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) : // Otherwise iterate each bit from the offset and return a new one
        packBools(new BitIterator(bitmap, offset, length, null, getBool)).subarray(0, alignedSize));
        return bytes;
    }
    return bitmap;
}
exports.truncateBitmap = truncateBitmap;
/** @ignore */ function packBools(values) {
    const xs = [];
    let i = 0, bit = 0, byte = 0;
    for (const value of values){
        value && (byte |= 1 << bit);
        if (++bit === 8) {
            xs[i++] = byte;
            byte = bit = 0;
        }
    }
    if (i === 0 || bit > 0) {
        xs[i++] = byte;
    }
    const b = new Uint8Array(xs.length + 7 & ~7);
    b.set(xs);
    return b;
}
exports.packBools = packBools;
/** @ignore */ class BitIterator {
    constructor(bytes, begin, length, context, get){
        this.bytes = bytes;
        this.length = length;
        this.context = context;
        this.get = get;
        this.bit = begin % 8;
        this.byteIndex = begin >> 3;
        this.byte = bytes[this.byteIndex++];
        this.index = 0;
    }
    next() {
        if (this.index < this.length) {
            if (this.bit === 8) {
                this.bit = 0;
                this.byte = this.bytes[this.byteIndex++];
            }
            return {
                value: this.get(this.context, this.index++, this.byte, this.bit++)
            };
        }
        return {
            done: true,
            value: null
        };
    }
    [Symbol.iterator]() {
        return this;
    }
}
exports.BitIterator = BitIterator;
/**
 * Compute the population count (the number of bits set to 1) for a range of bits in a Uint8Array.
 * @param vector The Uint8Array of bits for which to compute the population count.
 * @param lhs The range's left-hand side (or start) bit
 * @param rhs The range's right-hand side (or end) bit
 */ /** @ignore */ function popcnt_bit_range(data, lhs, rhs) {
    if (rhs - lhs <= 0) {
        return 0;
    }
    // If the bit range is less than one byte, sum the 1 bits in the bit range
    if (rhs - lhs < 8) {
        let sum = 0;
        for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)){
            sum += bit;
        }
        return sum;
    }
    // Get the next lowest multiple of 8 from the right hand side
    const rhsInside = rhs >> 3 << 3;
    // Get the next highest multiple of 8 from the left hand side
    const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
    return(// Get the popcnt of bits between the left hand side, and the next highest multiple of 8
    popcnt_bit_range(data, lhs, lhsInside) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
    popcnt_bit_range(data, rhsInside, rhs) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
    popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3));
}
exports.popcnt_bit_range = popcnt_bit_range;
/** @ignore */ function popcnt_array(arr, byteOffset, byteLength) {
    let cnt = 0, pos = Math.trunc(byteOffset);
    const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
    while(len - pos >= 4){
        cnt += popcnt_uint32(view.getUint32(pos));
        pos += 4;
    }
    while(len - pos >= 2){
        cnt += popcnt_uint32(view.getUint16(pos));
        pos += 2;
    }
    while(len - pos >= 1){
        cnt += popcnt_uint32(view.getUint8(pos));
        pos += 1;
    }
    return cnt;
}
exports.popcnt_array = popcnt_array;
/** @ignore */ function popcnt_uint32(uint32) {
    let i = Math.trunc(uint32);
    i = i - (i >>> 1 & 0x55555555);
    i = (i & 0x33333333) + (i >>> 2 & 0x33333333);
    return (i + (i >>> 4) & 0x0F0F0F0F) * 0x01010101 >>> 24;
}
exports.popcnt_uint32 = popcnt_uint32; //# sourceMappingURL=bit.js.map
}),
"[project]/node_modules/apache-arrow/data.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeData = exports.Data = exports.kUnknownNullCount = void 0;
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const bit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bit.js [app-ssr] (ecmascript)");
/** @ignore */ exports.kUnknownNullCount = -1;
/**
 * Data structure underlying {@link Vector}s. Use the convenience method {@link makeData}.
 */ class Data {
    get typeId() {
        return this.type.typeId;
    }
    get ArrayType() {
        return this.type.ArrayType;
    }
    get buffers() {
        return [
            this.valueOffsets,
            this.values,
            this.nullBitmap,
            this.typeIds
        ];
    }
    get nullable() {
        if (this._nullCount !== 0) {
            const { type } = this;
            if (type_js_1.DataType.isSparseUnion(type)) {
                return this.children.some((child)=>child.nullable);
            } else if (type_js_1.DataType.isDenseUnion(type)) {
                return this.children.some((child)=>child.nullable);
            }
            return this.nullBitmap && this.nullBitmap.byteLength > 0;
        }
        return true;
    }
    get byteLength() {
        let byteLength = 0;
        const { valueOffsets, values, nullBitmap, typeIds } = this;
        valueOffsets && (byteLength += valueOffsets.byteLength);
        values && (byteLength += values.byteLength);
        nullBitmap && (byteLength += nullBitmap.byteLength);
        typeIds && (byteLength += typeIds.byteLength);
        return this.children.reduce((byteLength, child)=>byteLength + child.byteLength, byteLength);
    }
    get nullCount() {
        if (type_js_1.DataType.isUnion(this.type)) {
            return this.children.reduce((nullCount, child)=>nullCount + child.nullCount, 0);
        }
        let nullCount = this._nullCount;
        let nullBitmap;
        if (nullCount <= exports.kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
            this._nullCount = nullCount = nullBitmap.length === 0 ? // no null bitmap, so all values are valid
            0 : this.length - (0, bit_js_1.popcnt_bit_range)(nullBitmap, this.offset, this.offset + this.length);
        }
        return nullCount;
    }
    constructor(type, offset, length, nullCount, buffers, children = [], dictionary){
        this.type = type;
        this.children = children;
        this.dictionary = dictionary;
        this.offset = Math.floor(Math.max(offset || 0, 0));
        this.length = Math.floor(Math.max(length || 0, 0));
        this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
        let buffer;
        if (buffers instanceof Data) {
            this.stride = buffers.stride;
            this.values = buffers.values;
            this.typeIds = buffers.typeIds;
            this.nullBitmap = buffers.nullBitmap;
            this.valueOffsets = buffers.valueOffsets;
        } else {
            this.stride = (0, type_js_1.strideForType)(type);
            if (buffers) {
                (buffer = buffers[0]) && (this.valueOffsets = buffer);
                (buffer = buffers[1]) && (this.values = buffer);
                (buffer = buffers[2]) && (this.nullBitmap = buffer);
                (buffer = buffers[3]) && (this.typeIds = buffer);
            }
        }
    }
    getValid(index) {
        const { type } = this;
        if (type_js_1.DataType.isUnion(type)) {
            const union = type;
            const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];
            const indexInChild = union.mode === enum_js_1.UnionMode.Dense ? this.valueOffsets[index] : index;
            return child.getValid(indexInChild);
        }
        if (this.nullable && this.nullCount > 0) {
            const pos = this.offset + index;
            const val = this.nullBitmap[pos >> 3];
            return (val & 1 << pos % 8) !== 0;
        }
        return true;
    }
    setValid(index, value) {
        let prev;
        const { type } = this;
        if (type_js_1.DataType.isUnion(type)) {
            const union = type;
            const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];
            const indexInChild = union.mode === enum_js_1.UnionMode.Dense ? this.valueOffsets[index] : index;
            prev = child.getValid(indexInChild);
            child.setValid(indexInChild, value);
        } else {
            let { nullBitmap } = this;
            const { offset, length } = this;
            const idx = offset + index;
            const mask = 1 << idx % 8;
            const byteOffset = idx >> 3;
            // If no null bitmap, initialize one on the fly
            if (!nullBitmap || nullBitmap.byteLength <= byteOffset) {
                nullBitmap = new Uint8Array((offset + length + 63 & ~63) >> 3).fill(255);
                // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s
                if (this.nullCount > 0) {
                    nullBitmap.set((0, bit_js_1.truncateBitmap)(offset, length, this.nullBitmap), 0);
                    Object.assign(this, {
                        nullBitmap
                    });
                } else {
                    Object.assign(this, {
                        nullBitmap,
                        _nullCount: 0
                    });
                }
            }
            const byte = nullBitmap[byteOffset];
            prev = (byte & mask) !== 0;
            nullBitmap[byteOffset] = value ? byte | mask : byte & ~mask;
        }
        if (prev !== !!value) {
            // Update `_nullCount` if the new value is different from the old value.
            this._nullCount = this.nullCount + (value ? -1 : 1);
        }
        return value;
    }
    clone(type = this.type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, children = this.children) {
        return new Data(type, offset, length, nullCount, buffers, children, this.dictionary);
    }
    slice(offset, length) {
        const { stride, typeId, children } = this;
        // +true === 1, +false === 0, so this means
        // we keep nullCount at 0 if it's already 0,
        // otherwise set to the invalidated flag -1
        const nullCount = +(this._nullCount === 0) - 1;
        const childStride = typeId === 16 /* FixedSizeList */  ? stride : 1;
        const buffers = this._sliceBuffers(offset, length, stride, typeId);
        return this.clone(this.type, this.offset + offset, length, nullCount, buffers, // Don't slice children if we have value offsets (the variable-width types)
        children.length === 0 || this.valueOffsets ? children : this._sliceChildren(children, childStride * offset, childStride * length));
    }
    _changeLengthAndBackfillNullBitmap(newLength) {
        if (this.typeId === enum_js_1.Type.Null) {
            return this.clone(this.type, 0, newLength, 0);
        }
        const { length, nullCount } = this;
        // start initialized with 0s (nulls), then fill from 0 to length with 1s (not null)
        const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length >> 3);
        // set all the bits in the last byte (up to bit `length - length % 8`) to 1 (not null)
        bitmap[length >> 3] = (1 << length - (length & ~7)) - 1;
        // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s
        if (nullCount > 0) {
            bitmap.set((0, bit_js_1.truncateBitmap)(this.offset, length, this.nullBitmap), 0);
        }
        const buffers = this.buffers;
        buffers[enum_js_1.BufferType.VALIDITY] = bitmap;
        return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);
    }
    _sliceBuffers(offset, length, stride, typeId) {
        let arr;
        const { buffers } = this;
        // If typeIds exist, slice the typeIds buffer
        (arr = buffers[enum_js_1.BufferType.TYPE]) && (buffers[enum_js_1.BufferType.TYPE] = arr.subarray(offset, offset + length));
        // If offsets exist, only slice the offsets buffer
        (arr = buffers[enum_js_1.BufferType.OFFSET]) && (buffers[enum_js_1.BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
        (arr = buffers[enum_js_1.BufferType.DATA]) && (buffers[enum_js_1.BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));
        return buffers;
    }
    _sliceChildren(children, offset, length) {
        return children.map((child)=>child.slice(offset, length));
    }
}
exports.Data = Data;
Data.prototype.children = Object.freeze([]);
const visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
class MakeDataVisitor extends visitor_js_1.Visitor {
    visit(props) {
        return this.getVisitFn(props['type']).call(this, props);
    }
    visitNull(props) {
        const { ['type']: type, ['offset']: offset = 0, ['length']: length = 0 } = props;
        return new Data(type, offset, length, length);
    }
    visitBool(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length >> 3, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            data,
            nullBitmap
        ]);
    }
    visitInt(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            data,
            nullBitmap
        ]);
    }
    visitFloat(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            data,
            nullBitmap
        ]);
    }
    visitUtf8(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props['data']);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            valueOffsets,
            data,
            nullBitmap
        ]);
    }
    visitLargeUtf8(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props['data']);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toBigInt64Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            valueOffsets,
            data,
            nullBitmap
        ]);
    }
    visitBinary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props['data']);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            valueOffsets,
            data,
            nullBitmap
        ]);
    }
    visitLargeBinary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props['data']);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toBigInt64Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            valueOffsets,
            data,
            nullBitmap
        ]);
    }
    visitFixedSizeBinary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            data,
            nullBitmap
        ]);
    }
    visitDate(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            data,
            nullBitmap
        ]);
    }
    visitTimestamp(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            data,
            nullBitmap
        ]);
    }
    visitTime(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            data,
            nullBitmap
        ]);
    }
    visitDecimal(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            data,
            nullBitmap
        ]);
    }
    visitList(props) {
        const { ['type']: type, ['offset']: offset = 0, ['child']: child } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            valueOffsets,
            undefined,
            nullBitmap
        ], [
            child
        ]);
    }
    visitStruct(props) {
        const { ['type']: type, ['offset']: offset = 0, ['children']: children = [] } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const { length = children.reduce((len, { length })=>Math.max(len, length), 0), nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            undefined,
            nullBitmap
        ], children);
    }
    visitUnion(props) {
        const { ['type']: type, ['offset']: offset = 0, ['children']: children = [] } = props;
        const typeIds = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['typeIds']);
        const { ['length']: length = typeIds.length, ['nullCount']: nullCount = -1 } = props;
        if (type_js_1.DataType.isSparseUnion(type)) {
            return new Data(type, offset, length, nullCount, [
                undefined,
                undefined,
                undefined,
                typeIds
            ], children);
        }
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        return new Data(type, offset, length, nullCount, [
            valueOffsets,
            undefined,
            undefined,
            typeIds
        ], children);
    }
    visitDictionary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.indices.ArrayType, props['data']);
        const { ['dictionary']: dictionary = new vector_js_1.Vector([
            new MakeDataVisitor().visit({
                type: type.dictionary
            })
        ]) } = props;
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            data,
            nullBitmap
        ], [], dictionary);
    }
    visitInterval(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            data,
            nullBitmap
        ]);
    }
    visitDuration(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            data,
            nullBitmap
        ]);
    }
    visitFixedSizeList(props) {
        const { ['type']: type, ['offset']: offset = 0, ['child']: child = new MakeDataVisitor().visit({
            type: type.valueType
        }) } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const { ['length']: length = child.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            undefined,
            undefined,
            nullBitmap
        ], [
            child
        ]);
    }
    visitMap(props) {
        const { ['type']: type, ['offset']: offset = 0, ['child']: child = new MakeDataVisitor().visit({
            type: type.childType
        }) } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [
            valueOffsets,
            undefined,
            nullBitmap
        ], [
            child
        ]);
    }
}
const makeDataVisitor = new MakeDataVisitor();
function makeData(props) {
    return makeDataVisitor.visit(props);
}
exports.makeData = makeData; //# sourceMappingURL=data.js.map
}),
"[project]/node_modules/apache-arrow/util/chunk.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapChunkedIndexOf = exports.wrapChunkedCall2 = exports.wrapChunkedCall1 = exports.isChunkedValid = exports.binarySearch = exports.sliceChunks = exports.computeChunkOffsets = exports.computeChunkNullCounts = exports.computeChunkNullable = exports.ChunkedIterator = void 0;
/** @ignore */ class ChunkedIterator {
    constructor(numChunks = 0, getChunkIterator){
        this.numChunks = numChunks;
        this.getChunkIterator = getChunkIterator;
        this.chunkIndex = 0;
        this.chunkIterator = this.getChunkIterator(0);
    }
    next() {
        while(this.chunkIndex < this.numChunks){
            const next = this.chunkIterator.next();
            if (!next.done) {
                return next;
            }
            if (++this.chunkIndex < this.numChunks) {
                this.chunkIterator = this.getChunkIterator(this.chunkIndex);
            }
        }
        return {
            done: true,
            value: null
        };
    }
    [Symbol.iterator]() {
        return this;
    }
}
exports.ChunkedIterator = ChunkedIterator;
/** @ignore */ function computeChunkNullable(chunks) {
    return chunks.some((chunk)=>chunk.nullable);
}
exports.computeChunkNullable = computeChunkNullable;
/** @ignore */ function computeChunkNullCounts(chunks) {
    return chunks.reduce((nullCount, chunk)=>nullCount + chunk.nullCount, 0);
}
exports.computeChunkNullCounts = computeChunkNullCounts;
/** @ignore */ function computeChunkOffsets(chunks) {
    return chunks.reduce((offsets, chunk, index)=>{
        offsets[index + 1] = offsets[index] + chunk.length;
        return offsets;
    }, new Uint32Array(chunks.length + 1));
}
exports.computeChunkOffsets = computeChunkOffsets;
/** @ignore */ function sliceChunks(chunks, offsets, begin, end) {
    const slices = [];
    for(let i = -1, n = chunks.length; ++i < n;){
        const chunk = chunks[i];
        const offset = offsets[i];
        const { length } = chunk;
        // Stop if the child is to the right of the slice boundary
        if (offset >= end) {
            break;
        }
        // Exclude children to the left of of the slice boundary
        if (begin >= offset + length) {
            continue;
        }
        // Include entire child if between both left and right boundaries
        if (offset >= begin && offset + length <= end) {
            slices.push(chunk);
            continue;
        }
        // Include the child slice that overlaps one of the slice boundaries
        const from = Math.max(0, begin - offset);
        const to = Math.min(end - offset, length);
        slices.push(chunk.slice(from, to - from));
    }
    if (slices.length === 0) {
        slices.push(chunks[0].slice(0, 0));
    }
    return slices;
}
exports.sliceChunks = sliceChunks;
/** @ignore */ function binarySearch(chunks, offsets, idx, fn) {
    let lhs = 0, mid = 0, rhs = offsets.length - 1;
    do {
        if (lhs >= rhs - 1) {
            return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;
        }
        mid = lhs + Math.trunc((rhs - lhs) * .5);
        idx < offsets[mid] ? rhs = mid : lhs = mid;
    }while (lhs < rhs)
}
exports.binarySearch = binarySearch;
/** @ignore */ function isChunkedValid(data, index) {
    return data.getValid(index);
}
exports.isChunkedValid = isChunkedValid;
/** @ignore */ function wrapChunkedCall1(fn) {
    function chunkedFn(chunks, i, j) {
        return fn(chunks[i], j);
    }
    return function(index) {
        const data = this.data;
        return binarySearch(data, this._offsets, index, chunkedFn);
    };
}
exports.wrapChunkedCall1 = wrapChunkedCall1;
/** @ignore */ function wrapChunkedCall2(fn) {
    let _2;
    function chunkedFn(chunks, i, j) {
        return fn(chunks[i], j, _2);
    }
    return function(index, value) {
        const data = this.data;
        _2 = value;
        const result = binarySearch(data, this._offsets, index, chunkedFn);
        _2 = undefined;
        return result;
    };
}
exports.wrapChunkedCall2 = wrapChunkedCall2;
/** @ignore */ function wrapChunkedIndexOf(indexOf) {
    let _1;
    function chunkedIndexOf(data, chunkIndex, fromIndex) {
        let begin = fromIndex, index = 0, total = 0;
        for(let i = chunkIndex - 1, n = data.length; ++i < n;){
            const chunk = data[i];
            if (~(index = indexOf(chunk, _1, begin))) {
                return total + index;
            }
            begin = 0;
            total += chunk.length;
        }
        return -1;
    }
    return function(element, offset) {
        _1 = element;
        const data = this.data;
        const result = typeof offset !== 'number' ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset, chunkedIndexOf);
        _1 = undefined;
        return result;
    };
}
exports.wrapChunkedIndexOf = wrapChunkedIndexOf; //# sourceMappingURL=chunk.js.map
}),
"[project]/node_modules/apache-arrow/visitor/indexof.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.instance = exports.IndexOfVisitor = void 0;
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
const get_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/get.js [app-ssr] (ecmascript)");
const bit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bit.js [app-ssr] (ecmascript)");
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/vector.js [app-ssr] (ecmascript)");
/** @ignore */ class IndexOfVisitor extends visitor_js_1.Visitor {
}
exports.IndexOfVisitor = IndexOfVisitor;
/** @ignore */ function nullIndexOf(data, searchElement) {
    // if you're looking for nulls and the vector isn't empty, we've got 'em!
    return searchElement === null && data.length > 0 ? 0 : -1;
}
/** @ignore */ function indexOfNull(data, fromIndex) {
    const { nullBitmap } = data;
    if (!nullBitmap || data.nullCount <= 0) {
        return -1;
    }
    let i = 0;
    for (const isValid of new bit_js_1.BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, bit_js_1.getBool)){
        if (!isValid) {
            return i;
        }
        ++i;
    }
    return -1;
}
/** @ignore */ function indexOfValue(data, searchElement, fromIndex) {
    if (searchElement === undefined) {
        return -1;
    }
    if (searchElement === null) {
        switch(data.typeId){
            // Unions don't have a nullBitmap of its own, so compare the `searchElement` to `get()`.
            case enum_js_1.Type.Union:
                break;
            // Dictionaries do have a nullBitmap, but their dictionary could also have null elements.
            case enum_js_1.Type.Dictionary:
                break;
            // All other types can iterate the null bitmap
            default:
                return indexOfNull(data, fromIndex);
        }
    }
    const get = get_js_1.instance.getVisitFn(data);
    const compare = (0, vector_js_1.createElementComparator)(searchElement);
    for(let i = (fromIndex || 0) - 1, n = data.length; ++i < n;){
        if (compare(get(data, i))) {
            return i;
        }
    }
    return -1;
}
/** @ignore */ function indexOfUnion(data, searchElement, fromIndex) {
    // Unions are special -- they do have a nullBitmap, but so can their children.
    // If the searchElement is null, we don't know whether it came from the Union's
    // bitmap or one of its children's. So we don't interrogate the Union's bitmap,
    // since that will report the wrong index if a child has a null before the Union.
    const get = get_js_1.instance.getVisitFn(data);
    const compare = (0, vector_js_1.createElementComparator)(searchElement);
    for(let i = (fromIndex || 0) - 1, n = data.length; ++i < n;){
        if (compare(get(data, i))) {
            return i;
        }
    }
    return -1;
}
IndexOfVisitor.prototype.visitNull = nullIndexOf;
IndexOfVisitor.prototype.visitBool = indexOfValue;
IndexOfVisitor.prototype.visitInt = indexOfValue;
IndexOfVisitor.prototype.visitInt8 = indexOfValue;
IndexOfVisitor.prototype.visitInt16 = indexOfValue;
IndexOfVisitor.prototype.visitInt32 = indexOfValue;
IndexOfVisitor.prototype.visitInt64 = indexOfValue;
IndexOfVisitor.prototype.visitUint8 = indexOfValue;
IndexOfVisitor.prototype.visitUint16 = indexOfValue;
IndexOfVisitor.prototype.visitUint32 = indexOfValue;
IndexOfVisitor.prototype.visitUint64 = indexOfValue;
IndexOfVisitor.prototype.visitFloat = indexOfValue;
IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
IndexOfVisitor.prototype.visitLargeUtf8 = indexOfValue;
IndexOfVisitor.prototype.visitBinary = indexOfValue;
IndexOfVisitor.prototype.visitLargeBinary = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
IndexOfVisitor.prototype.visitDate = indexOfValue;
IndexOfVisitor.prototype.visitDateDay = indexOfValue;
IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitTime = indexOfValue;
IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitDecimal = indexOfValue;
IndexOfVisitor.prototype.visitList = indexOfValue;
IndexOfVisitor.prototype.visitStruct = indexOfValue;
IndexOfVisitor.prototype.visitUnion = indexOfValue;
IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitDictionary = indexOfValue;
IndexOfVisitor.prototype.visitInterval = indexOfValue;
IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
IndexOfVisitor.prototype.visitDuration = indexOfValue;
IndexOfVisitor.prototype.visitDurationSecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
IndexOfVisitor.prototype.visitMap = indexOfValue;
/** @ignore */ exports.instance = new IndexOfVisitor(); //# sourceMappingURL=indexof.js.map
}),
"[project]/node_modules/apache-arrow/visitor/iterator.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.instance = exports.IteratorVisitor = void 0;
const visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const chunk_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/chunk.js [app-ssr] (ecmascript)");
/** @ignore */ class IteratorVisitor extends visitor_js_1.Visitor {
}
exports.IteratorVisitor = IteratorVisitor;
/** @ignore */ function vectorIterator(vector) {
    const { type } = vector;
    // Fast case, defer to native iterators if possible
    if (vector.nullCount === 0 && vector.stride === 1 && (// Don't defer to native iterator for timestamps since Numbers are expected
    // (DataType.isTimestamp(type)) && type.unit === TimeUnit.MILLISECOND ||
    type_js_1.DataType.isInt(type) && type.bitWidth !== 64 || type_js_1.DataType.isTime(type) && type.bitWidth !== 64 || type_js_1.DataType.isFloat(type) && type.precision !== enum_js_1.Precision.HALF)) {
        return new chunk_js_1.ChunkedIterator(vector.data.length, (chunkIndex)=>{
            const data = vector.data[chunkIndex];
            return data.values.subarray(0, data.length)[Symbol.iterator]();
        });
    }
    // Otherwise, iterate manually
    let offset = 0;
    return new chunk_js_1.ChunkedIterator(vector.data.length, (chunkIndex)=>{
        const data = vector.data[chunkIndex];
        const length = data.length;
        const inner = vector.slice(offset, offset + length);
        offset += length;
        return new VectorIterator(inner);
    });
}
/** @ignore */ class VectorIterator {
    constructor(vector){
        this.vector = vector;
        this.index = 0;
    }
    next() {
        if (this.index < this.vector.length) {
            return {
                value: this.vector.get(this.index++)
            };
        }
        return {
            done: true,
            value: null
        };
    }
    [Symbol.iterator]() {
        return this;
    }
}
IteratorVisitor.prototype.visitNull = vectorIterator;
IteratorVisitor.prototype.visitBool = vectorIterator;
IteratorVisitor.prototype.visitInt = vectorIterator;
IteratorVisitor.prototype.visitInt8 = vectorIterator;
IteratorVisitor.prototype.visitInt16 = vectorIterator;
IteratorVisitor.prototype.visitInt32 = vectorIterator;
IteratorVisitor.prototype.visitInt64 = vectorIterator;
IteratorVisitor.prototype.visitUint8 = vectorIterator;
IteratorVisitor.prototype.visitUint16 = vectorIterator;
IteratorVisitor.prototype.visitUint32 = vectorIterator;
IteratorVisitor.prototype.visitUint64 = vectorIterator;
IteratorVisitor.prototype.visitFloat = vectorIterator;
IteratorVisitor.prototype.visitFloat16 = vectorIterator;
IteratorVisitor.prototype.visitFloat32 = vectorIterator;
IteratorVisitor.prototype.visitFloat64 = vectorIterator;
IteratorVisitor.prototype.visitUtf8 = vectorIterator;
IteratorVisitor.prototype.visitLargeUtf8 = vectorIterator;
IteratorVisitor.prototype.visitBinary = vectorIterator;
IteratorVisitor.prototype.visitLargeBinary = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
IteratorVisitor.prototype.visitDate = vectorIterator;
IteratorVisitor.prototype.visitDateDay = vectorIterator;
IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestamp = vectorIterator;
IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
IteratorVisitor.prototype.visitTime = vectorIterator;
IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
IteratorVisitor.prototype.visitDecimal = vectorIterator;
IteratorVisitor.prototype.visitList = vectorIterator;
IteratorVisitor.prototype.visitStruct = vectorIterator;
IteratorVisitor.prototype.visitUnion = vectorIterator;
IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
IteratorVisitor.prototype.visitDictionary = vectorIterator;
IteratorVisitor.prototype.visitInterval = vectorIterator;
IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
IteratorVisitor.prototype.visitDuration = vectorIterator;
IteratorVisitor.prototype.visitDurationSecond = vectorIterator;
IteratorVisitor.prototype.visitDurationMillisecond = vectorIterator;
IteratorVisitor.prototype.visitDurationMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitDurationNanosecond = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
IteratorVisitor.prototype.visitMap = vectorIterator;
/** @ignore */ exports.instance = new IteratorVisitor(); //# sourceMappingURL=iterator.js.map
}),
"[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeVector = exports.Vector = void 0;
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/vector.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const data_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/data.js [app-ssr] (ecmascript)");
const chunk_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/chunk.js [app-ssr] (ecmascript)");
const get_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/get.js [app-ssr] (ecmascript)");
const set_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)");
const indexof_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/indexof.js [app-ssr] (ecmascript)");
const iterator_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/iterator.js [app-ssr] (ecmascript)");
const visitorsByTypeId = {};
const vectorPrototypesByTypeId = {};
/**
 * Array-like data structure. Use the convenience method {@link makeVector} and {@link vectorFromArray} to create vectors.
 */ class Vector {
    constructor(input){
        var _b, _c, _d;
        const data = input[0] instanceof Vector ? input.flatMap((x)=>x.data) : input;
        if (data.length === 0 || data.some((x)=>!(x instanceof data_js_1.Data))) {
            throw new TypeError('Vector constructor expects an Array of Data instances.');
        }
        const type = (_b = data[0]) === null || _b === void 0 ? void 0 : _b.type;
        switch(data.length){
            case 0:
                this._offsets = [
                    0
                ];
                break;
            case 1:
                {
                    // special case for unchunked vectors
                    const { get, set, indexOf } = visitorsByTypeId[type.typeId];
                    const unchunkedData = data[0];
                    this.isValid = (index)=>(0, chunk_js_1.isChunkedValid)(unchunkedData, index);
                    this.get = (index)=>get(unchunkedData, index);
                    this.set = (index, value)=>set(unchunkedData, index, value);
                    this.indexOf = (index)=>indexOf(unchunkedData, index);
                    this._offsets = [
                        0,
                        unchunkedData.length
                    ];
                    break;
                }
            default:
                Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);
                this._offsets = (0, chunk_js_1.computeChunkOffsets)(data);
                break;
        }
        this.data = data;
        this.type = type;
        this.stride = (0, type_js_1.strideForType)(type);
        this.numChildren = (_d = (_c = type.children) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
        this.length = this._offsets.at(-1);
    }
    /**
     * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
     */ get byteLength() {
        return this.data.reduce((byteLength, data)=>byteLength + data.byteLength, 0);
    }
    /**
     * Whether this Vector's elements can contain null values.
     */ get nullable() {
        return (0, chunk_js_1.computeChunkNullable)(this.data);
    }
    /**
     * The number of null elements in this Vector.
     */ get nullCount() {
        return (0, chunk_js_1.computeChunkNullCounts)(this.data);
    }
    /**
     * The Array or TypedArray constructor used for the JS representation
     *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
     */ get ArrayType() {
        return this.type.ArrayType;
    }
    /**
     * The name that should be printed when the Vector is logged in a message.
     */ get [Symbol.toStringTag]() {
        return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
    }
    /**
     * The name of this Vector.
     */ get VectorName() {
        return `${enum_js_1.Type[this.type.typeId]}Vector`;
    }
    /**
     * Check whether an element is null.
     * @param index The index at which to read the validity bitmap.
     */ // @ts-ignore
    isValid(index) {
        return false;
    }
    /**
     * Get an element value by position.
     * @param index The index of the element to read.
     */ // @ts-ignore
    get(index) {
        return null;
    }
    /**
     * Get an element value by position.
     * @param index The index of the element to read. A negative index will count back from the last element.
     */ at(index) {
        return this.get((0, vector_js_1.wrapIndex)(index, this.length));
    }
    /**
     * Set an element value by position.
     * @param index The index of the element to write.
     * @param value The value to set.
     */ // @ts-ignore
    set(index, value) {
        return;
    }
    /**
     * Retrieve the index of the first occurrence of a value in an Vector.
     * @param element The value to locate in the Vector.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */ // @ts-ignore
    indexOf(element, offset) {
        return -1;
    }
    includes(element, offset) {
        // eslint-disable-next-line unicorn/prefer-includes
        return this.indexOf(element, offset) > -1;
    }
    /**
     * Iterator for the Vector's elements.
     */ [Symbol.iterator]() {
        return iterator_js_1.instance.visit(this);
    }
    /**
     * Combines two or more Vectors of the same type.
     * @param others Additional Vectors to add to the end of this Vector.
     */ concat(...others) {
        return new Vector(this.data.concat(others.flatMap((x)=>x.data).flat(Number.POSITIVE_INFINITY)));
    }
    /**
     * Return a zero-copy sub-section of this Vector.
     * @param start The beginning of the specified portion of the Vector.
     * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
     */ slice(begin, end) {
        return new Vector((0, vector_js_1.clampRange)(this, begin, end, ({ data, _offsets }, begin, end)=>(0, chunk_js_1.sliceChunks)(data, _offsets, begin, end)));
    }
    toJSON() {
        return [
            ...this
        ];
    }
    /**
     * Return a JavaScript Array or TypedArray of the Vector's elements.
     *
     * @note If this Vector contains a single Data chunk and the Vector's type is a
     *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
     *  method returns a zero-copy slice of the underlying TypedArray values. If there's
     *  more than one chunk, the resulting TypedArray will be a copy of the data from each
     *  chunk's underlying TypedArray values.
     *
     * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
     */ toArray() {
        const { type, data, length, stride, ArrayType } = this;
        // Fast case, return subarray if possible
        switch(type.typeId){
            case enum_js_1.Type.Int:
            case enum_js_1.Type.Float:
            case enum_js_1.Type.Decimal:
            case enum_js_1.Type.Time:
            case enum_js_1.Type.Timestamp:
                switch(data.length){
                    case 0:
                        return new ArrayType();
                    case 1:
                        return data[0].values.subarray(0, length * stride);
                    default:
                        return data.reduce((memo, { values, length: chunk_length })=>{
                            memo.array.set(values.subarray(0, chunk_length * stride), memo.offset);
                            memo.offset += chunk_length * stride;
                            return memo;
                        }, {
                            array: new ArrayType(length * stride),
                            offset: 0
                        }).array;
                }
        }
        // Otherwise if not primitive, slow copy
        return [
            ...this
        ];
    }
    /**
     * Returns a string representation of the Vector.
     *
     * @returns A string representation of the Vector.
     */ toString() {
        return `[${[
            ...this
        ].join(',')}]`;
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     * @param name The name of the child to retrieve.
     */ getChild(name) {
        var _b;
        return this.getChildAt((_b = this.type.children) === null || _b === void 0 ? void 0 : _b.findIndex((f)=>f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     * @param index The index of the child to retrieve.
     */ getChildAt(index) {
        if (index > -1 && index < this.numChildren) {
            return new Vector(this.data.map(({ children })=>children[index]));
        }
        return null;
    }
    get isMemoized() {
        if (type_js_1.DataType.isDictionary(this.type)) {
            return this.data[0].dictionary.isMemoized;
        }
        return false;
    }
    /**
     * Adds memoization to the Vector's {@link get} method. For dictionary
     * vectors, this method return a vector that memoizes only the dictionary
     * values.
     *
     * Memoization is very useful when decoding a value is expensive such as
     * Utf8. The memoization creates a cache of the size of the Vector and
     * therefore increases memory usage.
     *
     * @returns A new vector that memoizes calls to {@link get}.
     */ memoize() {
        if (type_js_1.DataType.isDictionary(this.type)) {
            const dictionary = new MemoizedVector(this.data[0].dictionary);
            const newData = this.data.map((data)=>{
                const cloned = data.clone();
                cloned.dictionary = dictionary;
                return cloned;
            });
            return new Vector(newData);
        }
        return new MemoizedVector(this);
    }
    /**
     * Returns a vector without memoization of the {@link get} method. If this
     * vector is not memoized, this method returns this vector.
     *
     * @returns A new vector without memoization.
     */ unmemoize() {
        if (type_js_1.DataType.isDictionary(this.type) && this.isMemoized) {
            const dictionary = this.data[0].dictionary.unmemoize();
            const newData = this.data.map((data)=>{
                const newData = data.clone();
                newData.dictionary = dictionary;
                return newData;
            });
            return new Vector(newData);
        }
        return this;
    }
}
exports.Vector = Vector;
_a = Symbol.toStringTag;
// Initialize this static property via an IIFE so bundlers don't tree-shake
// out this logic, but also so we're still compliant with `"sideEffects": false`
Vector[_a] = ((proto)=>{
    proto.type = type_js_1.DataType.prototype;
    proto.data = [];
    proto.length = 0;
    proto.stride = 1;
    proto.numChildren = 0;
    proto._offsets = new Uint32Array([
        0
    ]);
    proto[Symbol.isConcatSpreadable] = true;
    const typeIds = Object.keys(enum_js_1.Type).map((T)=>enum_js_1.Type[T]).filter((T)=>typeof T === 'number' && T !== enum_js_1.Type.NONE);
    for (const typeId of typeIds){
        const get = get_js_1.instance.getVisitFnByTypeId(typeId);
        const set = set_js_1.instance.getVisitFnByTypeId(typeId);
        const indexOf = indexof_js_1.instance.getVisitFnByTypeId(typeId);
        visitorsByTypeId[typeId] = {
            get,
            set,
            indexOf
        };
        vectorPrototypesByTypeId[typeId] = Object.create(proto, {
            ['isValid']: {
                value: (0, chunk_js_1.wrapChunkedCall1)(chunk_js_1.isChunkedValid)
            },
            ['get']: {
                value: (0, chunk_js_1.wrapChunkedCall1)(get_js_1.instance.getVisitFnByTypeId(typeId))
            },
            ['set']: {
                value: (0, chunk_js_1.wrapChunkedCall2)(set_js_1.instance.getVisitFnByTypeId(typeId))
            },
            ['indexOf']: {
                value: (0, chunk_js_1.wrapChunkedIndexOf)(indexof_js_1.instance.getVisitFnByTypeId(typeId))
            }
        });
    }
    return 'Vector';
})(Vector.prototype);
class MemoizedVector extends Vector {
    constructor(vector){
        super(vector.data);
        const get = this.get;
        const set = this.set;
        const slice = this.slice;
        const cache = new Array(this.length);
        Object.defineProperty(this, 'get', {
            value (index) {
                const cachedValue = cache[index];
                if (cachedValue !== undefined) {
                    return cachedValue;
                }
                const value = get.call(this, index);
                cache[index] = value;
                return value;
            }
        });
        Object.defineProperty(this, 'set', {
            value (index, value) {
                set.call(this, index, value);
                cache[index] = value;
            }
        });
        Object.defineProperty(this, 'slice', {
            value: (begin, end)=>new MemoizedVector(slice.call(this, begin, end))
        });
        Object.defineProperty(this, 'isMemoized', {
            value: true
        });
        Object.defineProperty(this, 'unmemoize', {
            value: ()=>new Vector(this.data)
        });
        Object.defineProperty(this, 'memoize', {
            value: ()=>this
        });
    }
}
const dtypes = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
function makeVector(init) {
    if (init) {
        if (init instanceof data_js_1.Data) {
            return new Vector([
                init
            ]);
        }
        if (init instanceof Vector) {
            return new Vector(init.data);
        }
        if (init.type instanceof type_js_1.DataType) {
            return new Vector([
                (0, data_js_1.makeData)(init)
            ]);
        }
        if (Array.isArray(init)) {
            return new Vector(init.flatMap((v)=>unwrapInputs(v)));
        }
        if (ArrayBuffer.isView(init)) {
            if (init instanceof DataView) {
                init = new Uint8Array(init.buffer);
            }
            const props = {
                offset: 0,
                length: init.length,
                nullCount: -1,
                data: init
            };
            if (init instanceof Int8Array) {
                return new Vector([
                    (0, data_js_1.makeData)(Object.assign(Object.assign({}, props), {
                        type: new dtypes.Int8
                    }))
                ]);
            }
            if (init instanceof Int16Array) {
                return new Vector([
                    (0, data_js_1.makeData)(Object.assign(Object.assign({}, props), {
                        type: new dtypes.Int16
                    }))
                ]);
            }
            if (init instanceof Int32Array) {
                return new Vector([
                    (0, data_js_1.makeData)(Object.assign(Object.assign({}, props), {
                        type: new dtypes.Int32
                    }))
                ]);
            }
            if (init instanceof BigInt64Array) {
                return new Vector([
                    (0, data_js_1.makeData)(Object.assign(Object.assign({}, props), {
                        type: new dtypes.Int64
                    }))
                ]);
            }
            if (init instanceof Uint8Array || init instanceof Uint8ClampedArray) {
                return new Vector([
                    (0, data_js_1.makeData)(Object.assign(Object.assign({}, props), {
                        type: new dtypes.Uint8
                    }))
                ]);
            }
            if (init instanceof Uint16Array) {
                return new Vector([
                    (0, data_js_1.makeData)(Object.assign(Object.assign({}, props), {
                        type: new dtypes.Uint16
                    }))
                ]);
            }
            if (init instanceof Uint32Array) {
                return new Vector([
                    (0, data_js_1.makeData)(Object.assign(Object.assign({}, props), {
                        type: new dtypes.Uint32
                    }))
                ]);
            }
            if (init instanceof BigUint64Array) {
                return new Vector([
                    (0, data_js_1.makeData)(Object.assign(Object.assign({}, props), {
                        type: new dtypes.Uint64
                    }))
                ]);
            }
            if (init instanceof Float32Array) {
                return new Vector([
                    (0, data_js_1.makeData)(Object.assign(Object.assign({}, props), {
                        type: new dtypes.Float32
                    }))
                ]);
            }
            if (init instanceof Float64Array) {
                return new Vector([
                    (0, data_js_1.makeData)(Object.assign(Object.assign({}, props), {
                        type: new dtypes.Float64
                    }))
                ]);
            }
            throw new Error('Unrecognized input');
        }
    }
    throw new Error('Unrecognized input');
}
exports.makeVector = makeVector;
function unwrapInputs(x) {
    return x instanceof data_js_1.Data ? [
        x
    ] : x instanceof Vector ? x.data : makeVector(x).data;
} //# sourceMappingURL=vector.js.map
}),
"[project]/node_modules/apache-arrow/builder/valid.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createIsValidFunction = void 0;
const pretty_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/pretty.js [app-ssr] (ecmascript)");
/**
 * Dynamically compile the null values into an `isValid()` function whose
 * implementation is a switch statement. Microbenchmarks in v8 indicate
 * this approach is 25% faster than using an ES6 Map.
 *
 * @example
 * console.log(createIsValidFunction([null, 'N/A', NaN]));
 * `function (x) {
 *     if (x !== x) return false;
 *     switch (x) {
 *         case null:
 *         case "N/A":
 *             return false;
 *     }
 *     return true;
 * }`
 *
 * @ignore
 * @param nullValues
 */ function createIsValidFunction(nullValues) {
    if (!nullValues || nullValues.length <= 0) {
        // @ts-ignore
        return function isValid(value) {
            return true;
        };
    }
    let fnBody = '';
    const noNaNs = nullValues.filter((x)=>x === x);
    if (noNaNs.length > 0) {
        fnBody = `
    switch (x) {${noNaNs.map((x)=>`
        case ${valueToCase(x)}:`).join('')}
            return false;
    }`;
    }
    // NaN doesn't equal anything including itself, so it doesn't work as a
    // switch case. Instead we must explicitly check for NaN before the switch.
    if (nullValues.length !== noNaNs.length) {
        fnBody = `if (x !== x) return false;\n${fnBody}`;
    }
    return new Function(`x`, `${fnBody}\nreturn true;`);
}
exports.createIsValidFunction = createIsValidFunction;
/** @ignore */ function valueToCase(x) {
    if (typeof x !== 'bigint') {
        return (0, pretty_js_1.valueToString)(x);
    }
    return `${(0, pretty_js_1.valueToString)(x)}n`;
} //# sourceMappingURL=valid.js.map
}),
"[project]/node_modules/apache-arrow/builder/buffer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OffsetsBufferBuilder = exports.BitmapBufferBuilder = exports.DataBufferBuilder = exports.BufferBuilder = void 0;
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
/** @ignore */ function roundLengthUpToNearest64Bytes(len, BPE) {
    const bytesMinus1 = Math.ceil(len) * BPE - 1;
    return (bytesMinus1 - bytesMinus1 % 64 + 64 || 64) / BPE;
}
/** @ignore */ function resizeArray(arr, len = 0) {
    return arr.length >= len ? arr.subarray(0, len) : (0, buffer_js_1.memcpy)(new arr.constructor(len), arr, 0);
}
/** @ignore */ class BufferBuilder {
    constructor(bufferType, initialSize = 0, stride = 1){
        this.length = Math.ceil(initialSize / stride);
        this.buffer = new bufferType(this.length);
        this.stride = stride;
        this.BYTES_PER_ELEMENT = bufferType.BYTES_PER_ELEMENT;
        this.ArrayType = bufferType;
    }
    get byteLength() {
        return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
    }
    get reservedLength() {
        return this.buffer.length / this.stride;
    }
    get reservedByteLength() {
        return this.buffer.byteLength;
    }
    // @ts-ignore
    set(index, value) {
        return this;
    }
    append(value) {
        return this.set(this.length, value);
    }
    reserve(extra) {
        if (extra > 0) {
            this.length += extra;
            const stride = this.stride;
            const length = this.length * stride;
            const reserved = this.buffer.length;
            if (length >= reserved) {
                this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT));
            }
        }
        return this;
    }
    flush(length = this.length) {
        length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);
        const array = resizeArray(this.buffer, length);
        this.clear();
        return array;
    }
    clear() {
        this.length = 0;
        this.buffer = new this.ArrayType();
        return this;
    }
    _resize(newLength) {
        return this.buffer = resizeArray(this.buffer, newLength);
    }
}
exports.BufferBuilder = BufferBuilder;
/** @ignore */ class DataBufferBuilder extends BufferBuilder {
    last() {
        return this.get(this.length - 1);
    }
    get(index) {
        return this.buffer[index];
    }
    set(index, value) {
        this.reserve(index - this.length + 1);
        this.buffer[index * this.stride] = value;
        return this;
    }
}
exports.DataBufferBuilder = DataBufferBuilder;
/** @ignore */ class BitmapBufferBuilder extends DataBufferBuilder {
    constructor(){
        super(Uint8Array, 0, 1 / 8);
        this.numValid = 0;
    }
    get numInvalid() {
        return this.length - this.numValid;
    }
    get(idx) {
        return this.buffer[idx >> 3] >> idx % 8 & 1;
    }
    set(idx, val) {
        const { buffer } = this.reserve(idx - this.length + 1);
        const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
        // If `val` is truthy and the current bit is 0, flip it to 1 and increment `numValid`.
        // If `val` is falsey and the current bit is 1, flip it to 0 and decrement `numValid`.
        val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);
        return this;
    }
    clear() {
        this.numValid = 0;
        return super.clear();
    }
}
exports.BitmapBufferBuilder = BitmapBufferBuilder;
/** @ignore */ class OffsetsBufferBuilder extends DataBufferBuilder {
    constructor(type){
        super(type.OffsetArrayType, 1, 1);
    }
    append(value) {
        return this.set(this.length - 1, value);
    }
    set(index, value) {
        const offset = this.length - 1;
        const buffer = this.reserve(index - offset + 1).buffer;
        if (offset < index++ && offset >= 0) {
            buffer.fill(buffer[offset], offset, index);
        }
        buffer[index] = buffer[index - 1] + value;
        return this;
    }
    flush(length = this.length - 1) {
        if (length > this.length) {
            this.set(length - 1, this.BYTES_PER_ELEMENT > 4 ? BigInt(0) : 0);
        }
        return super.flush(length + 1);
    }
}
exports.OffsetsBufferBuilder = OffsetsBufferBuilder; //# sourceMappingURL=buffer.js.map
}),
"[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VariableWidthBuilder = exports.FixedWidthBuilder = exports.Builder = void 0;
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const data_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/data.js [app-ssr] (ecmascript)");
const map_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/row/map.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const valid_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/valid.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/buffer.js [app-ssr] (ecmascript)");
/**
 * An abstract base class for types that construct Arrow Vectors from arbitrary JavaScript values.
 *
 * A `Builder` is responsible for writing arbitrary JavaScript values
 * to ArrayBuffers and/or child Builders according to the Arrow specification
 * for each DataType, creating or resizing the underlying ArrayBuffers as necessary.
 *
 * The `Builder` for each Arrow `DataType` handles converting and appending
 * values for a given `DataType`. The high-level {@link makeBuilder `makeBuilder()`} convenience
 * method creates the specific `Builder` subclass for the supplied `DataType`.
 *
 * Once created, `Builder` instances support both appending values to the end
 * of the `Builder`, and random-access writes to specific indices
 * (`Builder.prototype.append(value)` is a convenience method for
 * `builder.set(builder.length, value)`). Appending or setting values beyond the
 * Builder's current length may cause the builder to grow its underlying buffers
 * or child Builders (if applicable) to accommodate the new values.
 *
 * After enough values have been written to a `Builder`, `Builder.prototype.flush()`
 * will commit the values to the underlying ArrayBuffers (or child Builders). The
 * internal Builder state will be reset, and an instance of `Data<T>` is returned.
 * Alternatively, `Builder.prototype.toVector()` will flush the `Builder` and return
 * an instance of `Vector<T>` instead.
 *
 * When there are no more values to write, use `Builder.prototype.finish()` to
 * finalize the `Builder`. This does not reset the internal state, so it is
 * necessary to call `Builder.prototype.flush()` or `toVector()` one last time
 * if there are still values queued to be flushed.
 *
 * Note: calling `Builder.prototype.finish()` is required when using a `DictionaryBuilder`,
 * because this is when it flushes the values that have been enqueued in its internal
 * dictionary's `Builder`, and creates the `dictionaryVector` for the `Dictionary` `DataType`.
 *
 * @example
 * ```ts
 * import { makeBuilder, Utf8 } from 'apache-arrow';
 *
 * const utf8Builder = makeBuilder({
 *     type: new Utf8(),
 *     nullValues: [null, 'n/a']
 * });
 *
 * utf8Builder
 *     .append('hello')
 *     .append('n/a')
 *     .append('world')
 *     .append(null);
 *
 * const utf8Vector = utf8Builder.finish().toVector();
 *
 * console.log(utf8Vector.toJSON());
 * // > ["hello", null, "world", null]
 * ```
 *
 * @typeparam T The `DataType` of this `Builder`.
 * @typeparam TNull The type(s) of values which will be considered null-value sentinels.
 */ class Builder {
    /** @nocollapse */ // @ts-ignore
    static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */ // @ts-ignore
    static throughDOM(options) {
        throw new Error(`"throughDOM" not available in this environment`);
    }
    /**
     * Construct a builder with the given Arrow DataType with optional null values,
     * which will be interpreted as "null" when set or appended to the `Builder`.
     * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
     */ constructor({ 'type': type, 'nullValues': nulls }){
        /**
         * The number of values written to the `Builder` that haven't been flushed yet.
         * @readonly
         */ this.length = 0;
        /**
         * A boolean indicating whether `Builder.prototype.finish()` has been called on this `Builder`.
         * @readonly
         */ this.finished = false;
        this.type = type;
        this.children = [];
        this.nullValues = nulls;
        this.stride = (0, type_js_1.strideForType)(type);
        this._nulls = new buffer_js_1.BitmapBufferBuilder();
        if (nulls && nulls.length > 0) {
            this._isValid = (0, valid_js_1.createIsValidFunction)(nulls);
        }
    }
    /**
     * Flush the `Builder` and return a `Vector<T>`.
     * @returns {Vector<T>} A `Vector<T>` of the flushed values.
     */ toVector() {
        return new vector_js_1.Vector([
            this.flush()
        ]);
    }
    get ArrayType() {
        return this.type.ArrayType;
    }
    get nullCount() {
        return this._nulls.numInvalid;
    }
    get numChildren() {
        return this.children.length;
    }
    /**
     * @returns The aggregate length (in bytes) of the values that have been written.
     */ get byteLength() {
        let size = 0;
        const { _offsets, _values, _nulls, _typeIds, children } = this;
        _offsets && (size += _offsets.byteLength);
        _values && (size += _values.byteLength);
        _nulls && (size += _nulls.byteLength);
        _typeIds && (size += _typeIds.byteLength);
        return children.reduce((size, child)=>size + child.byteLength, size);
    }
    /**
     * @returns The aggregate number of rows that have been reserved to write new values.
     */ get reservedLength() {
        return this._nulls.reservedLength;
    }
    /**
     * @returns The aggregate length (in bytes) that has been reserved to write new values.
     */ get reservedByteLength() {
        let size = 0;
        this._offsets && (size += this._offsets.reservedByteLength);
        this._values && (size += this._values.reservedByteLength);
        this._nulls && (size += this._nulls.reservedByteLength);
        this._typeIds && (size += this._typeIds.reservedByteLength);
        return this.children.reduce((size, child)=>size + child.reservedByteLength, size);
    }
    get valueOffsets() {
        return this._offsets ? this._offsets.buffer : null;
    }
    get values() {
        return this._values ? this._values.buffer : null;
    }
    get nullBitmap() {
        return this._nulls ? this._nulls.buffer : null;
    }
    get typeIds() {
        return this._typeIds ? this._typeIds.buffer : null;
    }
    /**
     * Appends a value (or null) to this `Builder`.
     * This is equivalent to `builder.set(builder.length, value)`.
     * @param {T['TValue'] | TNull } value The value to append.
     */ append(value) {
        return this.set(this.length, value);
    }
    /**
     * Validates whether a value is valid (true), or null (false)
     * @param {T['TValue'] | TNull } value The value to compare against null the value representations
     */ isValid(value) {
        return this._isValid(value);
    }
    /**
     * Write a value (or null-value sentinel) at the supplied index.
     * If the value matches one of the null-value representations, a 1-bit is
     * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
     * the null `BitmapBufferBuilder`, and the value is passed to
     * `Builder.prototype.setValue()`.
     * @param {number} index The index of the value to write.
     * @param {T['TValue'] | TNull } value The value to write at the supplied index.
     * @returns {this} The updated `Builder` instance.
     */ set(index, value) {
        if (this.setValid(index, this.isValid(value))) {
            this.setValue(index, value);
        }
        return this;
    }
    /**
     * Write a value to the underlying buffers at the supplied index, bypassing
     * the null-value check. This is a low-level method that
     * @param {number} index
     * @param {T['TValue'] | TNull } value
     */ setValue(index, value) {
        this._setValue(this, index, value);
    }
    setValid(index, valid) {
        this.length = this._nulls.set(index, +valid).length;
        return valid;
    }
    // @ts-ignore
    addChild(child, name = `${this.numChildren}`) {
        throw new Error(`Cannot append children to non-nested type "${this.type}"`);
    }
    /**
     * Retrieve the child `Builder` at the supplied `index`, or null if no child
     * exists at that index.
     * @param {number} index The index of the child `Builder` to retrieve.
     * @returns {Builder | null} The child Builder at the supplied index or null.
     */ getChildAt(index) {
        return this.children[index] || null;
    }
    /**
     * Commit all the values that have been written to their underlying
     * ArrayBuffers, including any child Builders if applicable, and reset
     * the internal `Builder` state.
     * @returns A `Data<T>` of the buffers and children representing the values written.
     */ flush() {
        let data;
        let typeIds;
        let nullBitmap;
        let valueOffsets;
        const { type, length, nullCount, _typeIds, _offsets, _values, _nulls } = this;
        if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length)) {
            valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length);
        } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length)) {
            data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
        } else {
            data = _values === null || _values === void 0 ? void 0 : _values.flush(length);
        }
        if (nullCount > 0) {
            nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length);
        }
        const children = this.children.map((child)=>child.flush());
        this.clear();
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            children,
            'child': children[0],
            data,
            typeIds,
            nullBitmap,
            valueOffsets
        });
    }
    /**
     * Finalize this `Builder`, and child builders if applicable.
     * @returns {this} The finalized `Builder` instance.
     */ finish() {
        this.finished = true;
        for (const child of this.children)child.finish();
        return this;
    }
    /**
     * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.
     * @returns {this} The cleared `Builder` instance.
     */ clear() {
        var _a, _b, _c, _d;
        this.length = 0;
        (_a = this._nulls) === null || _a === void 0 ? void 0 : _a.clear();
        (_b = this._values) === null || _b === void 0 ? void 0 : _b.clear();
        (_c = this._offsets) === null || _c === void 0 ? void 0 : _c.clear();
        (_d = this._typeIds) === null || _d === void 0 ? void 0 : _d.clear();
        for (const child of this.children)child.clear();
        return this;
    }
}
exports.Builder = Builder;
Builder.prototype.length = 1;
Builder.prototype.stride = 1;
Builder.prototype.children = null;
Builder.prototype.finished = false;
Builder.prototype.nullValues = null;
Builder.prototype._isValid = ()=>true;
/** @ignore */ class FixedWidthBuilder extends Builder {
    constructor(opts){
        super(opts);
        this._values = new buffer_js_1.DataBufferBuilder(this.ArrayType, 0, this.stride);
    }
    setValue(index, value) {
        const values = this._values;
        values.reserve(index - values.length + 1);
        return super.setValue(index, value);
    }
}
exports.FixedWidthBuilder = FixedWidthBuilder;
/** @ignore */ class VariableWidthBuilder extends Builder {
    constructor(opts){
        super(opts);
        this._pendingLength = 0;
        this._offsets = new buffer_js_1.OffsetsBufferBuilder(opts.type);
    }
    setValue(index, value) {
        const pending = this._pending || (this._pending = new Map());
        const current = pending.get(index);
        current && (this._pendingLength -= current.length);
        this._pendingLength += value instanceof map_js_1.MapRow ? value[map_js_1.kKeys].length : value.length;
        pending.set(index, value);
    }
    setValid(index, isValid) {
        if (!super.setValid(index, isValid)) {
            (this._pending || (this._pending = new Map())).set(index, undefined);
            return false;
        }
        return true;
    }
    clear() {
        this._pendingLength = 0;
        this._pending = undefined;
        return super.clear();
    }
    flush() {
        this._flush();
        return super.flush();
    }
    finish() {
        this._flush();
        return super.finish();
    }
    _flush() {
        const pending = this._pending;
        const pendingLength = this._pendingLength;
        this._pendingLength = 0;
        this._pending = undefined;
        if (pending && pending.size > 0) {
            this._flushPending(pending, pendingLength);
        }
        return this;
    }
}
exports.VariableWidthBuilder = VariableWidthBuilder; //# sourceMappingURL=builder.js.map
}),
"[project]/node_modules/apache-arrow/fb/block.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Block = void 0;
class Block {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    /**
     * Index to the start of the RecordBlock (note this is past the Message header)
     */ offset() {
        return this.bb.readInt64(this.bb_pos);
    }
    /**
     * Length of the metadata
     */ metaDataLength() {
        return this.bb.readInt32(this.bb_pos + 8);
    }
    /**
     * Length of the data (this is aligned so there can be a gap between this and
     * the metadata).
     */ bodyLength() {
        return this.bb.readInt64(this.bb_pos + 16);
    }
    static sizeOf() {
        return 24;
    }
    static createBlock(builder, offset, metaDataLength, bodyLength) {
        builder.prep(8, 24);
        builder.writeInt64(BigInt(bodyLength !== null && bodyLength !== void 0 ? bodyLength : 0));
        builder.pad(4);
        builder.writeInt32(metaDataLength);
        builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));
        return builder.offset();
    }
}
exports.Block = Block; //# sourceMappingURL=block.js.map
}),
"[project]/node_modules/apache-arrow/fb/footer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Footer = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const block_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/block.js [app-ssr] (ecmascript)");
const key_value_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/key-value.js [app-ssr] (ecmascript)");
const metadata_version_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/metadata-version.js [app-ssr] (ecmascript)");
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/schema.js [app-ssr] (ecmascript)");
/**
 * ----------------------------------------------------------------------
 * Arrow File metadata
 *
 */ class Footer {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFooter(bb, obj) {
        return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFooter(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : metadata_version_js_1.MetadataVersion.V1;
    }
    schema(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new schema_js_1.Schema()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    dictionaries(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new block_js_1.Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    dictionariesLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    recordBatches(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new block_js_1.Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    recordBatchesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * User-defined metadata
     */ customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startFooter(builder) {
        builder.startObject(5);
    }
    static addVersion(builder, version) {
        builder.addFieldInt16(0, version, metadata_version_js_1.MetadataVersion.V1);
    }
    static addSchema(builder, schemaOffset) {
        builder.addFieldOffset(1, schemaOffset, 0);
    }
    static addDictionaries(builder, dictionariesOffset) {
        builder.addFieldOffset(2, dictionariesOffset, 0);
    }
    static startDictionariesVector(builder, numElems) {
        builder.startVector(24, numElems, 8);
    }
    static addRecordBatches(builder, recordBatchesOffset) {
        builder.addFieldOffset(3, recordBatchesOffset, 0);
    }
    static startRecordBatchesVector(builder, numElems) {
        builder.startVector(24, numElems, 8);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endFooter(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishFooterBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedFooterBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
}
exports.Footer = Footer; //# sourceMappingURL=footer.js.map
}),
"[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Field = exports.Schema = void 0;
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
class Schema {
    constructor(fields = [], metadata, dictionaries, metadataVersion = enum_js_1.MetadataVersion.V5){
        this.fields = fields || [];
        this.metadata = metadata || new Map();
        if (!dictionaries) {
            dictionaries = generateDictionaryMap(this.fields);
        }
        this.dictionaries = dictionaries;
        this.metadataVersion = metadataVersion;
    }
    get [Symbol.toStringTag]() {
        return 'Schema';
    }
    get names() {
        return this.fields.map((f)=>f.name);
    }
    toString() {
        return `Schema<{ ${this.fields.map((f, i)=>`${i}: ${f}`).join(', ')} }>`;
    }
    /**
     * Construct a new Schema containing only specified fields.
     *
     * @param fieldNames Names of fields to keep.
     * @returns A new Schema of fields matching the specified names.
     */ select(fieldNames) {
        const names = new Set(fieldNames);
        const fields = this.fields.filter((f)=>names.has(f.name));
        return new Schema(fields, this.metadata);
    }
    /**
     * Construct a new Schema containing only fields at the specified indices.
     *
     * @param fieldIndices Indices of fields to keep.
     * @returns A new Schema of fields at the specified indices.
     */ selectAt(fieldIndices) {
        const fields = fieldIndices.map((i)=>this.fields[i]).filter(Boolean);
        return new Schema(fields, this.metadata);
    }
    assign(...args) {
        const other = args[0] instanceof Schema ? args[0] : Array.isArray(args[0]) ? new Schema(args[0]) : new Schema(args);
        const curFields = [
            ...this.fields
        ];
        const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);
        const newFields = other.fields.filter((f2)=>{
            const i = curFields.findIndex((f)=>f.name === f2.name);
            return ~i ? (curFields[i] = f2.clone({
                metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)
            })) && false : true;
        });
        const newDictionaries = generateDictionaryMap(newFields, new Map());
        return new Schema([
            ...curFields,
            ...newFields
        ], metadata, new Map([
            ...this.dictionaries,
            ...newDictionaries
        ]));
    }
}
exports.Schema = Schema;
// Add these here so they're picked up by the externs creator
// in the build, and closure-compiler doesn't minify them away
Schema.prototype.fields = null;
Schema.prototype.metadata = null;
Schema.prototype.dictionaries = null;
class Field {
    /** @nocollapse */ static new(...args) {
        let [name, type, nullable, metadata] = args;
        if (args[0] && typeof args[0] === 'object') {
            ({ name } = args[0]);
            type === undefined && (type = args[0].type);
            nullable === undefined && (nullable = args[0].nullable);
            metadata === undefined && (metadata = args[0].metadata);
        }
        return new Field(`${name}`, type, nullable, metadata);
    }
    constructor(name, type, nullable = false, metadata){
        this.name = name;
        this.type = type;
        this.nullable = nullable;
        this.metadata = metadata || new Map();
    }
    get typeId() {
        return this.type.typeId;
    }
    get [Symbol.toStringTag]() {
        return 'Field';
    }
    toString() {
        return `${this.name}: ${this.type}`;
    }
    clone(...args) {
        let [name, type, nullable, metadata] = args;
        !args[0] || typeof args[0] !== 'object' ? [name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];
        return Field.new(name, type, nullable, metadata);
    }
}
exports.Field = Field;
// Add these here so they're picked up by the externs creator
// in the build, and closure-compiler doesn't minify them away
Field.prototype.type = null;
Field.prototype.name = null;
Field.prototype.nullable = null;
Field.prototype.metadata = null;
/** @ignore */ function mergeMaps(m1, m2) {
    return new Map([
        ...m1 || new Map(),
        ...m2 || new Map()
    ]);
}
/** @ignore */ function generateDictionaryMap(fields, dictionaries = new Map()) {
    for(let i = -1, n = fields.length; ++i < n;){
        const field = fields[i];
        const type = field.type;
        if (type_js_1.DataType.isDictionary(type)) {
            if (!dictionaries.has(type.id)) {
                dictionaries.set(type.id, type.dictionary);
            } else if (dictionaries.get(type.id) !== type.dictionary) {
                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
            }
        }
        if (type.children && type.children.length > 0) {
            generateDictionaryMap(type.children, dictionaries);
        }
    }
    return dictionaries;
} //# sourceMappingURL=schema.js.map
}),
"[project]/node_modules/apache-arrow/ipc/metadata/file.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FileBlock = exports.Footer = void 0;
/* eslint-disable @typescript-eslint/naming-convention */ const block_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/block.js [app-ssr] (ecmascript)");
const footer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/footer.js [app-ssr] (ecmascript)");
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
var Builder = flatbuffers.Builder;
var ByteBuffer = flatbuffers.ByteBuffer;
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
const bigint_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bigint.js [app-ssr] (ecmascript)");
/** @ignore */ class Footer_ {
    /** @nocollapse */ static decode(buf) {
        buf = new ByteBuffer((0, buffer_js_1.toUint8Array)(buf));
        const footer = footer_js_1.Footer.getRootAsFooter(buf);
        const schema = schema_js_1.Schema.decode(footer.schema(), new Map(), footer.version());
        return new OffHeapFooter(schema, footer);
    }
    /** @nocollapse */ static encode(footer) {
        const b = new Builder();
        const schemaOffset = schema_js_1.Schema.encode(b, footer.schema);
        footer_js_1.Footer.startRecordBatchesVector(b, footer.numRecordBatches);
        for (const rb of [
            ...footer.recordBatches()
        ].slice().reverse()){
            FileBlock.encode(b, rb);
        }
        const recordBatchesOffset = b.endVector();
        footer_js_1.Footer.startDictionariesVector(b, footer.numDictionaries);
        for (const db of [
            ...footer.dictionaryBatches()
        ].slice().reverse()){
            FileBlock.encode(b, db);
        }
        const dictionaryBatchesOffset = b.endVector();
        footer_js_1.Footer.startFooter(b);
        footer_js_1.Footer.addSchema(b, schemaOffset);
        footer_js_1.Footer.addVersion(b, enum_js_1.MetadataVersion.V5);
        footer_js_1.Footer.addRecordBatches(b, recordBatchesOffset);
        footer_js_1.Footer.addDictionaries(b, dictionaryBatchesOffset);
        footer_js_1.Footer.finishFooterBuffer(b, footer_js_1.Footer.endFooter(b));
        return b.asUint8Array();
    }
    get numRecordBatches() {
        return this._recordBatches.length;
    }
    get numDictionaries() {
        return this._dictionaryBatches.length;
    }
    constructor(schema, version = enum_js_1.MetadataVersion.V5, recordBatches, dictionaryBatches){
        this.schema = schema;
        this.version = version;
        recordBatches && (this._recordBatches = recordBatches);
        dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
    }
    *recordBatches() {
        for(let block, i = -1, n = this.numRecordBatches; ++i < n;){
            if (block = this.getRecordBatch(i)) {
                yield block;
            }
        }
    }
    *dictionaryBatches() {
        for(let block, i = -1, n = this.numDictionaries; ++i < n;){
            if (block = this.getDictionaryBatch(i)) {
                yield block;
            }
        }
    }
    getRecordBatch(index) {
        return index >= 0 && index < this.numRecordBatches && this._recordBatches[index] || null;
    }
    getDictionaryBatch(index) {
        return index >= 0 && index < this.numDictionaries && this._dictionaryBatches[index] || null;
    }
}
exports.Footer = Footer_;
/** @ignore */ class OffHeapFooter extends Footer_ {
    get numRecordBatches() {
        return this._footer.recordBatchesLength();
    }
    get numDictionaries() {
        return this._footer.dictionariesLength();
    }
    constructor(schema, _footer){
        super(schema, _footer.version());
        this._footer = _footer;
    }
    getRecordBatch(index) {
        if (index >= 0 && index < this.numRecordBatches) {
            const fileBlock = this._footer.recordBatches(index);
            if (fileBlock) {
                return FileBlock.decode(fileBlock);
            }
        }
        return null;
    }
    getDictionaryBatch(index) {
        if (index >= 0 && index < this.numDictionaries) {
            const fileBlock = this._footer.dictionaries(index);
            if (fileBlock) {
                return FileBlock.decode(fileBlock);
            }
        }
        return null;
    }
}
/** @ignore */ class FileBlock {
    /** @nocollapse */ static decode(block) {
        return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
    }
    /** @nocollapse */ static encode(b, fileBlock) {
        const { metaDataLength } = fileBlock;
        const offset = BigInt(fileBlock.offset);
        const bodyLength = BigInt(fileBlock.bodyLength);
        return block_js_1.Block.createBlock(b, offset, metaDataLength, bodyLength);
    }
    constructor(metaDataLength, bodyLength, offset){
        this.metaDataLength = metaDataLength;
        this.offset = (0, bigint_js_1.bigIntToNumber)(offset);
        this.bodyLength = (0, bigint_js_1.bigIntToNumber)(bodyLength);
    }
}
exports.FileBlock = FileBlock; //# sourceMappingURL=file.js.map
}),
"[project]/node_modules/apache-arrow/io/interfaces.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AsyncQueue = exports.ReadableInterop = exports.ArrowJSON = exports.ITERATOR_DONE = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const adapters_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/adapters.js [app-ssr] (ecmascript)");
/** @ignore */ exports.ITERATOR_DONE = Object.freeze({
    done: true,
    value: void 0
});
/** @ignore */ class ArrowJSON {
    constructor(_json){
        this._json = _json;
    }
    get schema() {
        return this._json['schema'];
    }
    get batches() {
        return this._json['batches'] || [];
    }
    get dictionaries() {
        return this._json['dictionaries'] || [];
    }
}
exports.ArrowJSON = ArrowJSON;
/** @ignore */ class ReadableInterop {
    tee() {
        return this._getDOMStream().tee();
    }
    pipe(writable, options) {
        return this._getNodeStream().pipe(writable, options);
    }
    pipeTo(writable, options) {
        return this._getDOMStream().pipeTo(writable, options);
    }
    pipeThrough(duplex, options) {
        return this._getDOMStream().pipeThrough(duplex, options);
    }
    _getDOMStream() {
        return this._DOMStream || (this._DOMStream = this.toDOMStream());
    }
    _getNodeStream() {
        return this._nodeStream || (this._nodeStream = this.toNodeStream());
    }
}
exports.ReadableInterop = ReadableInterop;
/** @ignore */ class AsyncQueue extends ReadableInterop {
    constructor(){
        super();
        this._values = [];
        this.resolvers = [];
        this._closedPromise = new Promise((r)=>this._closedPromiseResolve = r);
    }
    get closed() {
        return this._closedPromise;
    }
    cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            yield this.return(reason);
        });
    }
    write(value) {
        if (this._ensureOpen()) {
            this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({
                done: false,
                value
            });
        }
    }
    abort(value) {
        if (this._closedPromiseResolve) {
            this.resolvers.length <= 0 ? this._error = {
                error: value
            } : this.resolvers.shift().reject({
                done: true,
                value
            });
        }
    }
    close() {
        if (this._closedPromiseResolve) {
            const { resolvers } = this;
            while(resolvers.length > 0){
                resolvers.shift().resolve(exports.ITERATOR_DONE);
            }
            this._closedPromiseResolve();
            this._closedPromiseResolve = undefined;
        }
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    toDOMStream(options) {
        return adapters_js_1.default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
    }
    toNodeStream(options) {
        return adapters_js_1.default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
    }
    throw(_) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            yield this.abort(_);
            return exports.ITERATOR_DONE;
        });
    }
    return(_) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            yield this.close();
            return exports.ITERATOR_DONE;
        });
    }
    read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            return (yield this.next(size, 'read')).value;
        });
    }
    peek(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            return (yield this.next(size, 'peek')).value;
        });
    }
    next(..._args) {
        if (this._values.length > 0) {
            return Promise.resolve({
                done: false,
                value: this._values.shift()
            });
        } else if (this._error) {
            return Promise.reject({
                done: true,
                value: this._error.error
            });
        } else if (!this._closedPromiseResolve) {
            return Promise.resolve(exports.ITERATOR_DONE);
        } else {
            return new Promise((resolve, reject)=>{
                this.resolvers.push({
                    resolve,
                    reject
                });
            });
        }
    }
    _ensureOpen() {
        if (this._closedPromiseResolve) {
            return true;
        }
        throw new Error(`AsyncQueue is closed`);
    }
}
exports.AsyncQueue = AsyncQueue; //# sourceMappingURL=interfaces.js.map
}),
"[project]/node_modules/apache-arrow/io/stream.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AsyncByteStream = exports.ByteStream = exports.AsyncByteQueue = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const adapters_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/adapters.js [app-ssr] (ecmascript)");
const utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/utf8.js [app-ssr] (ecmascript)");
const interfaces_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/interfaces.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
const compat_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/compat.js [app-ssr] (ecmascript)");
/** @ignore */ class AsyncByteQueue extends interfaces_js_1.AsyncQueue {
    write(value) {
        if ((value = (0, buffer_js_1.toUint8Array)(value)).byteLength > 0) {
            return super.write(value);
        }
    }
    toString(sync = false) {
        return sync ? (0, utf8_js_1.decodeUtf8)(this.toUint8Array(true)) : this.toUint8Array(false).then(utf8_js_1.decodeUtf8);
    }
    toUint8Array(sync = false) {
        return sync ? (0, buffer_js_1.joinUint8Arrays)(this._values)[0] : (()=>tslib_1.__awaiter(this, void 0, void 0, function*() {
                var _a, e_1, _b, _c;
                const buffers = [];
                let byteLength = 0;
                try {
                    for(var _d = true, _e = tslib_1.__asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true){
                        _c = _f.value;
                        _d = false;
                        const chunk = _c;
                        buffers.push(chunk);
                        byteLength += chunk.byteLength;
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
                return (0, buffer_js_1.joinUint8Arrays)(buffers, byteLength)[0];
            }))();
    }
}
exports.AsyncByteQueue = AsyncByteQueue;
/** @ignore */ class ByteStream {
    constructor(source){
        if (source) {
            this.source = new ByteStreamSource(adapters_js_1.default.fromIterable(source));
        }
    }
    [Symbol.iterator]() {
        return this;
    }
    next(value) {
        return this.source.next(value);
    }
    throw(value) {
        return this.source.throw(value);
    }
    return(value) {
        return this.source.return(value);
    }
    peek(size) {
        return this.source.peek(size);
    }
    read(size) {
        return this.source.read(size);
    }
}
exports.ByteStream = ByteStream;
/** @ignore */ class AsyncByteStream {
    constructor(source){
        if (source instanceof AsyncByteStream) {
            this.source = source.source;
        } else if (source instanceof AsyncByteQueue) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        } else if ((0, compat_js_1.isReadableNodeStream)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromNodeStream(source));
        } else if ((0, compat_js_1.isReadableDOMStream)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromDOMStream(source));
        } else if ((0, compat_js_1.isFetchResponse)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromDOMStream(source.body));
        } else if ((0, compat_js_1.isIterable)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromIterable(source));
        } else if ((0, compat_js_1.isPromise)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        } else if ((0, compat_js_1.isAsyncIterable)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        }
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    next(value) {
        return this.source.next(value);
    }
    throw(value) {
        return this.source.throw(value);
    }
    return(value) {
        return this.source.return(value);
    }
    get closed() {
        return this.source.closed;
    }
    cancel(reason) {
        return this.source.cancel(reason);
    }
    peek(size) {
        return this.source.peek(size);
    }
    read(size) {
        return this.source.read(size);
    }
}
exports.AsyncByteStream = AsyncByteStream;
/** @ignore */ class ByteStreamSource {
    constructor(source){
        this.source = source;
    }
    cancel(reason) {
        this.return(reason);
    }
    peek(size) {
        return this.next(size, 'peek').value;
    }
    read(size) {
        return this.next(size, 'read').value;
    }
    next(size, cmd = 'read') {
        return this.source.next({
            cmd,
            size
        });
    }
    throw(value) {
        return Object.create(this.source.throw && this.source.throw(value) || interfaces_js_1.ITERATOR_DONE);
    }
    return(value) {
        return Object.create(this.source.return && this.source.return(value) || interfaces_js_1.ITERATOR_DONE);
    }
}
/** @ignore */ class AsyncByteStreamSource {
    constructor(source){
        this.source = source;
        this._closedPromise = new Promise((r)=>this._closedPromiseResolve = r);
    }
    cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            yield this.return(reason);
        });
    }
    get closed() {
        return this._closedPromise;
    }
    read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            return (yield this.next(size, 'read')).value;
        });
    }
    peek(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            return (yield this.next(size, 'peek')).value;
        });
    }
    next(size_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function*(size, cmd = 'read') {
            return yield this.source.next({
                cmd,
                size
            });
        });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            const result = this.source.throw && (yield this.source.throw(value)) || interfaces_js_1.ITERATOR_DONE;
            this._closedPromiseResolve && this._closedPromiseResolve();
            this._closedPromiseResolve = undefined;
            return Object.create(result);
        });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            const result = this.source.return && (yield this.source.return(value)) || interfaces_js_1.ITERATOR_DONE;
            this._closedPromiseResolve && this._closedPromiseResolve();
            this._closedPromiseResolve = undefined;
            return Object.create(result);
        });
    }
} //# sourceMappingURL=stream.js.map
}),
"[project]/node_modules/apache-arrow/io/file.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AsyncRandomAccessFile = exports.RandomAccessFile = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const stream_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/stream.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
/** @ignore */ class RandomAccessFile extends stream_js_1.ByteStream {
    constructor(buffer, byteLength){
        super();
        this.position = 0;
        this.buffer = (0, buffer_js_1.toUint8Array)(buffer);
        this.size = byteLength === undefined ? this.buffer.byteLength : byteLength;
    }
    readInt32(position) {
        const { buffer, byteOffset } = this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
    }
    seek(position) {
        this.position = Math.min(position, this.size);
        return position < this.size;
    }
    read(nBytes) {
        const { buffer, size, position } = this;
        if (buffer && position < size) {
            if (typeof nBytes !== 'number') {
                nBytes = Number.POSITIVE_INFINITY;
            }
            this.position = Math.min(size, position + Math.min(size - position, nBytes));
            return buffer.subarray(position, this.position);
        }
        return null;
    }
    readAt(position, nBytes) {
        const buf = this.buffer;
        const end = Math.min(this.size, position + nBytes);
        return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);
    }
    close() {
        this.buffer && (this.buffer = null);
    }
    throw(value) {
        this.close();
        return {
            done: true,
            value
        };
    }
    return(value) {
        this.close();
        return {
            done: true,
            value
        };
    }
}
exports.RandomAccessFile = RandomAccessFile;
/** @ignore */ class AsyncRandomAccessFile extends stream_js_1.AsyncByteStream {
    constructor(file, byteLength){
        super();
        this.position = 0;
        this._handle = file;
        if (typeof byteLength === 'number') {
            this.size = byteLength;
        } else {
            this._pending = (()=>tslib_1.__awaiter(this, void 0, void 0, function*() {
                    this.size = (yield file.stat()).size;
                    delete this._pending;
                }))();
        }
    }
    readInt32(position) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            const { buffer, byteOffset } = yield this.readAt(position, 4);
            return new DataView(buffer, byteOffset).getInt32(0, true);
        });
    }
    seek(position) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            this._pending && (yield this._pending);
            this.position = Math.min(position, this.size);
            return position < this.size;
        });
    }
    read(nBytes) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            this._pending && (yield this._pending);
            const { _handle: file, size, position } = this;
            if (file && position < size) {
                if (typeof nBytes !== 'number') {
                    nBytes = Number.POSITIVE_INFINITY;
                }
                let pos = position, offset = 0, bytesRead = 0;
                const end = Math.min(size, pos + Math.min(size - pos, nBytes));
                const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
                while((pos += bytesRead) < end && (offset += bytesRead) < buffer.byteLength){
                    ({ bytesRead } = yield file.read(buffer, offset, buffer.byteLength - offset, pos));
                }
                return buffer;
            }
            return null;
        });
    }
    readAt(position, nBytes) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            this._pending && (yield this._pending);
            const { _handle: file, size } = this;
            if (file && position + nBytes < size) {
                const end = Math.min(size, position + nBytes);
                const buffer = new Uint8Array(end - position);
                return (yield file.read(buffer, 0, nBytes, position)).buffer;
            }
            return new Uint8Array(nBytes);
        });
    }
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            const f = this._handle;
            this._handle = null;
            f && (yield f.close());
        });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            yield this.close();
            return {
                done: true,
                value
            };
        });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            yield this.close();
            return {
                done: true,
                value
            };
        });
    }
}
exports.AsyncRandomAccessFile = AsyncRandomAccessFile; //# sourceMappingURL=file.js.map
}),
"[project]/node_modules/apache-arrow/util/int.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Int128 = exports.Int64 = exports.Uint64 = exports.BaseInt64 = void 0;
/** @ignore */ const carryBit16 = 1 << 16;
/** @ignore */ function intAsHex(value) {
    if (value < 0) {
        value = 0xFFFFFFFF + value + 1;
    }
    return `0x${value.toString(16)}`;
}
/** @ignore */ const kInt32DecimalDigits = 8;
/** @ignore */ const kPowersOfTen = [
    1,
    10,
    100,
    1000,
    10000,
    100000,
    1000000,
    10000000,
    100000000
];
/** @ignore */ class BaseInt64 {
    constructor(buffer){
        this.buffer = buffer;
    }
    high() {
        return this.buffer[1];
    }
    low() {
        return this.buffer[0];
    }
    _times(other) {
        // Break the left and right numbers into 16 bit chunks
        // so that we can multiply them without overflow.
        const L = new Uint32Array([
            this.buffer[1] >>> 16,
            this.buffer[1] & 0xFFFF,
            this.buffer[0] >>> 16,
            this.buffer[0] & 0xFFFF
        ]);
        const R = new Uint32Array([
            other.buffer[1] >>> 16,
            other.buffer[1] & 0xFFFF,
            other.buffer[0] >>> 16,
            other.buffer[0] & 0xFFFF
        ]);
        let product = L[3] * R[3];
        this.buffer[0] = product & 0xFFFF;
        let sum = product >>> 16;
        product = L[2] * R[3];
        sum += product;
        product = L[3] * R[2] >>> 0;
        sum += product;
        this.buffer[0] += sum << 16;
        this.buffer[1] = sum >>> 0 < product ? carryBit16 : 0;
        this.buffer[1] += sum >>> 16;
        this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
        this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;
        return this;
    }
    _plus(other) {
        const sum = this.buffer[0] + other.buffer[0] >>> 0;
        this.buffer[1] += other.buffer[1];
        if (sum < this.buffer[0] >>> 0) {
            ++this.buffer[1];
        }
        this.buffer[0] = sum;
    }
    lessThan(other) {
        return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
    }
    equals(other) {
        return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
    }
    greaterThan(other) {
        return other.lessThan(this);
    }
    hex() {
        return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
}
exports.BaseInt64 = BaseInt64;
/** @ignore */ class Uint64 extends BaseInt64 {
    times(other) {
        this._times(other);
        return this;
    }
    plus(other) {
        this._plus(other);
        return this;
    }
    /** @nocollapse */ static from(val, out_buffer = new Uint32Array(2)) {
        return Uint64.fromString(typeof val === 'string' ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */ static fromNumber(num, out_buffer = new Uint32Array(2)) {
        // Always parse numbers as strings - pulling out high and low bits
        // directly seems to lose precision sometimes
        // For example:
        //     > -4613034156400212000 >>> 0
        //     721782784
        // The correct lower 32-bits are 721782752
        return Uint64.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */ static fromString(str, out_buffer = new Uint32Array(2)) {
        const length = str.length;
        const out = new Uint64(out_buffer);
        for(let posn = 0; posn < length;){
            const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
            const chunk = new Uint64(new Uint32Array([
                Number.parseInt(str.slice(posn, posn + group), 10),
                0
            ]));
            const multiple = new Uint64(new Uint32Array([
                kPowersOfTen[group],
                0
            ]));
            out.times(multiple);
            out.plus(chunk);
            posn += group;
        }
        return out;
    }
    /** @nocollapse */ static convertArray(values) {
        const data = new Uint32Array(values.length * 2);
        for(let i = -1, n = values.length; ++i < n;){
            Uint64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
        }
        return data;
    }
    /** @nocollapse */ static multiply(left, right) {
        const rtrn = new Uint64(new Uint32Array(left.buffer));
        return rtrn.times(right);
    }
    /** @nocollapse */ static add(left, right) {
        const rtrn = new Uint64(new Uint32Array(left.buffer));
        return rtrn.plus(right);
    }
}
exports.Uint64 = Uint64;
/** @ignore */ class Int64 extends BaseInt64 {
    negate() {
        this.buffer[0] = ~this.buffer[0] + 1;
        this.buffer[1] = ~this.buffer[1];
        if (this.buffer[0] == 0) {
            ++this.buffer[1];
        }
        return this;
    }
    times(other) {
        this._times(other);
        return this;
    }
    plus(other) {
        this._plus(other);
        return this;
    }
    lessThan(other) {
        // force high bytes to be signed
        // eslint-disable-next-line unicorn/prefer-math-trunc
        const this_high = this.buffer[1] << 0;
        // eslint-disable-next-line unicorn/prefer-math-trunc
        const other_high = other.buffer[1] << 0;
        return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
    }
    /** @nocollapse */ static from(val, out_buffer = new Uint32Array(2)) {
        return Int64.fromString(typeof val === 'string' ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */ static fromNumber(num, out_buffer = new Uint32Array(2)) {
        // Always parse numbers as strings - pulling out high and low bits
        // directly seems to lose precision sometimes
        // For example:
        //     > -4613034156400212000 >>> 0
        //     721782784
        // The correct lower 32-bits are 721782752
        return Int64.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */ static fromString(str, out_buffer = new Uint32Array(2)) {
        // TODO: Assert that out_buffer is 0 and length = 2
        const negate = str.startsWith('-');
        const length = str.length;
        const out = new Int64(out_buffer);
        for(let posn = negate ? 1 : 0; posn < length;){
            const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
            const chunk = new Int64(new Uint32Array([
                Number.parseInt(str.slice(posn, posn + group), 10),
                0
            ]));
            const multiple = new Int64(new Uint32Array([
                kPowersOfTen[group],
                0
            ]));
            out.times(multiple);
            out.plus(chunk);
            posn += group;
        }
        return negate ? out.negate() : out;
    }
    /** @nocollapse */ static convertArray(values) {
        const data = new Uint32Array(values.length * 2);
        for(let i = -1, n = values.length; ++i < n;){
            Int64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
        }
        return data;
    }
    /** @nocollapse */ static multiply(left, right) {
        const rtrn = new Int64(new Uint32Array(left.buffer));
        return rtrn.times(right);
    }
    /** @nocollapse */ static add(left, right) {
        const rtrn = new Int64(new Uint32Array(left.buffer));
        return rtrn.plus(right);
    }
}
exports.Int64 = Int64;
/** @ignore */ class Int128 {
    constructor(buffer){
        this.buffer = buffer;
    // buffer[3] MSB (high)
    // buffer[2]
    // buffer[1]
    // buffer[0] LSB (low)
    }
    high() {
        return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
    }
    low() {
        return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
    }
    negate() {
        this.buffer[0] = ~this.buffer[0] + 1;
        this.buffer[1] = ~this.buffer[1];
        this.buffer[2] = ~this.buffer[2];
        this.buffer[3] = ~this.buffer[3];
        if (this.buffer[0] == 0) {
            ++this.buffer[1];
        }
        if (this.buffer[1] == 0) {
            ++this.buffer[2];
        }
        if (this.buffer[2] == 0) {
            ++this.buffer[3];
        }
        return this;
    }
    times(other) {
        // Break the left and right numbers into 32 bit chunks
        // so that we can multiply them without overflow.
        const L0 = new Uint64(new Uint32Array([
            this.buffer[3],
            0
        ]));
        const L1 = new Uint64(new Uint32Array([
            this.buffer[2],
            0
        ]));
        const L2 = new Uint64(new Uint32Array([
            this.buffer[1],
            0
        ]));
        const L3 = new Uint64(new Uint32Array([
            this.buffer[0],
            0
        ]));
        const R0 = new Uint64(new Uint32Array([
            other.buffer[3],
            0
        ]));
        const R1 = new Uint64(new Uint32Array([
            other.buffer[2],
            0
        ]));
        const R2 = new Uint64(new Uint32Array([
            other.buffer[1],
            0
        ]));
        const R3 = new Uint64(new Uint32Array([
            other.buffer[0],
            0
        ]));
        let product = Uint64.multiply(L3, R3);
        this.buffer[0] = product.low();
        const sum = new Uint64(new Uint32Array([
            product.high(),
            0
        ]));
        product = Uint64.multiply(L2, R3);
        sum.plus(product);
        product = Uint64.multiply(L3, R2);
        sum.plus(product);
        this.buffer[1] = sum.low();
        this.buffer[3] = sum.lessThan(product) ? 1 : 0;
        this.buffer[2] = sum.high();
        const high = new Uint64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
        high.plus(Uint64.multiply(L1, R3)).plus(Uint64.multiply(L2, R2)).plus(Uint64.multiply(L3, R1));
        this.buffer[3] += Uint64.multiply(L0, R3).plus(Uint64.multiply(L1, R2)).plus(Uint64.multiply(L2, R1)).plus(Uint64.multiply(L3, R0)).low();
        return this;
    }
    plus(other) {
        const sums = new Uint32Array(4);
        sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
        sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
        sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
        sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
        if (sums[0] < this.buffer[0] >>> 0) {
            ++sums[1];
        }
        if (sums[1] < this.buffer[1] >>> 0) {
            ++sums[2];
        }
        if (sums[2] < this.buffer[2] >>> 0) {
            ++sums[3];
        }
        this.buffer[3] = sums[3];
        this.buffer[2] = sums[2];
        this.buffer[1] = sums[1];
        this.buffer[0] = sums[0];
        return this;
    }
    hex() {
        return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
    /** @nocollapse */ static multiply(left, right) {
        const rtrn = new Int128(new Uint32Array(left.buffer));
        return rtrn.times(right);
    }
    /** @nocollapse */ static add(left, right) {
        const rtrn = new Int128(new Uint32Array(left.buffer));
        return rtrn.plus(right);
    }
    /** @nocollapse */ static from(val, out_buffer = new Uint32Array(4)) {
        return Int128.fromString(typeof val === 'string' ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */ static fromNumber(num, out_buffer = new Uint32Array(4)) {
        // Always parse numbers as strings - pulling out high and low bits
        // directly seems to lose precision sometimes
        // For example:
        //     > -4613034156400212000 >>> 0
        //     721782784
        // The correct lower 32-bits are 721782752
        return Int128.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */ static fromString(str, out_buffer = new Uint32Array(4)) {
        // TODO: Assert that out_buffer is 0 and length = 4
        const negate = str.startsWith('-');
        const length = str.length;
        const out = new Int128(out_buffer);
        for(let posn = negate ? 1 : 0; posn < length;){
            const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
            const chunk = new Int128(new Uint32Array([
                Number.parseInt(str.slice(posn, posn + group), 10),
                0,
                0,
                0
            ]));
            const multiple = new Int128(new Uint32Array([
                kPowersOfTen[group],
                0,
                0,
                0
            ]));
            out.times(multiple);
            out.plus(chunk);
            posn += group;
        }
        return negate ? out.negate() : out;
    }
    /** @nocollapse */ static convertArray(values) {
        // TODO: Distinguish between string and number at compile-time
        const data = new Uint32Array(values.length * 4);
        for(let i = -1, n = values.length; ++i < n;){
            Int128.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
        }
        return data;
    }
}
exports.Int128 = Int128; //# sourceMappingURL=int.js.map
}),
"[project]/node_modules/apache-arrow/visitor/vectorloader.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JSONVectorLoader = exports.VectorLoader = void 0;
const data_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/data.js [app-ssr] (ecmascript)");
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
const bit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bit.js [app-ssr] (ecmascript)");
const utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/utf8.js [app-ssr] (ecmascript)");
const int_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/int.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
/** @ignore */ class VectorLoader extends visitor_js_1.Visitor {
    constructor(bytes, nodes, buffers, dictionaries, metadataVersion = enum_js_1.MetadataVersion.V5){
        super();
        this.nodesIndex = -1;
        this.buffersIndex = -1;
        this.bytes = bytes;
        this.nodes = nodes;
        this.buffers = buffers;
        this.dictionaries = dictionaries;
        this.metadataVersion = metadataVersion;
    }
    visit(node) {
        return super.visit(node instanceof schema_js_1.Field ? node.type : node);
    }
    visitNull(type, { length } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length
        });
    }
    visitBool(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            data: this.readData(type)
        });
    }
    visitInt(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            data: this.readData(type)
        });
    }
    visitFloat(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            data: this.readData(type)
        });
    }
    visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            valueOffsets: this.readOffsets(type),
            data: this.readData(type)
        });
    }
    visitLargeUtf8(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            valueOffsets: this.readOffsets(type),
            data: this.readData(type)
        });
    }
    visitBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            valueOffsets: this.readOffsets(type),
            data: this.readData(type)
        });
    }
    visitLargeBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            valueOffsets: this.readOffsets(type),
            data: this.readData(type)
        });
    }
    visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            data: this.readData(type)
        });
    }
    visitDate(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            data: this.readData(type)
        });
    }
    visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            data: this.readData(type)
        });
    }
    visitTime(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            data: this.readData(type)
        });
    }
    visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            data: this.readData(type)
        });
    }
    visitList(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            valueOffsets: this.readOffsets(type),
            'child': this.visit(type.children[0])
        });
    }
    visitStruct(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            children: this.visitMany(type.children)
        });
    }
    visitUnion(type, { length, nullCount } = this.nextFieldNode()) {
        if (this.metadataVersion < enum_js_1.MetadataVersion.V5) {
            this.readNullBitmap(type, nullCount);
        }
        return type.mode === enum_js_1.UnionMode.Sparse ? this.visitSparseUnion(type, {
            length,
            nullCount
        }) : this.visitDenseUnion(type, {
            length,
            nullCount
        });
    }
    visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            typeIds: this.readTypeIds(type),
            valueOffsets: this.readOffsets(type),
            children: this.visitMany(type.children)
        });
    }
    visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            typeIds: this.readTypeIds(type),
            children: this.visitMany(type.children)
        });
    }
    visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            data: this.readData(type.indices),
            dictionary: this.readDictionary(type)
        });
    }
    visitInterval(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            data: this.readData(type)
        });
    }
    visitDuration(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            data: this.readData(type)
        });
    }
    visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            'child': this.visit(type.children[0])
        });
    }
    visitMap(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({
            type,
            length,
            nullCount,
            nullBitmap: this.readNullBitmap(type, nullCount),
            valueOffsets: this.readOffsets(type),
            'child': this.visit(type.children[0])
        });
    }
    nextFieldNode() {
        return this.nodes[++this.nodesIndex];
    }
    nextBufferRange() {
        return this.buffers[++this.buffersIndex];
    }
    readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {
        return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);
    }
    readOffsets(type, buffer) {
        return this.readData(type, buffer);
    }
    readTypeIds(type, buffer) {
        return this.readData(type, buffer);
    }
    readData(_type, { length, offset } = this.nextBufferRange()) {
        return this.bytes.subarray(offset, offset + length);
    }
    readDictionary(type) {
        return this.dictionaries.get(type.id);
    }
}
exports.VectorLoader = VectorLoader;
/** @ignore */ class JSONVectorLoader extends VectorLoader {
    constructor(sources, nodes, buffers, dictionaries, metadataVersion){
        super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);
        this.sources = sources;
    }
    readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
        return nullCount <= 0 ? new Uint8Array(0) : (0, bit_js_1.packBools)(this.sources[offset]);
    }
    readOffsets(_type, { offset } = this.nextBufferRange()) {
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(_type.OffsetArrayType, this.sources[offset]));
    }
    readTypeIds(type, { offset } = this.nextBufferRange()) {
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(type.ArrayType, this.sources[offset]));
    }
    readData(type, { offset } = this.nextBufferRange()) {
        const { sources } = this;
        if (type_js_1.DataType.isTimestamp(type)) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        } else if ((type_js_1.DataType.isInt(type) || type_js_1.DataType.isTime(type)) && type.bitWidth === 64 || type_js_1.DataType.isDuration(type)) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        } else if (type_js_1.DataType.isDate(type) && type.unit === enum_js_1.DateUnit.MILLISECOND) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        } else if (type_js_1.DataType.isDecimal(type)) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int128.convertArray(sources[offset]));
        } else if (type_js_1.DataType.isBinary(type) || type_js_1.DataType.isLargeBinary(type) || type_js_1.DataType.isFixedSizeBinary(type)) {
            return binaryDataFromJSON(sources[offset]);
        } else if (type_js_1.DataType.isBool(type)) {
            return (0, bit_js_1.packBools)(sources[offset]);
        } else if (type_js_1.DataType.isUtf8(type) || type_js_1.DataType.isLargeUtf8(type)) {
            return (0, utf8_js_1.encodeUtf8)(sources[offset].join(''));
        }
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(type.ArrayType, sources[offset].map((x)=>+x)));
    }
}
exports.JSONVectorLoader = JSONVectorLoader;
/** @ignore */ function binaryDataFromJSON(values) {
    // "DATA": ["49BC7D5B6C47D2","3F5FB6D9322026"]
    // There are definitely more efficient ways to do this... but it gets the
    // job done.
    const joined = values.join('');
    const data = new Uint8Array(joined.length / 2);
    for(let i = 0; i < joined.length; i += 2){
        data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);
    }
    return data;
} //# sourceMappingURL=vectorloader.js.map
}),
"[project]/node_modules/apache-arrow/builder/binary.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BinaryBuilder = void 0;
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/buffer.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const buffer_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
/** @ignore */ class BinaryBuilder extends builder_js_1.VariableWidthBuilder {
    constructor(opts){
        super(opts);
        this._values = new buffer_js_1.BufferBuilder(Uint8Array);
    }
    get byteLength() {
        let size = this._pendingLength + this.length * 4;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
    }
    setValue(index, value) {
        return super.setValue(index, (0, buffer_js_2.toUint8Array)(value));
    }
    _flushPending(pending, pendingLength) {
        const offsets = this._offsets;
        const data = this._values.reserve(pendingLength).buffer;
        let offset = 0;
        for (const [index, value] of pending){
            if (value === undefined) {
                offsets.set(index, 0);
            } else {
                const length = value.length;
                data.set(value, offset);
                offsets.set(index, length);
                offset += length;
            }
        }
    }
}
exports.BinaryBuilder = BinaryBuilder; //# sourceMappingURL=binary.js.map
}),
"[project]/node_modules/apache-arrow/builder/largebinary.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LargeBinaryBuilder = void 0;
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
const buffer_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/buffer.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
/** @ignore */ class LargeBinaryBuilder extends builder_js_1.VariableWidthBuilder {
    constructor(opts){
        super(opts);
        this._values = new buffer_js_2.BufferBuilder(Uint8Array);
    }
    get byteLength() {
        let size = this._pendingLength + this.length * 4;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
    }
    setValue(index, value) {
        return super.setValue(index, (0, buffer_js_1.toUint8Array)(value));
    }
    _flushPending(pending, pendingLength) {
        const offsets = this._offsets;
        const data = this._values.reserve(pendingLength).buffer;
        let offset = 0;
        for (const [index, value] of pending){
            if (value === undefined) {
                offsets.set(index, BigInt(0));
            } else {
                const length = value.length;
                data.set(value, offset);
                offsets.set(index, BigInt(length));
                offset += length;
            }
        }
    }
}
exports.LargeBinaryBuilder = LargeBinaryBuilder; //# sourceMappingURL=largebinary.js.map
}),
"[project]/node_modules/apache-arrow/builder/bool.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BoolBuilder = void 0;
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/buffer.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
/** @ignore */ class BoolBuilder extends builder_js_1.Builder {
    constructor(options){
        super(options);
        this._values = new buffer_js_1.BitmapBufferBuilder();
    }
    setValue(index, value) {
        this._values.set(index, +value);
    }
}
exports.BoolBuilder = BoolBuilder; //# sourceMappingURL=bool.js.map
}),
"[project]/node_modules/apache-arrow/builder/date.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DateMillisecondBuilder = exports.DateDayBuilder = exports.DateBuilder = void 0;
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const set_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)");
/** @ignore */ class DateBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.DateBuilder = DateBuilder;
DateBuilder.prototype._setValue = set_js_1.setDate;
/** @ignore */ class DateDayBuilder extends DateBuilder {
}
exports.DateDayBuilder = DateDayBuilder;
DateDayBuilder.prototype._setValue = set_js_1.setDateDay;
/** @ignore */ class DateMillisecondBuilder extends DateBuilder {
}
exports.DateMillisecondBuilder = DateMillisecondBuilder;
DateMillisecondBuilder.prototype._setValue = set_js_1.setDateMillisecond; //# sourceMappingURL=date.js.map
}),
"[project]/node_modules/apache-arrow/builder/decimal.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DecimalBuilder = void 0;
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const set_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)");
/** @ignore */ class DecimalBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.DecimalBuilder = DecimalBuilder;
DecimalBuilder.prototype._setValue = set_js_1.setDecimal; //# sourceMappingURL=decimal.js.map
}),
"[project]/node_modules/apache-arrow/builder/dictionary.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DictionaryBuilder = void 0;
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const factories_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/factories.js [app-ssr] (ecmascript)");
/** @ignore */ class DictionaryBuilder extends builder_js_1.Builder {
    constructor({ 'type': type, 'nullValues': nulls, 'dictionaryHashFunction': hashFn }){
        super({
            type: new type_js_1.Dictionary(type.dictionary, type.indices, type.id, type.isOrdered)
        });
        this._nulls = null;
        this._dictionaryOffset = 0;
        this._keysToIndices = Object.create(null);
        this.indices = (0, factories_js_1.makeBuilder)({
            'type': this.type.indices,
            'nullValues': nulls
        });
        this.dictionary = (0, factories_js_1.makeBuilder)({
            'type': this.type.dictionary,
            'nullValues': null
        });
        if (typeof hashFn === 'function') {
            this.valueToKey = hashFn;
        }
    }
    get values() {
        return this.indices.values;
    }
    get nullCount() {
        return this.indices.nullCount;
    }
    get nullBitmap() {
        return this.indices.nullBitmap;
    }
    get byteLength() {
        return this.indices.byteLength + this.dictionary.byteLength;
    }
    get reservedLength() {
        return this.indices.reservedLength + this.dictionary.reservedLength;
    }
    get reservedByteLength() {
        return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
    }
    isValid(value) {
        return this.indices.isValid(value);
    }
    setValid(index, valid) {
        const indices = this.indices;
        valid = indices.setValid(index, valid);
        this.length = indices.length;
        return valid;
    }
    setValue(index, value) {
        const keysToIndices = this._keysToIndices;
        const key = this.valueToKey(value);
        let idx = keysToIndices[key];
        if (idx === undefined) {
            keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
        }
        return this.indices.setValue(index, idx);
    }
    flush() {
        const type = this.type;
        const prev = this._dictionary;
        const curr = this.dictionary.toVector();
        const data = this.indices.flush().clone(type);
        data.dictionary = prev ? prev.concat(curr) : curr;
        this.finished || (this._dictionaryOffset += curr.length);
        this._dictionary = data.dictionary;
        this.clear();
        return data;
    }
    finish() {
        this.indices.finish();
        this.dictionary.finish();
        this._dictionaryOffset = 0;
        this._keysToIndices = Object.create(null);
        return super.finish();
    }
    clear() {
        this.indices.clear();
        this.dictionary.clear();
        return super.clear();
    }
    valueToKey(val) {
        return typeof val === 'string' ? val : `${val}`;
    }
}
exports.DictionaryBuilder = DictionaryBuilder; //# sourceMappingURL=dictionary.js.map
}),
"[project]/node_modules/apache-arrow/builder/fixedsizebinary.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FixedSizeBinaryBuilder = void 0;
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const set_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)");
/** @ignore */ class FixedSizeBinaryBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.FixedSizeBinaryBuilder = FixedSizeBinaryBuilder;
FixedSizeBinaryBuilder.prototype._setValue = set_js_1.setFixedSizeBinary; //# sourceMappingURL=fixedsizebinary.js.map
}),
"[project]/node_modules/apache-arrow/builder/fixedsizelist.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FixedSizeListBuilder = void 0;
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
/** @ignore */ class FixedSizeListBuilder extends builder_js_1.Builder {
    setValue(index, value) {
        const [child] = this.children;
        const start = index * this.stride;
        for(let i = -1, n = value.length; ++i < n;){
            child.set(start + i, value[i]);
        }
    }
    addChild(child, name = '0') {
        if (this.numChildren > 0) {
            throw new Error('FixedSizeListBuilder can only have one child.');
        }
        const childIndex = this.children.push(child);
        this.type = new type_js_1.FixedSizeList(this.type.listSize, new schema_js_1.Field(name, child.type, true));
        return childIndex;
    }
}
exports.FixedSizeListBuilder = FixedSizeListBuilder; //# sourceMappingURL=fixedsizelist.js.map
}),
"[project]/node_modules/apache-arrow/builder/float.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Float64Builder = exports.Float32Builder = exports.Float16Builder = exports.FloatBuilder = void 0;
const math_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/math.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
/** @ignore */ class FloatBuilder extends builder_js_1.FixedWidthBuilder {
    setValue(index, value) {
        this._values.set(index, value);
    }
}
exports.FloatBuilder = FloatBuilder;
/** @ignore */ class Float16Builder extends FloatBuilder {
    setValue(index, value) {
        // convert JS float64 to a uint16
        super.setValue(index, (0, math_js_1.float64ToUint16)(value));
    }
}
exports.Float16Builder = Float16Builder;
/** @ignore */ class Float32Builder extends FloatBuilder {
}
exports.Float32Builder = Float32Builder;
/** @ignore */ class Float64Builder extends FloatBuilder {
}
exports.Float64Builder = Float64Builder; //# sourceMappingURL=float.js.map
}),
"[project]/node_modules/apache-arrow/builder/interval.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IntervalYearMonthBuilder = exports.IntervalDayTimeBuilder = exports.IntervalBuilder = void 0;
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const set_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)");
/** @ignore */ class IntervalBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.IntervalBuilder = IntervalBuilder;
IntervalBuilder.prototype._setValue = set_js_1.setIntervalValue;
/** @ignore */ class IntervalDayTimeBuilder extends IntervalBuilder {
}
exports.IntervalDayTimeBuilder = IntervalDayTimeBuilder;
IntervalDayTimeBuilder.prototype._setValue = set_js_1.setIntervalDayTime;
/** @ignore */ class IntervalYearMonthBuilder extends IntervalBuilder {
}
exports.IntervalYearMonthBuilder = IntervalYearMonthBuilder;
IntervalYearMonthBuilder.prototype._setValue = set_js_1.setIntervalYearMonth; //# sourceMappingURL=interval.js.map
}),
"[project]/node_modules/apache-arrow/builder/duration.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DurationNanosecondBuilder = exports.DurationMicrosecondBuilder = exports.DurationMillisecondBuilder = exports.DurationSecondBuilder = exports.DurationBuilder = void 0;
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const set_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)");
/** @ignore */ class DurationBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.DurationBuilder = DurationBuilder;
DurationBuilder.prototype._setValue = set_js_1.setDuration;
/** @ignore */ class DurationSecondBuilder extends DurationBuilder {
}
exports.DurationSecondBuilder = DurationSecondBuilder;
DurationSecondBuilder.prototype._setValue = set_js_1.setDurationSecond;
/** @ignore */ class DurationMillisecondBuilder extends DurationBuilder {
}
exports.DurationMillisecondBuilder = DurationMillisecondBuilder;
DurationMillisecondBuilder.prototype._setValue = set_js_1.setDurationMillisecond;
/** @ignore */ class DurationMicrosecondBuilder extends DurationBuilder {
}
exports.DurationMicrosecondBuilder = DurationMicrosecondBuilder;
DurationMicrosecondBuilder.prototype._setValue = set_js_1.setDurationMicrosecond;
/** @ignore */ class DurationNanosecondBuilder extends DurationBuilder {
}
exports.DurationNanosecondBuilder = DurationNanosecondBuilder;
DurationNanosecondBuilder.prototype._setValue = set_js_1.setDurationNanosecond; //# sourceMappingURL=duration.js.map
}),
"[project]/node_modules/apache-arrow/builder/int.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Uint64Builder = exports.Uint32Builder = exports.Uint16Builder = exports.Uint8Builder = exports.Int64Builder = exports.Int32Builder = exports.Int16Builder = exports.Int8Builder = exports.IntBuilder = void 0;
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
/** @ignore */ class IntBuilder extends builder_js_1.FixedWidthBuilder {
    setValue(index, value) {
        this._values.set(index, value);
    }
}
exports.IntBuilder = IntBuilder;
/** @ignore */ class Int8Builder extends IntBuilder {
}
exports.Int8Builder = Int8Builder;
/** @ignore */ class Int16Builder extends IntBuilder {
}
exports.Int16Builder = Int16Builder;
/** @ignore */ class Int32Builder extends IntBuilder {
}
exports.Int32Builder = Int32Builder;
/** @ignore */ class Int64Builder extends IntBuilder {
}
exports.Int64Builder = Int64Builder;
/** @ignore */ class Uint8Builder extends IntBuilder {
}
exports.Uint8Builder = Uint8Builder;
/** @ignore */ class Uint16Builder extends IntBuilder {
}
exports.Uint16Builder = Uint16Builder;
/** @ignore */ class Uint32Builder extends IntBuilder {
}
exports.Uint32Builder = Uint32Builder;
/** @ignore */ class Uint64Builder extends IntBuilder {
}
exports.Uint64Builder = Uint64Builder; //# sourceMappingURL=int.js.map
}),
"[project]/node_modules/apache-arrow/builder/list.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ListBuilder = void 0;
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/buffer.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
/** @ignore */ class ListBuilder extends builder_js_1.VariableWidthBuilder {
    constructor(opts){
        super(opts);
        this._offsets = new buffer_js_1.OffsetsBufferBuilder(opts.type);
    }
    addChild(child, name = '0') {
        if (this.numChildren > 0) {
            throw new Error('ListBuilder can only have one child.');
        }
        this.children[this.numChildren] = child;
        this.type = new type_js_1.List(new schema_js_1.Field(name, child.type, true));
        return this.numChildren - 1;
    }
    _flushPending(pending) {
        const offsets = this._offsets;
        const [child] = this.children;
        for (const [index, value] of pending){
            if (typeof value === 'undefined') {
                offsets.set(index, 0);
            } else {
                const v = value;
                const n = v.length;
                const start = offsets.set(index, n).buffer[index];
                for(let i = -1; ++i < n;){
                    child.set(start + i, v[i]);
                }
            }
        }
    }
}
exports.ListBuilder = ListBuilder; //# sourceMappingURL=list.js.map
}),
"[project]/node_modules/apache-arrow/builder/map.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MapBuilder = void 0;
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
/** @ignore */ class MapBuilder extends builder_js_1.VariableWidthBuilder {
    set(index, value) {
        return super.set(index, value);
    }
    setValue(index, value) {
        const row = value instanceof Map ? value : new Map(Object.entries(value));
        const pending = this._pending || (this._pending = new Map());
        const current = pending.get(index);
        current && (this._pendingLength -= current.size);
        this._pendingLength += row.size;
        pending.set(index, row);
    }
    addChild(child, name = `${this.numChildren}`) {
        if (this.numChildren > 0) {
            throw new Error('ListBuilder can only have one child.');
        }
        this.children[this.numChildren] = child;
        this.type = new type_js_1.Map_(new schema_js_1.Field(name, child.type, true), this.type.keysSorted);
        return this.numChildren - 1;
    }
    _flushPending(pending) {
        const offsets = this._offsets;
        const [child] = this.children;
        for (const [index, value] of pending){
            if (value === undefined) {
                offsets.set(index, 0);
            } else {
                let { [index]: idx, [index + 1]: end } = offsets.set(index, value.size).buffer;
                for (const val of value.entries()){
                    child.set(idx, val);
                    if (++idx >= end) break;
                }
            }
        }
    }
}
exports.MapBuilder = MapBuilder; //# sourceMappingURL=map.js.map
}),
"[project]/node_modules/apache-arrow/builder/null.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NullBuilder = void 0;
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
/** @ignore */ class NullBuilder extends builder_js_1.Builder {
    // @ts-ignore
    setValue(index, value) {}
    setValid(index, valid) {
        this.length = Math.max(index + 1, this.length);
        return valid;
    }
}
exports.NullBuilder = NullBuilder; //# sourceMappingURL=null.js.map
}),
"[project]/node_modules/apache-arrow/builder/struct.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StructBuilder = void 0;
/* eslint-disable unicorn/no-array-for-each */ const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
/** @ignore */ class StructBuilder extends builder_js_1.Builder {
    setValue(index, value) {
        const { children, type } = this;
        switch(Array.isArray(value) || value.constructor){
            case true:
                return type.children.forEach((_, i)=>children[i].set(index, value[i]));
            case Map:
                return type.children.forEach((f, i)=>children[i].set(index, value.get(f.name)));
            default:
                return type.children.forEach((f, i)=>children[i].set(index, value[f.name]));
        }
    }
    /** @inheritdoc */ setValid(index, valid) {
        if (!super.setValid(index, valid)) {
            this.children.forEach((child)=>child.setValid(index, valid));
        }
        return valid;
    }
    addChild(child, name = `${this.numChildren}`) {
        const childIndex = this.children.push(child);
        this.type = new type_js_1.Struct([
            ...this.type.children,
            new schema_js_1.Field(name, child.type, true)
        ]);
        return childIndex;
    }
}
exports.StructBuilder = StructBuilder; //# sourceMappingURL=struct.js.map
}),
"[project]/node_modules/apache-arrow/builder/timestamp.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TimestampNanosecondBuilder = exports.TimestampMicrosecondBuilder = exports.TimestampMillisecondBuilder = exports.TimestampSecondBuilder = exports.TimestampBuilder = void 0;
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const set_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)");
/** @ignore */ class TimestampBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.TimestampBuilder = TimestampBuilder;
TimestampBuilder.prototype._setValue = set_js_1.setTimestamp;
/** @ignore */ class TimestampSecondBuilder extends TimestampBuilder {
}
exports.TimestampSecondBuilder = TimestampSecondBuilder;
TimestampSecondBuilder.prototype._setValue = set_js_1.setTimestampSecond;
/** @ignore */ class TimestampMillisecondBuilder extends TimestampBuilder {
}
exports.TimestampMillisecondBuilder = TimestampMillisecondBuilder;
TimestampMillisecondBuilder.prototype._setValue = set_js_1.setTimestampMillisecond;
/** @ignore */ class TimestampMicrosecondBuilder extends TimestampBuilder {
}
exports.TimestampMicrosecondBuilder = TimestampMicrosecondBuilder;
TimestampMicrosecondBuilder.prototype._setValue = set_js_1.setTimestampMicrosecond;
/** @ignore */ class TimestampNanosecondBuilder extends TimestampBuilder {
}
exports.TimestampNanosecondBuilder = TimestampNanosecondBuilder;
TimestampNanosecondBuilder.prototype._setValue = set_js_1.setTimestampNanosecond; //# sourceMappingURL=timestamp.js.map
}),
"[project]/node_modules/apache-arrow/builder/time.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TimeNanosecondBuilder = exports.TimeMicrosecondBuilder = exports.TimeMillisecondBuilder = exports.TimeSecondBuilder = exports.TimeBuilder = void 0;
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const set_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)");
/** @ignore */ class TimeBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.TimeBuilder = TimeBuilder;
TimeBuilder.prototype._setValue = set_js_1.setTime;
/** @ignore */ class TimeSecondBuilder extends TimeBuilder {
}
exports.TimeSecondBuilder = TimeSecondBuilder;
TimeSecondBuilder.prototype._setValue = set_js_1.setTimeSecond;
/** @ignore */ class TimeMillisecondBuilder extends TimeBuilder {
}
exports.TimeMillisecondBuilder = TimeMillisecondBuilder;
TimeMillisecondBuilder.prototype._setValue = set_js_1.setTimeMillisecond;
/** @ignore */ class TimeMicrosecondBuilder extends TimeBuilder {
}
exports.TimeMicrosecondBuilder = TimeMicrosecondBuilder;
TimeMicrosecondBuilder.prototype._setValue = set_js_1.setTimeMicrosecond;
/** @ignore */ class TimeNanosecondBuilder extends TimeBuilder {
}
exports.TimeNanosecondBuilder = TimeNanosecondBuilder;
TimeNanosecondBuilder.prototype._setValue = set_js_1.setTimeNanosecond; //# sourceMappingURL=time.js.map
}),
"[project]/node_modules/apache-arrow/builder/union.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DenseUnionBuilder = exports.SparseUnionBuilder = exports.UnionBuilder = void 0;
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/buffer.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
/** @ignore */ class UnionBuilder extends builder_js_1.Builder {
    constructor(options){
        super(options);
        this._typeIds = new buffer_js_1.DataBufferBuilder(Int8Array, 0, 1);
        if (typeof options['valueToChildTypeId'] === 'function') {
            this._valueToChildTypeId = options['valueToChildTypeId'];
        }
    }
    get typeIdToChildIndex() {
        return this.type.typeIdToChildIndex;
    }
    append(value, childTypeId) {
        return this.set(this.length, value, childTypeId);
    }
    set(index, value, childTypeId) {
        if (childTypeId === undefined) {
            childTypeId = this._valueToChildTypeId(this, value, index);
        }
        this.setValue(index, value, childTypeId);
        return this;
    }
    setValue(index, value, childTypeId) {
        this._typeIds.set(index, childTypeId);
        const childIndex = this.type.typeIdToChildIndex[childTypeId];
        const child = this.children[childIndex];
        child === null || child === void 0 ? void 0 : child.set(index, value);
    }
    addChild(child, name = `${this.children.length}`) {
        const childTypeId = this.children.push(child);
        const { type: { children, mode, typeIds } } = this;
        const fields = [
            ...children,
            new schema_js_1.Field(name, child.type)
        ];
        this.type = new type_js_1.Union(mode, [
            ...typeIds,
            childTypeId
        ], fields);
        return childTypeId;
    }
    /** @ignore */ // @ts-ignore
    _valueToChildTypeId(builder, value, offset) {
        throw new Error(`Cannot map UnionBuilder value to child typeId. \
Pass the \`childTypeId\` as the second argument to unionBuilder.append(), \
or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
    }
}
exports.UnionBuilder = UnionBuilder;
/** @ignore */ class SparseUnionBuilder extends UnionBuilder {
}
exports.SparseUnionBuilder = SparseUnionBuilder;
/** @ignore */ class DenseUnionBuilder extends UnionBuilder {
    constructor(options){
        super(options);
        this._offsets = new buffer_js_1.DataBufferBuilder(Int32Array);
    }
    /** @ignore */ setValue(index, value, childTypeId) {
        const id = this._typeIds.set(index, childTypeId).buffer[index];
        const child = this.getChildAt(this.type.typeIdToChildIndex[id]);
        const denseIndex = this._offsets.set(index, child.length).buffer[index];
        child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
    }
}
exports.DenseUnionBuilder = DenseUnionBuilder; //# sourceMappingURL=union.js.map
}),
"[project]/node_modules/apache-arrow/builder/utf8.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Utf8Builder = void 0;
const utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/utf8.js [app-ssr] (ecmascript)");
const binary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/binary.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/buffer.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
/** @ignore */ class Utf8Builder extends builder_js_1.VariableWidthBuilder {
    constructor(opts){
        super(opts);
        this._values = new buffer_js_1.BufferBuilder(Uint8Array);
    }
    get byteLength() {
        let size = this._pendingLength + this.length * 4;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
    }
    setValue(index, value) {
        return super.setValue(index, (0, utf8_js_1.encodeUtf8)(value));
    }
    // @ts-ignore
    _flushPending(pending, pendingLength) {}
}
exports.Utf8Builder = Utf8Builder;
Utf8Builder.prototype._flushPending = binary_js_1.BinaryBuilder.prototype._flushPending; //# sourceMappingURL=utf8.js.map
}),
"[project]/node_modules/apache-arrow/builder/largeutf8.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LargeUtf8Builder = void 0;
const utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/utf8.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/buffer.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const largebinary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/largebinary.js [app-ssr] (ecmascript)");
/** @ignore */ class LargeUtf8Builder extends builder_js_1.VariableWidthBuilder {
    constructor(opts){
        super(opts);
        this._values = new buffer_js_1.BufferBuilder(Uint8Array);
    }
    get byteLength() {
        let size = this._pendingLength + this.length * 4;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
    }
    setValue(index, value) {
        return super.setValue(index, (0, utf8_js_1.encodeUtf8)(value));
    }
    // @ts-ignore
    _flushPending(pending, pendingLength) {}
}
exports.LargeUtf8Builder = LargeUtf8Builder;
LargeUtf8Builder.prototype._flushPending = largebinary_js_1.LargeBinaryBuilder.prototype._flushPending; //# sourceMappingURL=largeutf8.js.map
}),
"[project]/node_modules/apache-arrow/visitor/builderctor.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.instance = exports.GetBuilderCtor = void 0;
const visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
const binary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/binary.js [app-ssr] (ecmascript)");
const largebinary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/largebinary.js [app-ssr] (ecmascript)");
const bool_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/bool.js [app-ssr] (ecmascript)");
const date_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/date.js [app-ssr] (ecmascript)");
const decimal_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/decimal.js [app-ssr] (ecmascript)");
const dictionary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/dictionary.js [app-ssr] (ecmascript)");
const fixedsizebinary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/fixedsizebinary.js [app-ssr] (ecmascript)");
const fixedsizelist_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/fixedsizelist.js [app-ssr] (ecmascript)");
const float_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/float.js [app-ssr] (ecmascript)");
const interval_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/interval.js [app-ssr] (ecmascript)");
const duration_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/duration.js [app-ssr] (ecmascript)");
const int_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/int.js [app-ssr] (ecmascript)");
const list_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/list.js [app-ssr] (ecmascript)");
const map_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/map.js [app-ssr] (ecmascript)");
const null_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/null.js [app-ssr] (ecmascript)");
const struct_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/struct.js [app-ssr] (ecmascript)");
const timestamp_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/timestamp.js [app-ssr] (ecmascript)");
const time_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/time.js [app-ssr] (ecmascript)");
const union_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/union.js [app-ssr] (ecmascript)");
const utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/utf8.js [app-ssr] (ecmascript)");
const largeutf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/largeutf8.js [app-ssr] (ecmascript)");
/** @ignore */ class GetBuilderCtor extends visitor_js_1.Visitor {
    visitNull() {
        return null_js_1.NullBuilder;
    }
    visitBool() {
        return bool_js_1.BoolBuilder;
    }
    visitInt() {
        return int_js_1.IntBuilder;
    }
    visitInt8() {
        return int_js_1.Int8Builder;
    }
    visitInt16() {
        return int_js_1.Int16Builder;
    }
    visitInt32() {
        return int_js_1.Int32Builder;
    }
    visitInt64() {
        return int_js_1.Int64Builder;
    }
    visitUint8() {
        return int_js_1.Uint8Builder;
    }
    visitUint16() {
        return int_js_1.Uint16Builder;
    }
    visitUint32() {
        return int_js_1.Uint32Builder;
    }
    visitUint64() {
        return int_js_1.Uint64Builder;
    }
    visitFloat() {
        return float_js_1.FloatBuilder;
    }
    visitFloat16() {
        return float_js_1.Float16Builder;
    }
    visitFloat32() {
        return float_js_1.Float32Builder;
    }
    visitFloat64() {
        return float_js_1.Float64Builder;
    }
    visitUtf8() {
        return utf8_js_1.Utf8Builder;
    }
    visitLargeUtf8() {
        return largeutf8_js_1.LargeUtf8Builder;
    }
    visitBinary() {
        return binary_js_1.BinaryBuilder;
    }
    visitLargeBinary() {
        return largebinary_js_1.LargeBinaryBuilder;
    }
    visitFixedSizeBinary() {
        return fixedsizebinary_js_1.FixedSizeBinaryBuilder;
    }
    visitDate() {
        return date_js_1.DateBuilder;
    }
    visitDateDay() {
        return date_js_1.DateDayBuilder;
    }
    visitDateMillisecond() {
        return date_js_1.DateMillisecondBuilder;
    }
    visitTimestamp() {
        return timestamp_js_1.TimestampBuilder;
    }
    visitTimestampSecond() {
        return timestamp_js_1.TimestampSecondBuilder;
    }
    visitTimestampMillisecond() {
        return timestamp_js_1.TimestampMillisecondBuilder;
    }
    visitTimestampMicrosecond() {
        return timestamp_js_1.TimestampMicrosecondBuilder;
    }
    visitTimestampNanosecond() {
        return timestamp_js_1.TimestampNanosecondBuilder;
    }
    visitTime() {
        return time_js_1.TimeBuilder;
    }
    visitTimeSecond() {
        return time_js_1.TimeSecondBuilder;
    }
    visitTimeMillisecond() {
        return time_js_1.TimeMillisecondBuilder;
    }
    visitTimeMicrosecond() {
        return time_js_1.TimeMicrosecondBuilder;
    }
    visitTimeNanosecond() {
        return time_js_1.TimeNanosecondBuilder;
    }
    visitDecimal() {
        return decimal_js_1.DecimalBuilder;
    }
    visitList() {
        return list_js_1.ListBuilder;
    }
    visitStruct() {
        return struct_js_1.StructBuilder;
    }
    visitUnion() {
        return union_js_1.UnionBuilder;
    }
    visitDenseUnion() {
        return union_js_1.DenseUnionBuilder;
    }
    visitSparseUnion() {
        return union_js_1.SparseUnionBuilder;
    }
    visitDictionary() {
        return dictionary_js_1.DictionaryBuilder;
    }
    visitInterval() {
        return interval_js_1.IntervalBuilder;
    }
    visitIntervalDayTime() {
        return interval_js_1.IntervalDayTimeBuilder;
    }
    visitIntervalYearMonth() {
        return interval_js_1.IntervalYearMonthBuilder;
    }
    visitDuration() {
        return duration_js_1.DurationBuilder;
    }
    visitDurationSecond() {
        return duration_js_1.DurationSecondBuilder;
    }
    visitDurationMillisecond() {
        return duration_js_1.DurationMillisecondBuilder;
    }
    visitDurationMicrosecond() {
        return duration_js_1.DurationMicrosecondBuilder;
    }
    visitDurationNanosecond() {
        return duration_js_1.DurationNanosecondBuilder;
    }
    visitFixedSizeList() {
        return fixedsizelist_js_1.FixedSizeListBuilder;
    }
    visitMap() {
        return map_js_1.MapBuilder;
    }
}
exports.GetBuilderCtor = GetBuilderCtor;
/** @ignore */ exports.instance = new GetBuilderCtor(); //# sourceMappingURL=builderctor.js.map
}),
"[project]/node_modules/apache-arrow/visitor/typecomparator.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.compareTypes = exports.compareFields = exports.compareSchemas = exports.instance = exports.TypeComparator = void 0;
const visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
/** @ignore */ class TypeComparator extends visitor_js_1.Visitor {
    compareSchemas(schema, other) {
        return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);
    }
    compareManyFields(fields, others) {
        return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i)=>this.compareFields(f, others[i]));
    }
    compareFields(field, other) {
        return field === other || other instanceof field.constructor && field.name === other.name && field.nullable === other.nullable && this.visit(field.type, other.type);
    }
}
exports.TypeComparator = TypeComparator;
function compareConstructor(type, other) {
    return other instanceof type.constructor;
}
function compareAny(type, other) {
    return type === other || compareConstructor(type, other);
}
function compareInt(type, other) {
    return type === other || compareConstructor(type, other) && type.bitWidth === other.bitWidth && type.isSigned === other.isSigned;
}
function compareFloat(type, other) {
    return type === other || compareConstructor(type, other) && type.precision === other.precision;
}
function compareFixedSizeBinary(type, other) {
    return type === other || compareConstructor(type, other) && type.byteWidth === other.byteWidth;
}
function compareDate(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
}
function compareTimestamp(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit && type.timezone === other.timezone;
}
function compareTime(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit && type.bitWidth === other.bitWidth;
}
function compareList(type, other) {
    return type === other || compareConstructor(type, other) && type.children.length === other.children.length && exports.instance.compareManyFields(type.children, other.children);
}
function compareStruct(type, other) {
    return type === other || compareConstructor(type, other) && type.children.length === other.children.length && exports.instance.compareManyFields(type.children, other.children);
}
function compareUnion(type, other) {
    return type === other || compareConstructor(type, other) && type.mode === other.mode && type.typeIds.every((x, i)=>x === other.typeIds[i]) && exports.instance.compareManyFields(type.children, other.children);
}
function compareDictionary(type, other) {
    return type === other || compareConstructor(type, other) && type.id === other.id && type.isOrdered === other.isOrdered && exports.instance.visit(type.indices, other.indices) && exports.instance.visit(type.dictionary, other.dictionary);
}
function compareInterval(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
}
function compareDuration(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
}
function compareFixedSizeList(type, other) {
    return type === other || compareConstructor(type, other) && type.listSize === other.listSize && type.children.length === other.children.length && exports.instance.compareManyFields(type.children, other.children);
}
function compareMap(type, other) {
    return type === other || compareConstructor(type, other) && type.keysSorted === other.keysSorted && type.children.length === other.children.length && exports.instance.compareManyFields(type.children, other.children);
}
TypeComparator.prototype.visitNull = compareAny;
TypeComparator.prototype.visitBool = compareAny;
TypeComparator.prototype.visitInt = compareInt;
TypeComparator.prototype.visitInt8 = compareInt;
TypeComparator.prototype.visitInt16 = compareInt;
TypeComparator.prototype.visitInt32 = compareInt;
TypeComparator.prototype.visitInt64 = compareInt;
TypeComparator.prototype.visitUint8 = compareInt;
TypeComparator.prototype.visitUint16 = compareInt;
TypeComparator.prototype.visitUint32 = compareInt;
TypeComparator.prototype.visitUint64 = compareInt;
TypeComparator.prototype.visitFloat = compareFloat;
TypeComparator.prototype.visitFloat16 = compareFloat;
TypeComparator.prototype.visitFloat32 = compareFloat;
TypeComparator.prototype.visitFloat64 = compareFloat;
TypeComparator.prototype.visitUtf8 = compareAny;
TypeComparator.prototype.visitLargeUtf8 = compareAny;
TypeComparator.prototype.visitBinary = compareAny;
TypeComparator.prototype.visitLargeBinary = compareAny;
TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
TypeComparator.prototype.visitDate = compareDate;
TypeComparator.prototype.visitDateDay = compareDate;
TypeComparator.prototype.visitDateMillisecond = compareDate;
TypeComparator.prototype.visitTimestamp = compareTimestamp;
TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
TypeComparator.prototype.visitTime = compareTime;
TypeComparator.prototype.visitTimeSecond = compareTime;
TypeComparator.prototype.visitTimeMillisecond = compareTime;
TypeComparator.prototype.visitTimeMicrosecond = compareTime;
TypeComparator.prototype.visitTimeNanosecond = compareTime;
TypeComparator.prototype.visitDecimal = compareAny;
TypeComparator.prototype.visitList = compareList;
TypeComparator.prototype.visitStruct = compareStruct;
TypeComparator.prototype.visitUnion = compareUnion;
TypeComparator.prototype.visitDenseUnion = compareUnion;
TypeComparator.prototype.visitSparseUnion = compareUnion;
TypeComparator.prototype.visitDictionary = compareDictionary;
TypeComparator.prototype.visitInterval = compareInterval;
TypeComparator.prototype.visitIntervalDayTime = compareInterval;
TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
TypeComparator.prototype.visitDuration = compareDuration;
TypeComparator.prototype.visitDurationSecond = compareDuration;
TypeComparator.prototype.visitDurationMillisecond = compareDuration;
TypeComparator.prototype.visitDurationMicrosecond = compareDuration;
TypeComparator.prototype.visitDurationNanosecond = compareDuration;
TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
TypeComparator.prototype.visitMap = compareMap;
/** @ignore */ exports.instance = new TypeComparator();
function compareSchemas(schema, other) {
    return exports.instance.compareSchemas(schema, other);
}
exports.compareSchemas = compareSchemas;
function compareFields(field, other) {
    return exports.instance.compareFields(field, other);
}
exports.compareFields = compareFields;
function compareTypes(type, other) {
    return exports.instance.visit(type, other);
}
exports.compareTypes = compareTypes; //# sourceMappingURL=typecomparator.js.map
}),
"[project]/node_modules/apache-arrow/factories.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.tableFromJSON = exports.vectorFromArray = exports.makeBuilder = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
const dtypes = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const data_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/data.js [app-ssr] (ecmascript)");
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const builderctor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/builderctor.js [app-ssr] (ecmascript)");
const table_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/table.js [app-ssr] (ecmascript)");
const recordbatch_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/recordbatch.js [app-ssr] (ecmascript)");
const typecomparator_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/typecomparator.js [app-ssr] (ecmascript)");
function makeBuilder(options) {
    const type = options.type;
    const builder = new (builderctor_js_1.instance.getVisitFn(type)())(options);
    if (type.children && type.children.length > 0) {
        const children = options['children'] || [];
        const defaultOptions = {
            'nullValues': options['nullValues']
        };
        const getChildOptions = Array.isArray(children) ? (_, i)=>children[i] || defaultOptions : ({ name })=>children[name] || defaultOptions;
        for (const [index, field] of type.children.entries()){
            const { type } = field;
            const opts = getChildOptions(field, index);
            builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), {
                type
            })));
        }
    }
    return builder;
}
exports.makeBuilder = makeBuilder;
function vectorFromArray(init, type) {
    if (init instanceof data_js_1.Data || init instanceof vector_js_1.Vector || init.type instanceof dtypes.DataType || ArrayBuffer.isView(init)) {
        return (0, vector_js_1.makeVector)(init);
    }
    const options = {
        type: type !== null && type !== void 0 ? type : inferType(init),
        nullValues: [
            null
        ]
    };
    const chunks = [
        ...builderThroughIterable(options)(init)
    ];
    const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b)=>a.concat(b));
    if (dtypes.DataType.isDictionary(vector.type)) {
        return vector.memoize();
    }
    return vector;
}
exports.vectorFromArray = vectorFromArray;
/**
 * Creates a {@link Table} from an array of objects.
 *
 * @param array A table of objects.
 */ function tableFromJSON(array) {
    const vector = vectorFromArray(array);
    const batch = new recordbatch_js_1.RecordBatch(new schema_js_1.Schema(vector.type.children), vector.data[0]);
    return new table_js_1.Table(batch);
}
exports.tableFromJSON = tableFromJSON;
function inferType(value) {
    if (value.length === 0) {
        return new dtypes.Null;
    }
    let nullsCount = 0;
    let arraysCount = 0;
    let objectsCount = 0;
    let numbersCount = 0;
    let stringsCount = 0;
    let bigintsCount = 0;
    let booleansCount = 0;
    let datesCount = 0;
    for (const val of value){
        if (val == null) {
            ++nullsCount;
            continue;
        }
        switch(typeof val){
            case 'bigint':
                ++bigintsCount;
                continue;
            case 'boolean':
                ++booleansCount;
                continue;
            case 'number':
                ++numbersCount;
                continue;
            case 'string':
                ++stringsCount;
                continue;
            case 'object':
                if (Array.isArray(val)) {
                    ++arraysCount;
                } else if (Object.prototype.toString.call(val) === '[object Date]') {
                    ++datesCount;
                } else {
                    ++objectsCount;
                }
                continue;
        }
        throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected.');
    }
    if (numbersCount + nullsCount === value.length) {
        return new dtypes.Float64;
    } else if (stringsCount + nullsCount === value.length) {
        return new dtypes.Dictionary(new dtypes.Utf8, new dtypes.Int32);
    } else if (bigintsCount + nullsCount === value.length) {
        return new dtypes.Int64;
    } else if (booleansCount + nullsCount === value.length) {
        return new dtypes.Bool;
    } else if (datesCount + nullsCount === value.length) {
        return new dtypes.TimestampMillisecond;
    } else if (arraysCount + nullsCount === value.length) {
        const array = value;
        const childType = inferType(array[array.findIndex((ary)=>ary != null)]);
        if (array.every((ary)=>ary == null || (0, typecomparator_js_1.compareTypes)(childType, inferType(ary)))) {
            return new dtypes.List(new schema_js_1.Field('', childType, true));
        }
    } else if (objectsCount + nullsCount === value.length) {
        const fields = new Map();
        for (const row of value){
            for (const key of Object.keys(row)){
                if (!fields.has(key) && row[key] != null) {
                    // use the type inferred for the first instance of a found key
                    fields.set(key, new schema_js_1.Field(key, inferType([
                        row[key]
                    ]), true));
                }
            }
        }
        return new dtypes.Struct([
            ...fields.values()
        ]);
    }
    throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected.');
}
/**
 * Transform a synchronous `Iterable` of arbitrary JavaScript values into a
 * sequence of Arrow Vector<T> following the chunking semantics defined in
 * the supplied `options` argument.
 *
 * This function returns a function that accepts an `Iterable` of values to
 * transform. When called, this function returns an Iterator of `Vector<T>`.
 *
 * The resulting `Iterator<Vector<T>>` yields Vectors based on the
 * `queueingStrategy` and `highWaterMark` specified in the `options` argument.
 *
 * * If `queueingStrategy` is `"count"` (or omitted), The `Iterator<Vector<T>>`
 *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the
 *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.
 * * If `queueingStrategy` is `"bytes"`, the `Iterator<Vector<T>>` will flush
 *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`
 *   reaches or exceeds the supplied `highWaterMark`.
 *
 * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.
 * @returns A function which accepts a JavaScript `Iterable` of values to
 *          write, and returns an `Iterator` that yields Vectors according
 *          to the chunking semantics defined in the `options` argument.
 * @nocollapse
 */ function builderThroughIterable(options) {
    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;
    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
    const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';
    return function*(source) {
        let numChunks = 0;
        const builder = makeBuilder(options);
        for (const value of source){
            if (builder.append(value)[sizeProperty] >= highWaterMark) {
                ++numChunks && (yield builder.toVector());
            }
        }
        if (builder.finish().length > 0 || numChunks === 0) {
            yield builder.toVector();
        }
    };
}
exports.builderThroughIterable = builderThroughIterable;
/**
 * Transform an `AsyncIterable` of arbitrary JavaScript values into a
 * sequence of Arrow Vector<T> following the chunking semantics defined in
 * the supplied `options` argument.
 *
 * This function returns a function that accepts an `AsyncIterable` of values to
 * transform. When called, this function returns an AsyncIterator of `Vector<T>`.
 *
 * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the
 * `queueingStrategy` and `highWaterMark` specified in the `options` argument.
 *
 * * If `queueingStrategy` is `"count"` (or omitted), The `AsyncIterator<Vector<T>>`
 *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the
 *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.
 * * If `queueingStrategy` is `"bytes"`, the `AsyncIterator<Vector<T>>` will flush
 *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`
 *   reaches or exceeds the supplied `highWaterMark`.
 *
 * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.
 * @returns A function which accepts a JavaScript `AsyncIterable` of values
 *          to write, and returns an `AsyncIterator` that yields Vectors
 *          according to the chunking semantics defined in the `options`
 *          argument.
 * @nocollapse
 */ function builderThroughAsyncIterable(options) {
    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;
    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
    const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';
    return function(source) {
        return tslib_1.__asyncGenerator(this, arguments, function*() {
            var _a, e_1, _b, _c;
            let numChunks = 0;
            const builder = makeBuilder(options);
            try {
                for(var _d = true, source_1 = tslib_1.__asyncValues(source), source_1_1; source_1_1 = yield tslib_1.__await(source_1.next()), _a = source_1_1.done, !_a; _d = true){
                    _c = source_1_1.value;
                    _d = false;
                    const value = _c;
                    if (builder.append(value)[sizeProperty] >= highWaterMark) {
                        ++numChunks && (yield yield tslib_1.__await(builder.toVector()));
                    }
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (!_d && !_a && (_b = source_1.return)) yield tslib_1.__await(_b.call(source_1));
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            if (builder.finish().length > 0 || numChunks === 0) {
                yield yield tslib_1.__await(builder.toVector());
            }
        });
    };
}
exports.builderThroughAsyncIterable = builderThroughAsyncIterable; //# sourceMappingURL=factories.js.map
}),
"[project]/node_modules/apache-arrow/util/recordbatch.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.distributeVectorsIntoRecordBatches = void 0;
const data_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/data.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const recordbatch_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/recordbatch.js [app-ssr] (ecmascript)");
/** @ignore */ function distributeVectorsIntoRecordBatches(schema, vecs) {
    return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v)=>v.data.concat()));
}
exports.distributeVectorsIntoRecordBatches = distributeVectorsIntoRecordBatches;
/** @ignore */ function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
    const fields = [
        ...schema.fields
    ];
    const batches = [];
    const memo = {
        numBatches: cols.reduce((n, c)=>Math.max(n, c.length), 0)
    };
    let numBatches = 0, batchLength = 0;
    let i = -1;
    const numColumns = cols.length;
    let child, children = [];
    while(memo.numBatches-- > 0){
        for(batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns;){
            children[i] = child = cols[i].shift();
            batchLength = Math.min(batchLength, child ? child.length : batchLength);
        }
        if (Number.isFinite(batchLength)) {
            children = distributeChildren(fields, batchLength, children, cols, memo);
            if (batchLength > 0) {
                batches[numBatches++] = (0, data_js_1.makeData)({
                    type: new type_js_1.Struct(fields),
                    length: batchLength,
                    nullCount: 0,
                    children: children.slice()
                });
            }
        }
    }
    return [
        schema = schema.assign(fields),
        batches.map((data)=>new recordbatch_js_1.RecordBatch(schema, data))
    ];
}
/** @ignore */ function distributeChildren(fields, batchLength, children, columns, memo) {
    var _a;
    const nullBitmapSize = (batchLength + 63 & ~63) >> 3;
    for(let i = -1, n = columns.length; ++i < n;){
        const child = children[i];
        const length = child === null || child === void 0 ? void 0 : child.length;
        if (length >= batchLength) {
            if (length === batchLength) {
                children[i] = child;
            } else {
                children[i] = child.slice(0, batchLength);
                memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length - batchLength)));
            }
        } else {
            const field = fields[i];
            fields[i] = field.clone({
                nullable: true
            });
            children[i] = (_a = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a !== void 0 ? _a : (0, data_js_1.makeData)({
                type: field.type,
                length: batchLength,
                nullCount: batchLength,
                nullBitmap: new Uint8Array(nullBitmapSize)
            });
        }
    }
    return children;
} //# sourceMappingURL=recordbatch.js.map
}),
"[project]/node_modules/apache-arrow/table.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tableFromArrays = exports.makeTable = exports.Table = void 0;
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const data_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/data.js [app-ssr] (ecmascript)");
const factories_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/factories.js [app-ssr] (ecmascript)");
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const typecomparator_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/typecomparator.js [app-ssr] (ecmascript)");
const recordbatch_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/recordbatch.js [app-ssr] (ecmascript)");
const chunk_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/chunk.js [app-ssr] (ecmascript)");
const get_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/get.js [app-ssr] (ecmascript)");
const set_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)");
const indexof_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/indexof.js [app-ssr] (ecmascript)");
const iterator_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/iterator.js [app-ssr] (ecmascript)");
const vector_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/vector.js [app-ssr] (ecmascript)");
const recordbatch_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/recordbatch.js [app-ssr] (ecmascript)");
/**
 * Tables are collections of {@link Vector}s and have a {@link Schema}. Use the convenience methods {@link makeTable}
 * or {@link tableFromArrays} to create a table in JavaScript. To create a table from the IPC format, use
 * {@link tableFromIPC}.
 */ class Table {
    constructor(...args){
        var _b, _c;
        if (args.length === 0) {
            this.batches = [];
            this.schema = new schema_js_1.Schema([]);
            this._offsets = [
                0
            ];
            return this;
        }
        let schema;
        let offsets;
        if (args[0] instanceof schema_js_1.Schema) {
            schema = args.shift();
        }
        if (args.at(-1) instanceof Uint32Array) {
            offsets = args.pop();
        }
        const unwrap = (x)=>{
            if (x) {
                if (x instanceof recordbatch_js_2.RecordBatch) {
                    return [
                        x
                    ];
                } else if (x instanceof Table) {
                    return x.batches;
                } else if (x instanceof data_js_1.Data) {
                    if (x.type instanceof type_js_1.Struct) {
                        return [
                            new recordbatch_js_2.RecordBatch(new schema_js_1.Schema(x.type.children), x)
                        ];
                    }
                } else if (Array.isArray(x)) {
                    return x.flatMap((v)=>unwrap(v));
                } else if (typeof x[Symbol.iterator] === 'function') {
                    return [
                        ...x
                    ].flatMap((v)=>unwrap(v));
                } else if (typeof x === 'object') {
                    const keys = Object.keys(x);
                    const vecs = keys.map((k)=>new vector_js_1.Vector([
                            x[k]
                        ]));
                    const batchSchema = schema !== null && schema !== void 0 ? schema : new schema_js_1.Schema(keys.map((k, i)=>new schema_js_1.Field(String(k), vecs[i].type, vecs[i].nullable)));
                    const [, batches] = (0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(batchSchema, vecs);
                    return batches.length === 0 ? [
                        new recordbatch_js_2.RecordBatch(x)
                    ] : batches;
                }
            }
            return [];
        };
        const batches = args.flatMap((v)=>unwrap(v));
        schema = (_c = schema !== null && schema !== void 0 ? schema : (_b = batches[0]) === null || _b === void 0 ? void 0 : _b.schema) !== null && _c !== void 0 ? _c : new schema_js_1.Schema([]);
        if (!(schema instanceof schema_js_1.Schema)) {
            throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');
        }
        for (const batch of batches){
            if (!(batch instanceof recordbatch_js_2.RecordBatch)) {
                throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');
            }
            if (!(0, typecomparator_js_1.compareSchemas)(schema, batch.schema)) {
                throw new TypeError('Table and inner RecordBatch schemas must be equivalent.');
            }
        }
        this.schema = schema;
        this.batches = batches;
        this._offsets = offsets !== null && offsets !== void 0 ? offsets : (0, chunk_js_1.computeChunkOffsets)(this.data);
    }
    /**
     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
     */ get data() {
        return this.batches.map(({ data })=>data);
    }
    /**
     * The number of columns in this Table.
     */ get numCols() {
        return this.schema.fields.length;
    }
    /**
     * The number of rows in this Table.
     */ get numRows() {
        return this.data.reduce((numRows, data)=>numRows + data.length, 0);
    }
    /**
     * The number of null rows in this Table.
     */ get nullCount() {
        if (this._nullCount === -1) {
            this._nullCount = (0, chunk_js_1.computeChunkNullCounts)(this.data);
        }
        return this._nullCount;
    }
    /**
     * Check whether an element is null.
     *
     * @param index The index at which to read the validity bitmap.
     */ // @ts-ignore
    isValid(index) {
        return false;
    }
    /**
     * Get an element value by position.
     *
     * @param index The index of the element to read.
     */ // @ts-ignore
    get(index) {
        return null;
    }
    /**
      * Get an element value by position.
      * @param index The index of the element to read. A negative index will count back from the last element.
      */ // @ts-ignore
    at(index) {
        return this.get((0, vector_js_2.wrapIndex)(index, this.numRows));
    }
    /**
     * Set an element value by position.
     *
     * @param index The index of the element to write.
     * @param value The value to set.
     */ // @ts-ignore
    set(index, value) {
        return;
    }
    /**
     * Retrieve the index of the first occurrence of a value in an Vector.
     *
     * @param element The value to locate in the Vector.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */ // @ts-ignore
    indexOf(element, offset) {
        return -1;
    }
    /**
     * Iterator for rows in this Table.
     */ [Symbol.iterator]() {
        if (this.batches.length > 0) {
            return iterator_js_1.instance.visit(new vector_js_1.Vector(this.data));
        }
        return new Array(0)[Symbol.iterator]();
    }
    /**
     * Return a JavaScript Array of the Table rows.
     *
     * @returns An Array of Table rows.
     */ toArray() {
        return [
            ...this
        ];
    }
    /**
     * Returns a string representation of the Table rows.
     *
     * @returns A string representation of the Table rows.
     */ toString() {
        return `[\n  ${this.toArray().join(',\n  ')}\n]`;
    }
    /**
     * Combines two or more Tables of the same schema.
     *
     * @param others Additional Tables to add to the end of this Tables.
     */ concat(...others) {
        const schema = this.schema;
        const data = this.data.concat(others.flatMap(({ data })=>data));
        return new Table(schema, data.map((data)=>new recordbatch_js_2.RecordBatch(schema, data)));
    }
    /**
     * Return a zero-copy sub-section of this Table.
     *
     * @param begin The beginning of the specified portion of the Table.
     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
     */ slice(begin, end) {
        const schema = this.schema;
        [begin, end] = (0, vector_js_2.clampRange)({
            length: this.numRows
        }, begin, end);
        const data = (0, chunk_js_1.sliceChunks)(this.data, this._offsets, begin, end);
        return new Table(schema, data.map((chunk)=>new recordbatch_js_2.RecordBatch(schema, chunk)));
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     *
     * @param name The name of the child to retrieve.
     */ getChild(name) {
        return this.getChildAt(this.schema.fields.findIndex((f)=>f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     *
     * @param index The index of the child to retrieve.
     */ getChildAt(index) {
        if (index > -1 && index < this.schema.fields.length) {
            const data = this.data.map((data)=>data.children[index]);
            if (data.length === 0) {
                const { type } = this.schema.fields[index];
                const empty = (0, data_js_1.makeData)({
                    type,
                    length: 0,
                    nullCount: 0
                });
                data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));
            }
            return new vector_js_1.Vector(data);
        }
        return null;
    }
    /**
     * Sets a child Vector by name.
     *
     * @param name The name of the child to overwrite.
     * @returns A new Table with the supplied child for the specified name.
     */ setChild(name, child) {
        var _b;
        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f)=>f.name === name), child);
    }
    setChildAt(index, child) {
        let schema = this.schema;
        let batches = [
            ...this.batches
        ];
        if (index > -1 && index < this.numCols) {
            if (!child) {
                child = new vector_js_1.Vector([
                    (0, data_js_1.makeData)({
                        type: new type_js_1.Null,
                        length: this.numRows
                    })
                ]);
            }
            const fields = schema.fields.slice();
            const field = fields[index].clone({
                type: child.type
            });
            const children = this.schema.fields.map((_, i)=>this.getChildAt(i));
            [fields[index], children[index]] = [
                field,
                child
            ];
            [schema, batches] = (0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(schema, children);
        }
        return new Table(schema, batches);
    }
    /**
     * Construct a new Table containing only specified columns.
     *
     * @param columnNames Names of columns to keep.
     * @returns A new Table of columns matching the specified names.
     */ select(columnNames) {
        const nameToIndex = this.schema.fields.reduce((m, f, i)=>m.set(f.name, i), new Map());
        return this.selectAt(columnNames.map((columnName)=>nameToIndex.get(columnName)).filter((x)=>x > -1));
    }
    /**
     * Construct a new Table containing only columns at the specified indices.
     *
     * @param columnIndices Indices of columns to keep.
     * @returns A new Table of columns at the specified indices.
     */ selectAt(columnIndices) {
        const schema = this.schema.selectAt(columnIndices);
        const data = this.batches.map((batch)=>batch.selectAt(columnIndices));
        return new Table(schema, data);
    }
    assign(other) {
        const fields = this.schema.fields;
        const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx)=>{
            const [indices, oldToNew] = memo;
            const i = fields.findIndex((f)=>f.name === f2.name);
            ~i ? oldToNew[i] = newIdx : indices.push(newIdx);
            return memo;
        }, [
            [],
            []
        ]);
        const schema = this.schema.assign(other.schema);
        const columns = [
            ...fields.map((_, i)=>[
                    i,
                    oldToNew[i]
                ]).map(([i, j])=>j === undefined ? this.getChildAt(i) : other.getChildAt(j)),
            ...indices.map((i)=>other.getChildAt(i))
        ].filter(Boolean);
        return new Table(...(0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(schema, columns));
    }
}
exports.Table = Table;
_a = Symbol.toStringTag;
// Initialize this static property via an IIFE so bundlers don't tree-shake
// out this logic, but also so we're still compliant with `"sideEffects": false`
Table[_a] = ((proto)=>{
    proto.schema = null;
    proto.batches = [];
    proto._offsets = new Uint32Array([
        0
    ]);
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    proto['isValid'] = (0, chunk_js_1.wrapChunkedCall1)(chunk_js_1.isChunkedValid);
    proto['get'] = (0, chunk_js_1.wrapChunkedCall1)(get_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    proto['set'] = (0, chunk_js_1.wrapChunkedCall2)(set_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    proto['indexOf'] = (0, chunk_js_1.wrapChunkedIndexOf)(indexof_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    return 'Table';
})(Table.prototype);
/**
 * Creates a new Table from an object of typed arrays.
 *
*  @example
 * ```ts
 * const table = makeTable({
 *   a: new Int8Array([1, 2, 3]),
 * })
 * ```
 *
 * @param input Input an object of typed arrays.
 * @returns A new Table.
 */ function makeTable(input) {
    const vecs = {};
    const inputs = Object.entries(input);
    for (const [key, col] of inputs){
        vecs[key] = (0, vector_js_1.makeVector)(col);
    }
    return new Table(vecs);
}
exports.makeTable = makeTable;
/**
 * Creates a new Table from an object of typed arrays or JavaScript arrays.
 *
 *  @example
 * ```ts
 * const table = tableFromArrays({
 *   a: [1, 2, 3],
 *   b: new Int8Array([1, 2, 3]),
 * })
 * ```
 *
 * @param input Input an object of typed arrays or JavaScript arrays.
 * @returns A new Table.
 */ function tableFromArrays(input) {
    const vecs = {};
    const inputs = Object.entries(input);
    for (const [key, col] of inputs){
        vecs[key] = (0, factories_js_1.vectorFromArray)(col);
    }
    return new Table(vecs);
}
exports.tableFromArrays = tableFromArrays; //# sourceMappingURL=table.js.map
}),
"[project]/node_modules/apache-arrow/recordbatch.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._InternalEmptyPlaceholderRecordBatch = exports.RecordBatch = void 0;
const data_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/data.js [app-ssr] (ecmascript)");
const table_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/table.js [app-ssr] (ecmascript)");
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const vector_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/vector.js [app-ssr] (ecmascript)");
const get_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/get.js [app-ssr] (ecmascript)");
const set_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/set.js [app-ssr] (ecmascript)");
const indexof_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/indexof.js [app-ssr] (ecmascript)");
const iterator_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/iterator.js [app-ssr] (ecmascript)");
/** @ignore */ class RecordBatch {
    constructor(...args){
        switch(args.length){
            case 2:
                {
                    [this.schema] = args;
                    if (!(this.schema instanceof schema_js_1.Schema)) {
                        throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');
                    }
                    [, this.data = (0, data_js_1.makeData)({
                        nullCount: 0,
                        type: new type_js_1.Struct(this.schema.fields),
                        children: this.schema.fields.map((f)=>(0, data_js_1.makeData)({
                                type: f.type,
                                nullCount: 0
                            }))
                    })] = args;
                    if (!(this.data instanceof data_js_1.Data)) {
                        throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');
                    }
                    [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
                    break;
                }
            case 1:
                {
                    const [obj] = args;
                    const { fields, children, length } = Object.keys(obj).reduce((memo, name, i)=>{
                        memo.children[i] = obj[name];
                        memo.length = Math.max(memo.length, obj[name].length);
                        memo.fields[i] = schema_js_1.Field.new({
                            name,
                            type: obj[name].type,
                            nullable: true
                        });
                        return memo;
                    }, {
                        length: 0,
                        fields: new Array(),
                        children: new Array()
                    });
                    const schema = new schema_js_1.Schema(fields);
                    const data = (0, data_js_1.makeData)({
                        type: new type_js_1.Struct(fields),
                        length,
                        children,
                        nullCount: 0
                    });
                    [this.schema, this.data] = ensureSameLengthData(schema, data.children, length);
                    break;
                }
            default:
                throw new TypeError('RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.');
        }
    }
    get dictionaries() {
        return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
    }
    /**
     * The number of columns in this RecordBatch.
     */ get numCols() {
        return this.schema.fields.length;
    }
    /**
     * The number of rows in this RecordBatch.
     */ get numRows() {
        return this.data.length;
    }
    /**
     * The number of null rows in this RecordBatch.
     */ get nullCount() {
        return this.data.nullCount;
    }
    /**
     * Check whether an row is null.
     * @param index The index at which to read the validity bitmap.
     */ isValid(index) {
        return this.data.getValid(index);
    }
    /**
     * Get a row by position.
     * @param index The index of the row to read.
     */ get(index) {
        return get_js_1.instance.visit(this.data, index);
    }
    /**
      * Get a row value by position.
      * @param index The index of the row to read. A negative index will count back from the last row.
      */ at(index) {
        return this.get((0, vector_js_2.wrapIndex)(index, this.numRows));
    }
    /**
     * Set a row by position.
     * @param index The index of the row to write.
     * @param value The value to set.
     */ set(index, value) {
        return set_js_1.instance.visit(this.data, index, value);
    }
    /**
     * Retrieve the index of the first occurrence of a row in an RecordBatch.
     * @param element The row to locate in the RecordBatch.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */ indexOf(element, offset) {
        return indexof_js_1.instance.visit(this.data, element, offset);
    }
    /**
     * Iterator for rows in this RecordBatch.
     */ [Symbol.iterator]() {
        return iterator_js_1.instance.visit(new vector_js_1.Vector([
            this.data
        ]));
    }
    /**
     * Return a JavaScript Array of the RecordBatch rows.
     * @returns An Array of RecordBatch rows.
     */ toArray() {
        return [
            ...this
        ];
    }
    /**
     * Combines two or more RecordBatch of the same schema.
     * @param others Additional RecordBatch to add to the end of this RecordBatch.
     */ concat(...others) {
        return new table_js_1.Table(this.schema, [
            this,
            ...others
        ]);
    }
    /**
     * Return a zero-copy sub-section of this RecordBatch.
     * @param start The beginning of the specified portion of the RecordBatch.
     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the row at the index 'end'.
     */ slice(begin, end) {
        const [slice] = new vector_js_1.Vector([
            this.data
        ]).slice(begin, end).data;
        return new RecordBatch(this.schema, slice);
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     * @param name The name of the child to retrieve.
     */ getChild(name) {
        var _b;
        return this.getChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f)=>f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     * @param index The index of the child to retrieve.
     */ getChildAt(index) {
        if (index > -1 && index < this.schema.fields.length) {
            return new vector_js_1.Vector([
                this.data.children[index]
            ]);
        }
        return null;
    }
    /**
     * Sets a child Vector by name.
     * @param name The name of the child to overwrite.
     * @returns A new RecordBatch with the new child for the specified name.
     */ setChild(name, child) {
        var _b;
        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f)=>f.name === name), child);
    }
    setChildAt(index, child) {
        let schema = this.schema;
        let data = this.data;
        if (index > -1 && index < this.numCols) {
            if (!child) {
                child = new vector_js_1.Vector([
                    (0, data_js_1.makeData)({
                        type: new type_js_1.Null,
                        length: this.numRows
                    })
                ]);
            }
            const fields = schema.fields.slice();
            const children = data.children.slice();
            const field = fields[index].clone({
                type: child.type
            });
            [fields[index], children[index]] = [
                field,
                child.data[0]
            ];
            schema = new schema_js_1.Schema(fields, new Map(this.schema.metadata));
            data = (0, data_js_1.makeData)({
                type: new type_js_1.Struct(fields),
                children
            });
        }
        return new RecordBatch(schema, data);
    }
    /**
     * Construct a new RecordBatch containing only specified columns.
     *
     * @param columnNames Names of columns to keep.
     * @returns A new RecordBatch of columns matching the specified names.
     */ select(columnNames) {
        const schema = this.schema.select(columnNames);
        const type = new type_js_1.Struct(schema.fields);
        const children = [];
        for (const name of columnNames){
            const index = this.schema.fields.findIndex((f)=>f.name === name);
            if (~index) {
                children[index] = this.data.children[index];
            }
        }
        return new RecordBatch(schema, (0, data_js_1.makeData)({
            type,
            length: this.numRows,
            children
        }));
    }
    /**
     * Construct a new RecordBatch containing only columns at the specified indices.
     *
     * @param columnIndices Indices of columns to keep.
     * @returns A new RecordBatch of columns matching at the specified indices.
     */ selectAt(columnIndices) {
        const schema = this.schema.selectAt(columnIndices);
        const children = columnIndices.map((i)=>this.data.children[i]).filter(Boolean);
        const subset = (0, data_js_1.makeData)({
            type: new type_js_1.Struct(schema.fields),
            length: this.numRows,
            children
        });
        return new RecordBatch(schema, subset);
    }
}
exports.RecordBatch = RecordBatch;
_a = Symbol.toStringTag;
// Initialize this static property via an IIFE so bundlers don't tree-shake
// out this logic, but also so we're still compliant with `"sideEffects": false`
RecordBatch[_a] = ((proto)=>{
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    return 'RecordBatch';
})(RecordBatch.prototype);
/** @ignore */ function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col)=>Math.max(max, col.length), 0)) {
    var _b;
    const fields = [
        ...schema.fields
    ];
    const children = [
        ...chunks
    ];
    const nullBitmapSize = (maxLength + 63 & ~63) >> 3;
    for (const [idx, field] of schema.fields.entries()){
        const chunk = chunks[idx];
        if (!chunk || chunk.length !== maxLength) {
            fields[idx] = field.clone({
                nullable: true
            });
            children[idx] = (_b = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b !== void 0 ? _b : (0, data_js_1.makeData)({
                type: field.type,
                length: maxLength,
                nullCount: maxLength,
                nullBitmap: new Uint8Array(nullBitmapSize)
            });
        }
    }
    return [
        schema.assign(fields),
        (0, data_js_1.makeData)({
            type: new type_js_1.Struct(fields),
            length: maxLength,
            children
        })
    ];
}
/** @ignore */ function collectDictionaries(fields, children, dictionaries = new Map()) {
    var _b, _c;
    if (((_b = fields === null || fields === void 0 ? void 0 : fields.length) !== null && _b !== void 0 ? _b : 0) > 0 && (fields === null || fields === void 0 ? void 0 : fields.length) === (children === null || children === void 0 ? void 0 : children.length)) {
        for(let i = -1, n = fields.length; ++i < n;){
            const { type } = fields[i];
            const data = children[i];
            for (const next of [
                data,
                ...((_c = data === null || data === void 0 ? void 0 : data.dictionary) === null || _c === void 0 ? void 0 : _c.data) || []
            ]){
                collectDictionaries(type.children, next === null || next === void 0 ? void 0 : next.children, dictionaries);
            }
            if (type_js_1.DataType.isDictionary(type)) {
                const { id } = type;
                if (!dictionaries.has(id)) {
                    if (data === null || data === void 0 ? void 0 : data.dictionary) {
                        dictionaries.set(id, data.dictionary);
                    }
                } else if (dictionaries.get(id) !== data.dictionary) {
                    throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
                }
            }
        }
    }
    return dictionaries;
}
/**
 * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`
 * implementations to differentiate between a stream with valid zero-length
 * RecordBatches, and a stream with a Schema message, but no RecordBatches.
 * @see https://github.com/apache/arrow/pull/4373
 * @ignore
 * @private
 */ class _InternalEmptyPlaceholderRecordBatch extends RecordBatch {
    constructor(schema){
        const children = schema.fields.map((f)=>(0, data_js_1.makeData)({
                type: f.type
            }));
        const data = (0, data_js_1.makeData)({
            type: new type_js_1.Struct(schema.fields),
            nullCount: 0,
            children
        });
        super(schema, data);
    }
}
exports._InternalEmptyPlaceholderRecordBatch = _InternalEmptyPlaceholderRecordBatch; //# sourceMappingURL=recordbatch.js.map
}),
"[project]/node_modules/apache-arrow/fb/message.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Message = void 0;
const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const key_value_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/key-value.js [app-ssr] (ecmascript)");
const message_header_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/message-header.js [app-ssr] (ecmascript)");
const metadata_version_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/metadata-version.js [app-ssr] (ecmascript)");
class Message {
    constructor(){
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMessage(bb, obj) {
        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMessage(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : metadata_version_js_1.MetadataVersion.V1;
    }
    headerType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : message_header_js_1.MessageHeader.NONE;
    }
    header(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    bodyLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startMessage(builder) {
        builder.startObject(5);
    }
    static addVersion(builder, version) {
        builder.addFieldInt16(0, version, metadata_version_js_1.MetadataVersion.V1);
    }
    static addHeaderType(builder, headerType) {
        builder.addFieldInt8(1, headerType, message_header_js_1.MessageHeader.NONE);
    }
    static addHeader(builder, headerOffset) {
        builder.addFieldOffset(2, headerOffset, 0);
    }
    static addBodyLength(builder, bodyLength) {
        builder.addFieldInt64(3, bodyLength, BigInt('0'));
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(let i = data.length - 1; i >= 0; i--){
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endMessage(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishMessageBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedMessageBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
    static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
        Message.startMessage(builder);
        Message.addVersion(builder, version);
        Message.addHeaderType(builder, headerType);
        Message.addHeader(builder, headerOffset);
        Message.addBodyLength(builder, bodyLength);
        Message.addCustomMetadata(builder, customMetadataOffset);
        return Message.endMessage(builder);
    }
}
exports.Message = Message; //# sourceMappingURL=message.js.map
}),
"[project]/node_modules/apache-arrow/visitor/typeassembler.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.instance = exports.TypeAssembler = void 0;
const visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
const null_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/null.js [app-ssr] (ecmascript)");
const int_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/int.js [app-ssr] (ecmascript)");
const floating_point_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/floating-point.js [app-ssr] (ecmascript)");
const binary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/binary.js [app-ssr] (ecmascript)");
const large_binary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/large-binary.js [app-ssr] (ecmascript)");
const bool_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/bool.js [app-ssr] (ecmascript)");
const utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/utf8.js [app-ssr] (ecmascript)");
const large_utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/large-utf8.js [app-ssr] (ecmascript)");
const decimal_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/decimal.js [app-ssr] (ecmascript)");
const date_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/date.js [app-ssr] (ecmascript)");
const time_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/time.js [app-ssr] (ecmascript)");
const timestamp_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/timestamp.js [app-ssr] (ecmascript)");
const interval_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/interval.js [app-ssr] (ecmascript)");
const duration_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/duration.js [app-ssr] (ecmascript)");
const list_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/list.js [app-ssr] (ecmascript)");
const struct__js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/struct-.js [app-ssr] (ecmascript)");
const union_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/union.js [app-ssr] (ecmascript)");
const dictionary_encoding_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/dictionary-encoding.js [app-ssr] (ecmascript)");
const fixed_size_binary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/fixed-size-binary.js [app-ssr] (ecmascript)");
const fixed_size_list_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/fixed-size-list.js [app-ssr] (ecmascript)");
const map_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/map.js [app-ssr] (ecmascript)");
/** @ignore */ class TypeAssembler extends visitor_js_1.Visitor {
    visit(node, builder) {
        return node == null || builder == null ? undefined : super.visit(node, builder);
    }
    visitNull(_node, b) {
        null_js_1.Null.startNull(b);
        return null_js_1.Null.endNull(b);
    }
    visitInt(node, b) {
        int_js_1.Int.startInt(b);
        int_js_1.Int.addBitWidth(b, node.bitWidth);
        int_js_1.Int.addIsSigned(b, node.isSigned);
        return int_js_1.Int.endInt(b);
    }
    visitFloat(node, b) {
        floating_point_js_1.FloatingPoint.startFloatingPoint(b);
        floating_point_js_1.FloatingPoint.addPrecision(b, node.precision);
        return floating_point_js_1.FloatingPoint.endFloatingPoint(b);
    }
    visitBinary(_node, b) {
        binary_js_1.Binary.startBinary(b);
        return binary_js_1.Binary.endBinary(b);
    }
    visitLargeBinary(_node, b) {
        large_binary_js_1.LargeBinary.startLargeBinary(b);
        return large_binary_js_1.LargeBinary.endLargeBinary(b);
    }
    visitBool(_node, b) {
        bool_js_1.Bool.startBool(b);
        return bool_js_1.Bool.endBool(b);
    }
    visitUtf8(_node, b) {
        utf8_js_1.Utf8.startUtf8(b);
        return utf8_js_1.Utf8.endUtf8(b);
    }
    visitLargeUtf8(_node, b) {
        large_utf8_js_1.LargeUtf8.startLargeUtf8(b);
        return large_utf8_js_1.LargeUtf8.endLargeUtf8(b);
    }
    visitDecimal(node, b) {
        decimal_js_1.Decimal.startDecimal(b);
        decimal_js_1.Decimal.addScale(b, node.scale);
        decimal_js_1.Decimal.addPrecision(b, node.precision);
        decimal_js_1.Decimal.addBitWidth(b, node.bitWidth);
        return decimal_js_1.Decimal.endDecimal(b);
    }
    visitDate(node, b) {
        date_js_1.Date.startDate(b);
        date_js_1.Date.addUnit(b, node.unit);
        return date_js_1.Date.endDate(b);
    }
    visitTime(node, b) {
        time_js_1.Time.startTime(b);
        time_js_1.Time.addUnit(b, node.unit);
        time_js_1.Time.addBitWidth(b, node.bitWidth);
        return time_js_1.Time.endTime(b);
    }
    visitTimestamp(node, b) {
        const timezone = node.timezone && b.createString(node.timezone) || undefined;
        timestamp_js_1.Timestamp.startTimestamp(b);
        timestamp_js_1.Timestamp.addUnit(b, node.unit);
        if (timezone !== undefined) {
            timestamp_js_1.Timestamp.addTimezone(b, timezone);
        }
        return timestamp_js_1.Timestamp.endTimestamp(b);
    }
    visitInterval(node, b) {
        interval_js_1.Interval.startInterval(b);
        interval_js_1.Interval.addUnit(b, node.unit);
        return interval_js_1.Interval.endInterval(b);
    }
    visitDuration(node, b) {
        duration_js_1.Duration.startDuration(b);
        duration_js_1.Duration.addUnit(b, node.unit);
        return duration_js_1.Duration.endDuration(b);
    }
    visitList(_node, b) {
        list_js_1.List.startList(b);
        return list_js_1.List.endList(b);
    }
    visitStruct(_node, b) {
        struct__js_1.Struct_.startStruct_(b);
        return struct__js_1.Struct_.endStruct_(b);
    }
    visitUnion(node, b) {
        union_js_1.Union.startTypeIdsVector(b, node.typeIds.length);
        const typeIds = union_js_1.Union.createTypeIdsVector(b, node.typeIds);
        union_js_1.Union.startUnion(b);
        union_js_1.Union.addMode(b, node.mode);
        union_js_1.Union.addTypeIds(b, typeIds);
        return union_js_1.Union.endUnion(b);
    }
    visitDictionary(node, b) {
        const indexType = this.visit(node.indices, b);
        dictionary_encoding_js_1.DictionaryEncoding.startDictionaryEncoding(b);
        dictionary_encoding_js_1.DictionaryEncoding.addId(b, BigInt(node.id));
        dictionary_encoding_js_1.DictionaryEncoding.addIsOrdered(b, node.isOrdered);
        if (indexType !== undefined) {
            dictionary_encoding_js_1.DictionaryEncoding.addIndexType(b, indexType);
        }
        return dictionary_encoding_js_1.DictionaryEncoding.endDictionaryEncoding(b);
    }
    visitFixedSizeBinary(node, b) {
        fixed_size_binary_js_1.FixedSizeBinary.startFixedSizeBinary(b);
        fixed_size_binary_js_1.FixedSizeBinary.addByteWidth(b, node.byteWidth);
        return fixed_size_binary_js_1.FixedSizeBinary.endFixedSizeBinary(b);
    }
    visitFixedSizeList(node, b) {
        fixed_size_list_js_1.FixedSizeList.startFixedSizeList(b);
        fixed_size_list_js_1.FixedSizeList.addListSize(b, node.listSize);
        return fixed_size_list_js_1.FixedSizeList.endFixedSizeList(b);
    }
    visitMap(node, b) {
        map_js_1.Map.startMap(b);
        map_js_1.Map.addKeysSorted(b, node.keysSorted);
        return map_js_1.Map.endMap(b);
    }
}
exports.TypeAssembler = TypeAssembler;
/** @ignore */ exports.instance = new TypeAssembler(); //# sourceMappingURL=typeassembler.js.map
}),
"[project]/node_modules/apache-arrow/ipc/metadata/json.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fieldFromJSON = exports.dictionaryBatchFromJSON = exports.recordBatchFromJSON = exports.schemaFromJSON = void 0;
/* eslint-disable brace-style */ const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const message_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/metadata/message.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
/** @ignore */ function schemaFromJSON(_schema, dictionaries = new Map()) {
    return new schema_js_1.Schema(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema['metadata']), dictionaries);
}
exports.schemaFromJSON = schemaFromJSON;
/** @ignore */ function recordBatchFromJSON(b) {
    return new message_js_1.RecordBatch(b['count'], fieldNodesFromJSON(b['columns']), buffersFromJSON(b['columns']));
}
exports.recordBatchFromJSON = recordBatchFromJSON;
/** @ignore */ function dictionaryBatchFromJSON(b) {
    return new message_js_1.DictionaryBatch(recordBatchFromJSON(b['data']), b['id'], b['isDelta']);
}
exports.dictionaryBatchFromJSON = dictionaryBatchFromJSON;
/** @ignore */ function schemaFieldsFromJSON(_schema, dictionaries) {
    return (_schema['fields'] || []).filter(Boolean).map((f)=>schema_js_1.Field.fromJSON(f, dictionaries));
}
/** @ignore */ function fieldChildrenFromJSON(_field, dictionaries) {
    return (_field['children'] || []).filter(Boolean).map((f)=>schema_js_1.Field.fromJSON(f, dictionaries));
}
/** @ignore */ function fieldNodesFromJSON(xs) {
    return (xs || []).reduce((fieldNodes, column)=>[
            ...fieldNodes,
            new message_js_1.FieldNode(column['count'], nullCountFromJSON(column['VALIDITY'])),
            ...fieldNodesFromJSON(column['children'])
        ], []);
}
/** @ignore */ function buffersFromJSON(xs, buffers = []) {
    for(let i = -1, n = (xs || []).length; ++i < n;){
        const column = xs[i];
        column['VALIDITY'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['VALIDITY'].length));
        column['TYPE_ID'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['TYPE_ID'].length));
        column['OFFSET'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['OFFSET'].length));
        column['DATA'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['DATA'].length));
        buffers = buffersFromJSON(column['children'], buffers);
    }
    return buffers;
}
/** @ignore */ function nullCountFromJSON(validity) {
    return (validity || []).reduce((sum, val)=>sum + +(val === 0), 0);
}
/** @ignore */ function fieldFromJSON(_field, dictionaries) {
    let id;
    let keys;
    let field;
    let dictMeta;
    let type;
    let dictType;
    // If no dictionary encoding
    if (!dictionaries || !(dictMeta = _field['dictionary'])) {
        type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
        field = new schema_js_1.Field(_field['name'], type, _field['nullable'], customMetadataFromJSON(_field['metadata']));
    } else if (!dictionaries.has(id = dictMeta['id'])) {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) : new type_js_1.Int32();
        dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
        dictType = new type_js_1.Dictionary(type, keys, id, dictMeta['isOrdered']);
        field = new schema_js_1.Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['metadata']));
    } else {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) : new type_js_1.Int32();
        dictType = new type_js_1.Dictionary(dictionaries.get(id), keys, id, dictMeta['isOrdered']);
        field = new schema_js_1.Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['metadata']));
    }
    return field || null;
}
exports.fieldFromJSON = fieldFromJSON;
/** @ignore */ function customMetadataFromJSON(metadata = []) {
    return new Map(metadata.map(({ key, value })=>[
            key,
            value
        ]));
}
/** @ignore */ function indexTypeFromJSON(_type) {
    return new type_js_1.Int(_type['isSigned'], _type['bitWidth']);
}
/** @ignore */ function typeFromJSON(f, children) {
    const typeId = f['type']['name'];
    switch(typeId){
        case 'NONE':
            return new type_js_1.Null();
        case 'null':
            return new type_js_1.Null();
        case 'binary':
            return new type_js_1.Binary();
        case 'largebinary':
            return new type_js_1.LargeBinary();
        case 'utf8':
            return new type_js_1.Utf8();
        case 'largeutf8':
            return new type_js_1.LargeUtf8();
        case 'bool':
            return new type_js_1.Bool();
        case 'list':
            return new type_js_1.List((children || [])[0]);
        case 'struct':
            return new type_js_1.Struct(children || []);
        case 'struct_':
            return new type_js_1.Struct(children || []);
    }
    switch(typeId){
        case 'int':
            {
                const t = f['type'];
                return new type_js_1.Int(t['isSigned'], t['bitWidth']);
            }
        case 'floatingpoint':
            {
                const t = f['type'];
                return new type_js_1.Float(enum_js_1.Precision[t['precision']]);
            }
        case 'decimal':
            {
                const t = f['type'];
                return new type_js_1.Decimal(t['scale'], t['precision'], t['bitWidth']);
            }
        case 'date':
            {
                const t = f['type'];
                return new type_js_1.Date_(enum_js_1.DateUnit[t['unit']]);
            }
        case 'time':
            {
                const t = f['type'];
                return new type_js_1.Time(enum_js_1.TimeUnit[t['unit']], t['bitWidth']);
            }
        case 'timestamp':
            {
                const t = f['type'];
                return new type_js_1.Timestamp(enum_js_1.TimeUnit[t['unit']], t['timezone']);
            }
        case 'interval':
            {
                const t = f['type'];
                return new type_js_1.Interval(enum_js_1.IntervalUnit[t['unit']]);
            }
        case 'duration':
            {
                const t = f['type'];
                return new type_js_1.Duration(enum_js_1.TimeUnit[t['unit']]);
            }
        case 'union':
            {
                const t = f['type'];
                const [m, ...ms] = (t['mode'] + '').toLowerCase();
                const mode = m.toUpperCase() + ms.join('');
                return new type_js_1.Union(enum_js_1.UnionMode[mode], t['typeIds'] || [], children || []);
            }
        case 'fixedsizebinary':
            {
                const t = f['type'];
                return new type_js_1.FixedSizeBinary(t['byteWidth']);
            }
        case 'fixedsizelist':
            {
                const t = f['type'];
                return new type_js_1.FixedSizeList(t['listSize'], (children || [])[0]);
            }
        case 'map':
            {
                const t = f['type'];
                return new type_js_1.Map_((children || [])[0], t['keysSorted']);
            }
    }
    throw new Error(`Unrecognized type: "${typeId}"`);
} //# sourceMappingURL=json.js.map
}),
"[project]/node_modules/apache-arrow/ipc/metadata/message.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FieldNode = exports.BufferRegion = exports.DictionaryBatch = exports.RecordBatch = exports.Message = void 0;
/* eslint-disable brace-style */ const flatbuffers = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/schema.js [app-ssr] (ecmascript)");
const int_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/int.js [app-ssr] (ecmascript)");
const record_batch_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/record-batch.js [app-ssr] (ecmascript)");
const dictionary_batch_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/dictionary-batch.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/buffer.js [app-ssr] (ecmascript)");
const field_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/field.js [app-ssr] (ecmascript)");
const field_node_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/field-node.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/type.js [app-ssr] (ecmascript)");
const key_value_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/key-value.js [app-ssr] (ecmascript)");
const endianness_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/endianness.js [app-ssr] (ecmascript)");
const floating_point_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/floating-point.js [app-ssr] (ecmascript)");
const decimal_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/decimal.js [app-ssr] (ecmascript)");
const date_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/date.js [app-ssr] (ecmascript)");
const time_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/time.js [app-ssr] (ecmascript)");
const timestamp_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/timestamp.js [app-ssr] (ecmascript)");
const interval_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/interval.js [app-ssr] (ecmascript)");
const duration_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/duration.js [app-ssr] (ecmascript)");
const union_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/union.js [app-ssr] (ecmascript)");
const fixed_size_binary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/fixed-size-binary.js [app-ssr] (ecmascript)");
const fixed_size_list_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/fixed-size-list.js [app-ssr] (ecmascript)");
const map_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/map.js [app-ssr] (ecmascript)");
const message_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/message.js [app-ssr] (ecmascript)");
const schema_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
const buffer_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
const bigint_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bigint.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const typeassembler_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/typeassembler.js [app-ssr] (ecmascript)");
const json_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/metadata/json.js [app-ssr] (ecmascript)");
var Builder = flatbuffers.Builder;
var ByteBuffer = flatbuffers.ByteBuffer;
const type_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
/**
 * @ignore
 * @private
 **/ class Message {
    /** @nocollapse */ static fromJSON(msg, headerType) {
        const message = new Message(0, enum_js_1.MetadataVersion.V5, headerType);
        message._createHeader = messageHeaderFromJSON(msg, headerType);
        return message;
    }
    /** @nocollapse */ static decode(buf) {
        buf = new ByteBuffer((0, buffer_js_2.toUint8Array)(buf));
        const _message = message_js_1.Message.getRootAsMessage(buf);
        const bodyLength = _message.bodyLength();
        const version = _message.version();
        const headerType = _message.headerType();
        const message = new Message(bodyLength, version, headerType);
        message._createHeader = decodeMessageHeader(_message, headerType);
        return message;
    }
    /** @nocollapse */ static encode(message) {
        const b = new Builder();
        let headerOffset = -1;
        if (message.isSchema()) {
            headerOffset = schema_js_2.Schema.encode(b, message.header());
        } else if (message.isRecordBatch()) {
            headerOffset = RecordBatch.encode(b, message.header());
        } else if (message.isDictionaryBatch()) {
            headerOffset = DictionaryBatch.encode(b, message.header());
        }
        message_js_1.Message.startMessage(b);
        message_js_1.Message.addVersion(b, enum_js_1.MetadataVersion.V5);
        message_js_1.Message.addHeader(b, headerOffset);
        message_js_1.Message.addHeaderType(b, message.headerType);
        message_js_1.Message.addBodyLength(b, BigInt(message.bodyLength));
        message_js_1.Message.finishMessageBuffer(b, message_js_1.Message.endMessage(b));
        return b.asUint8Array();
    }
    /** @nocollapse */ static from(header, bodyLength = 0) {
        if (header instanceof schema_js_2.Schema) {
            return new Message(0, enum_js_1.MetadataVersion.V5, enum_js_1.MessageHeader.Schema, header);
        }
        if (header instanceof RecordBatch) {
            return new Message(bodyLength, enum_js_1.MetadataVersion.V5, enum_js_1.MessageHeader.RecordBatch, header);
        }
        if (header instanceof DictionaryBatch) {
            return new Message(bodyLength, enum_js_1.MetadataVersion.V5, enum_js_1.MessageHeader.DictionaryBatch, header);
        }
        throw new Error(`Unrecognized Message header: ${header}`);
    }
    get type() {
        return this.headerType;
    }
    get version() {
        return this._version;
    }
    get headerType() {
        return this._headerType;
    }
    get bodyLength() {
        return this._bodyLength;
    }
    header() {
        return this._createHeader();
    }
    isSchema() {
        return this.headerType === enum_js_1.MessageHeader.Schema;
    }
    isRecordBatch() {
        return this.headerType === enum_js_1.MessageHeader.RecordBatch;
    }
    isDictionaryBatch() {
        return this.headerType === enum_js_1.MessageHeader.DictionaryBatch;
    }
    constructor(bodyLength, version, headerType, header){
        this._version = version;
        this._headerType = headerType;
        this.body = new Uint8Array(0);
        header && (this._createHeader = ()=>header);
        this._bodyLength = (0, bigint_js_1.bigIntToNumber)(bodyLength);
    }
}
exports.Message = Message;
/**
 * @ignore
 * @private
 **/ class RecordBatch {
    get nodes() {
        return this._nodes;
    }
    get length() {
        return this._length;
    }
    get buffers() {
        return this._buffers;
    }
    constructor(length, nodes, buffers){
        this._nodes = nodes;
        this._buffers = buffers;
        this._length = (0, bigint_js_1.bigIntToNumber)(length);
    }
}
exports.RecordBatch = RecordBatch;
/**
 * @ignore
 * @private
 **/ class DictionaryBatch {
    get id() {
        return this._id;
    }
    get data() {
        return this._data;
    }
    get isDelta() {
        return this._isDelta;
    }
    get length() {
        return this.data.length;
    }
    get nodes() {
        return this.data.nodes;
    }
    get buffers() {
        return this.data.buffers;
    }
    constructor(data, id, isDelta = false){
        this._data = data;
        this._isDelta = isDelta;
        this._id = (0, bigint_js_1.bigIntToNumber)(id);
    }
}
exports.DictionaryBatch = DictionaryBatch;
/**
 * @ignore
 * @private
 **/ class BufferRegion {
    constructor(offset, length){
        this.offset = (0, bigint_js_1.bigIntToNumber)(offset);
        this.length = (0, bigint_js_1.bigIntToNumber)(length);
    }
}
exports.BufferRegion = BufferRegion;
/**
 * @ignore
 * @private
 **/ class FieldNode {
    constructor(length, nullCount){
        this.length = (0, bigint_js_1.bigIntToNumber)(length);
        this.nullCount = (0, bigint_js_1.bigIntToNumber)(nullCount);
    }
}
exports.FieldNode = FieldNode;
/** @ignore */ function messageHeaderFromJSON(message, type) {
    return ()=>{
        switch(type){
            case enum_js_1.MessageHeader.Schema:
                return schema_js_2.Schema.fromJSON(message);
            case enum_js_1.MessageHeader.RecordBatch:
                return RecordBatch.fromJSON(message);
            case enum_js_1.MessageHeader.DictionaryBatch:
                return DictionaryBatch.fromJSON(message);
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_js_1.MessageHeader[type]}, type: ${type} }`);
    };
}
/** @ignore */ function decodeMessageHeader(message, type) {
    return ()=>{
        switch(type){
            case enum_js_1.MessageHeader.Schema:
                return schema_js_2.Schema.decode(message.header(new schema_js_1.Schema()), new Map(), message.version());
            case enum_js_1.MessageHeader.RecordBatch:
                return RecordBatch.decode(message.header(new record_batch_js_1.RecordBatch()), message.version());
            case enum_js_1.MessageHeader.DictionaryBatch:
                return DictionaryBatch.decode(message.header(new dictionary_batch_js_1.DictionaryBatch()), message.version());
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_js_1.MessageHeader[type]}, type: ${type} }`);
    };
}
schema_js_2.Field['encode'] = encodeField;
schema_js_2.Field['decode'] = decodeField;
schema_js_2.Field['fromJSON'] = json_js_1.fieldFromJSON;
schema_js_2.Schema['encode'] = encodeSchema;
schema_js_2.Schema['decode'] = decodeSchema;
schema_js_2.Schema['fromJSON'] = json_js_1.schemaFromJSON;
RecordBatch['encode'] = encodeRecordBatch;
RecordBatch['decode'] = decodeRecordBatch;
RecordBatch['fromJSON'] = json_js_1.recordBatchFromJSON;
DictionaryBatch['encode'] = encodeDictionaryBatch;
DictionaryBatch['decode'] = decodeDictionaryBatch;
DictionaryBatch['fromJSON'] = json_js_1.dictionaryBatchFromJSON;
FieldNode['encode'] = encodeFieldNode;
FieldNode['decode'] = decodeFieldNode;
BufferRegion['encode'] = encodeBufferRegion;
BufferRegion['decode'] = decodeBufferRegion;
/** @ignore */ function decodeSchema(_schema, dictionaries = new Map(), version = enum_js_1.MetadataVersion.V5) {
    const fields = decodeSchemaFields(_schema, dictionaries);
    return new schema_js_2.Schema(fields, decodeCustomMetadata(_schema), dictionaries, version);
}
/** @ignore */ function decodeRecordBatch(batch, version = enum_js_1.MetadataVersion.V5) {
    if (batch.compression() !== null) {
        throw new Error('Record batch compression not implemented');
    }
    return new RecordBatch(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));
}
/** @ignore */ function decodeDictionaryBatch(batch, version = enum_js_1.MetadataVersion.V5) {
    return new DictionaryBatch(RecordBatch.decode(batch.data(), version), batch.id(), batch.isDelta());
}
/** @ignore */ function decodeBufferRegion(b) {
    return new BufferRegion(b.offset(), b.length());
}
/** @ignore */ function decodeFieldNode(f) {
    return new FieldNode(f.length(), f.nullCount());
}
/** @ignore */ function decodeFieldNodes(batch) {
    const nodes = [];
    for(let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n;){
        if (f = batch.nodes(i)) {
            nodes[++j] = FieldNode.decode(f);
        }
    }
    return nodes;
}
/** @ignore */ function decodeBuffers(batch, version) {
    const bufferRegions = [];
    for(let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n;){
        if (b = batch.buffers(i)) {
            // If this Arrow buffer was written before version 4,
            // advance the buffer's bb_pos 8 bytes to skip past
            // the now-removed page_id field
            if (version < enum_js_1.MetadataVersion.V4) {
                b.bb_pos += 8 * (i + 1);
            }
            bufferRegions[++j] = BufferRegion.decode(b);
        }
    }
    return bufferRegions;
}
/** @ignore */ function decodeSchemaFields(schema, dictionaries) {
    const fields = [];
    for(let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n;){
        if (f = schema.fields(i)) {
            fields[++j] = schema_js_2.Field.decode(f, dictionaries);
        }
    }
    return fields;
}
/** @ignore */ function decodeFieldChildren(field, dictionaries) {
    const children = [];
    for(let f, i = -1, j = -1, n = field.childrenLength(); ++i < n;){
        if (f = field.children(i)) {
            children[++j] = schema_js_2.Field.decode(f, dictionaries);
        }
    }
    return children;
}
/** @ignore */ function decodeField(f, dictionaries) {
    let id;
    let field;
    let type;
    let keys;
    let dictType;
    let dictMeta;
    // If no dictionary encoding
    if (!dictionaries || !(dictMeta = f.dictionary())) {
        type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
        field = new schema_js_2.Field(f.name(), type, f.nullable(), decodeCustomMetadata(f));
    } else if (!dictionaries.has(id = (0, bigint_js_1.bigIntToNumber)(dictMeta.id()))) {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_js_2.Int32();
        dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
        dictType = new type_js_2.Dictionary(type, keys, id, dictMeta.isOrdered());
        field = new schema_js_2.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    } else {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_js_2.Int32();
        dictType = new type_js_2.Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());
        field = new schema_js_2.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    }
    return field || null;
}
/** @ignore */ function decodeCustomMetadata(parent) {
    const data = new Map();
    if (parent) {
        for(let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n;){
            if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
                data.set(key, entry.value());
            }
        }
    }
    return data;
}
/** @ignore */ function decodeIndexType(_type) {
    return new type_js_2.Int(_type.isSigned(), _type.bitWidth());
}
/** @ignore */ function decodeFieldType(f, children) {
    const typeId = f.typeType();
    switch(typeId){
        case type_js_1.Type['NONE']:
            return new type_js_2.Null();
        case type_js_1.Type['Null']:
            return new type_js_2.Null();
        case type_js_1.Type['Binary']:
            return new type_js_2.Binary();
        case type_js_1.Type['LargeBinary']:
            return new type_js_2.LargeBinary();
        case type_js_1.Type['Utf8']:
            return new type_js_2.Utf8();
        case type_js_1.Type['LargeUtf8']:
            return new type_js_2.LargeUtf8();
        case type_js_1.Type['Bool']:
            return new type_js_2.Bool();
        case type_js_1.Type['List']:
            return new type_js_2.List((children || [])[0]);
        case type_js_1.Type['Struct_']:
            return new type_js_2.Struct(children || []);
    }
    switch(typeId){
        case type_js_1.Type['Int']:
            {
                const t = f.type(new int_js_1.Int());
                return new type_js_2.Int(t.isSigned(), t.bitWidth());
            }
        case type_js_1.Type['FloatingPoint']:
            {
                const t = f.type(new floating_point_js_1.FloatingPoint());
                return new type_js_2.Float(t.precision());
            }
        case type_js_1.Type['Decimal']:
            {
                const t = f.type(new decimal_js_1.Decimal());
                return new type_js_2.Decimal(t.scale(), t.precision(), t.bitWidth());
            }
        case type_js_1.Type['Date']:
            {
                const t = f.type(new date_js_1.Date());
                return new type_js_2.Date_(t.unit());
            }
        case type_js_1.Type['Time']:
            {
                const t = f.type(new time_js_1.Time());
                return new type_js_2.Time(t.unit(), t.bitWidth());
            }
        case type_js_1.Type['Timestamp']:
            {
                const t = f.type(new timestamp_js_1.Timestamp());
                return new type_js_2.Timestamp(t.unit(), t.timezone());
            }
        case type_js_1.Type['Interval']:
            {
                const t = f.type(new interval_js_1.Interval());
                return new type_js_2.Interval(t.unit());
            }
        case type_js_1.Type['Duration']:
            {
                const t = f.type(new duration_js_1.Duration());
                return new type_js_2.Duration(t.unit());
            }
        case type_js_1.Type['Union']:
            {
                const t = f.type(new union_js_1.Union());
                return new type_js_2.Union(t.mode(), t.typeIdsArray() || [], children || []);
            }
        case type_js_1.Type['FixedSizeBinary']:
            {
                const t = f.type(new fixed_size_binary_js_1.FixedSizeBinary());
                return new type_js_2.FixedSizeBinary(t.byteWidth());
            }
        case type_js_1.Type['FixedSizeList']:
            {
                const t = f.type(new fixed_size_list_js_1.FixedSizeList());
                return new type_js_2.FixedSizeList(t.listSize(), (children || [])[0]);
            }
        case type_js_1.Type['Map']:
            {
                const t = f.type(new map_js_1.Map());
                return new type_js_2.Map_((children || [])[0], t.keysSorted());
            }
    }
    throw new Error(`Unrecognized type: "${type_js_1.Type[typeId]}" (${typeId})`);
}
/** @ignore */ function encodeSchema(b, schema) {
    const fieldOffsets = schema.fields.map((f)=>schema_js_2.Field.encode(b, f));
    schema_js_1.Schema.startFieldsVector(b, fieldOffsets.length);
    const fieldsVectorOffset = schema_js_1.Schema.createFieldsVector(b, fieldOffsets);
    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : schema_js_1.Schema.createCustomMetadataVector(b, [
        ...schema.metadata
    ].map(([k, v])=>{
        const key = b.createString(`${k}`);
        const val = b.createString(`${v}`);
        key_value_js_1.KeyValue.startKeyValue(b);
        key_value_js_1.KeyValue.addKey(b, key);
        key_value_js_1.KeyValue.addValue(b, val);
        return key_value_js_1.KeyValue.endKeyValue(b);
    }));
    schema_js_1.Schema.startSchema(b);
    schema_js_1.Schema.addFields(b, fieldsVectorOffset);
    schema_js_1.Schema.addEndianness(b, platformIsLittleEndian ? endianness_js_1.Endianness.Little : endianness_js_1.Endianness.Big);
    if (metadataOffset !== -1) {
        schema_js_1.Schema.addCustomMetadata(b, metadataOffset);
    }
    return schema_js_1.Schema.endSchema(b);
}
/** @ignore */ function encodeField(b, field) {
    let nameOffset = -1;
    let typeOffset = -1;
    let dictionaryOffset = -1;
    const type = field.type;
    let typeId = field.typeId;
    if (!type_js_2.DataType.isDictionary(type)) {
        typeOffset = typeassembler_js_1.instance.visit(type, b);
    } else {
        typeId = type.dictionary.typeId;
        dictionaryOffset = typeassembler_js_1.instance.visit(type, b);
        typeOffset = typeassembler_js_1.instance.visit(type.dictionary, b);
    }
    const childOffsets = (type.children || []).map((f)=>schema_js_2.Field.encode(b, f));
    const childrenVectorOffset = field_js_1.Field.createChildrenVector(b, childOffsets);
    const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 : field_js_1.Field.createCustomMetadataVector(b, [
        ...field.metadata
    ].map(([k, v])=>{
        const key = b.createString(`${k}`);
        const val = b.createString(`${v}`);
        key_value_js_1.KeyValue.startKeyValue(b);
        key_value_js_1.KeyValue.addKey(b, key);
        key_value_js_1.KeyValue.addValue(b, val);
        return key_value_js_1.KeyValue.endKeyValue(b);
    }));
    if (field.name) {
        nameOffset = b.createString(field.name);
    }
    field_js_1.Field.startField(b);
    field_js_1.Field.addType(b, typeOffset);
    field_js_1.Field.addTypeType(b, typeId);
    field_js_1.Field.addChildren(b, childrenVectorOffset);
    field_js_1.Field.addNullable(b, !!field.nullable);
    if (nameOffset !== -1) {
        field_js_1.Field.addName(b, nameOffset);
    }
    if (dictionaryOffset !== -1) {
        field_js_1.Field.addDictionary(b, dictionaryOffset);
    }
    if (metadataOffset !== -1) {
        field_js_1.Field.addCustomMetadata(b, metadataOffset);
    }
    return field_js_1.Field.endField(b);
}
/** @ignore */ function encodeRecordBatch(b, recordBatch) {
    const nodes = recordBatch.nodes || [];
    const buffers = recordBatch.buffers || [];
    record_batch_js_1.RecordBatch.startNodesVector(b, nodes.length);
    for (const n of nodes.slice().reverse())FieldNode.encode(b, n);
    const nodesVectorOffset = b.endVector();
    record_batch_js_1.RecordBatch.startBuffersVector(b, buffers.length);
    for (const b_ of buffers.slice().reverse())BufferRegion.encode(b, b_);
    const buffersVectorOffset = b.endVector();
    record_batch_js_1.RecordBatch.startRecordBatch(b);
    record_batch_js_1.RecordBatch.addLength(b, BigInt(recordBatch.length));
    record_batch_js_1.RecordBatch.addNodes(b, nodesVectorOffset);
    record_batch_js_1.RecordBatch.addBuffers(b, buffersVectorOffset);
    return record_batch_js_1.RecordBatch.endRecordBatch(b);
}
/** @ignore */ function encodeDictionaryBatch(b, dictionaryBatch) {
    const dataOffset = RecordBatch.encode(b, dictionaryBatch.data);
    dictionary_batch_js_1.DictionaryBatch.startDictionaryBatch(b);
    dictionary_batch_js_1.DictionaryBatch.addId(b, BigInt(dictionaryBatch.id));
    dictionary_batch_js_1.DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
    dictionary_batch_js_1.DictionaryBatch.addData(b, dataOffset);
    return dictionary_batch_js_1.DictionaryBatch.endDictionaryBatch(b);
}
/** @ignore */ function encodeFieldNode(b, node) {
    return field_node_js_1.FieldNode.createFieldNode(b, BigInt(node.length), BigInt(node.nullCount));
}
/** @ignore */ function encodeBufferRegion(b, node) {
    return buffer_js_1.Buffer.createBuffer(b, BigInt(node.offset), BigInt(node.length));
}
/** @ignore */ const platformIsLittleEndian = (()=>{
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(0, 256, true);
    // Int16Array uses the platform's endianness.
    return new Int16Array(buffer)[0] === 256;
})(); //# sourceMappingURL=message.js.map
}),
"[project]/node_modules/apache-arrow/ipc/message.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.magicX2AndPadding = exports.magicAndPadding = exports.magicLength = exports.checkForMagicArrowString = exports.MAGIC = exports.MAGIC_STR = exports.PADDING = exports.JSONMessageReader = exports.AsyncMessageReader = exports.MessageReader = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const flatbuffers_1 = __turbopack_context__.r("[project]/node_modules/flatbuffers/mjs/flatbuffers.js [app-ssr] (ecmascript)");
const message_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/metadata/message.js [app-ssr] (ecmascript)");
const compat_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/compat.js [app-ssr] (ecmascript)");
const file_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/file.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
const stream_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/stream.js [app-ssr] (ecmascript)");
const interfaces_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/interfaces.js [app-ssr] (ecmascript)");
/** @ignore */ const invalidMessageType = (type)=>`Expected ${enum_js_1.MessageHeader[type]} Message in stream, but was null or length 0.`;
/** @ignore */ const nullMessage = (type)=>`Header pointer of flatbuffer-encoded ${enum_js_1.MessageHeader[type]} Message is null or length 0.`;
/** @ignore */ const invalidMessageMetadata = (expected, actual)=>`Expected to read ${expected} metadata bytes, but only read ${actual}.`;
/** @ignore */ const invalidMessageBodyLength = (expected, actual)=>`Expected to read ${expected} bytes for message body, but only read ${actual}.`;
/** @ignore */ class MessageReader {
    constructor(source){
        this.source = source instanceof stream_js_1.ByteStream ? source : new stream_js_1.ByteStream(source);
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        let r;
        if ((r = this.readMetadataLength()).done) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read
        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a
        // pre-v0.15 message, where the first 4 bytes are the metadata length.
        if (r.value === -1 && (r = this.readMetadataLength()).done) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        if ((r = this.readMetadata(r.value)).done) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        return r;
    }
    throw(value) {
        return this.source.throw(value);
    }
    return(value) {
        return this.source.return(value);
    }
    readMessage(type) {
        let r;
        if ((r = this.next()).done) {
            return null;
        }
        if (type != null && r.value.headerType !== type) {
            throw new Error(invalidMessageType(type));
        }
        return r.value;
    }
    readMessageBody(bodyLength) {
        if (bodyLength <= 0) {
            return new Uint8Array(0);
        }
        const buf = (0, buffer_js_1.toUint8Array)(this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817
        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126
        return /* 1. */ buf.byteOffset % 8 === 0 && /* 2. */ buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();
    }
    readSchema(throwIfNull = false) {
        const type = enum_js_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (throwIfNull && !schema) {
            throw new Error(nullMessage(type));
        }
        return schema;
    }
    readMetadataLength() {
        const buf = this.source.read(exports.PADDING);
        const bb = buf && new flatbuffers_1.ByteBuffer(buf);
        const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
        return {
            done: len === 0,
            value: len
        };
    }
    readMetadata(metadataLength) {
        const buf = this.source.read(metadataLength);
        if (!buf) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return {
            done: false,
            value: message_js_1.Message.decode(buf)
        };
    }
}
exports.MessageReader = MessageReader;
/** @ignore */ class AsyncMessageReader {
    constructor(source, byteLength){
        this.source = source instanceof stream_js_1.AsyncByteStream ? source : (0, compat_js_1.isFileHandle)(source) ? new file_js_1.AsyncRandomAccessFile(source, byteLength) : new stream_js_1.AsyncByteStream(source);
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    next() {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            let r;
            if ((r = yield this.readMetadataLength()).done) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read
            // the next 4 for the 32-bit metadata length. Otherwise, assume this is a
            // pre-v0.15 message, where the first 4 bytes are the metadata length.
            if (r.value === -1 && (r = yield this.readMetadataLength()).done) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            if ((r = yield this.readMetadata(r.value)).done) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            return r;
        });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            return yield this.source.throw(value);
        });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            return yield this.source.return(value);
        });
    }
    readMessage(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            let r;
            if ((r = yield this.next()).done) {
                return null;
            }
            if (type != null && r.value.headerType !== type) {
                throw new Error(invalidMessageType(type));
            }
            return r.value;
        });
    }
    readMessageBody(bodyLength) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            if (bodyLength <= 0) {
                return new Uint8Array(0);
            }
            const buf = (0, buffer_js_1.toUint8Array)((yield this.source.read(bodyLength)));
            if (buf.byteLength < bodyLength) {
                throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
            }
            // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817
            // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126
            return /* 1. */ buf.byteOffset % 8 === 0 && /* 2. */ buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();
        });
    }
    readSchema() {
        return tslib_1.__awaiter(this, arguments, void 0, function*(throwIfNull = false) {
            const type = enum_js_1.MessageHeader.Schema;
            const message = yield this.readMessage(type);
            const schema = message === null || message === void 0 ? void 0 : message.header();
            if (throwIfNull && !schema) {
                throw new Error(nullMessage(type));
            }
            return schema;
        });
    }
    readMetadataLength() {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            const buf = yield this.source.read(exports.PADDING);
            const bb = buf && new flatbuffers_1.ByteBuffer(buf);
            const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
            return {
                done: len === 0,
                value: len
            };
        });
    }
    readMetadata(metadataLength) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            const buf = yield this.source.read(metadataLength);
            if (!buf) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            if (buf.byteLength < metadataLength) {
                throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
            }
            return {
                done: false,
                value: message_js_1.Message.decode(buf)
            };
        });
    }
}
exports.AsyncMessageReader = AsyncMessageReader;
/** @ignore */ class JSONMessageReader extends MessageReader {
    constructor(source){
        super(new Uint8Array(0));
        this._schema = false;
        this._body = [];
        this._batchIndex = 0;
        this._dictionaryIndex = 0;
        this._json = source instanceof interfaces_js_1.ArrowJSON ? source : new interfaces_js_1.ArrowJSON(source);
    }
    next() {
        const { _json } = this;
        if (!this._schema) {
            this._schema = true;
            const message = message_js_1.Message.fromJSON(_json.schema, enum_js_1.MessageHeader.Schema);
            return {
                done: false,
                value: message
            };
        }
        if (this._dictionaryIndex < _json.dictionaries.length) {
            const batch = _json.dictionaries[this._dictionaryIndex++];
            this._body = batch['data']['columns'];
            const message = message_js_1.Message.fromJSON(batch, enum_js_1.MessageHeader.DictionaryBatch);
            return {
                done: false,
                value: message
            };
        }
        if (this._batchIndex < _json.batches.length) {
            const batch = _json.batches[this._batchIndex++];
            this._body = batch['columns'];
            const message = message_js_1.Message.fromJSON(batch, enum_js_1.MessageHeader.RecordBatch);
            return {
                done: false,
                value: message
            };
        }
        this._body = [];
        return interfaces_js_1.ITERATOR_DONE;
    }
    readMessageBody(_bodyLength) {
        return flattenDataSources(this._body);
        //TURBOPACK unreachable
        ;
        function flattenDataSources(xs) {
            return (xs || []).reduce((buffers, column)=>[
                    ...buffers,
                    ...column['VALIDITY'] && [
                        column['VALIDITY']
                    ] || [],
                    ...column['TYPE_ID'] && [
                        column['TYPE_ID']
                    ] || [],
                    ...column['OFFSET'] && [
                        column['OFFSET']
                    ] || [],
                    ...column['DATA'] && [
                        column['DATA']
                    ] || [],
                    ...flattenDataSources(column['children'])
                ], []);
        }
    }
    readMessage(type) {
        let r;
        if ((r = this.next()).done) {
            return null;
        }
        if (type != null && r.value.headerType !== type) {
            throw new Error(invalidMessageType(type));
        }
        return r.value;
    }
    readSchema() {
        const type = enum_js_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (!message || !schema) {
            throw new Error(nullMessage(type));
        }
        return schema;
    }
}
exports.JSONMessageReader = JSONMessageReader;
/** @ignore */ exports.PADDING = 4;
/** @ignore */ exports.MAGIC_STR = 'ARROW1';
/** @ignore */ exports.MAGIC = new Uint8Array(exports.MAGIC_STR.length);
for(let i = 0; i < exports.MAGIC_STR.length; i += 1){
    exports.MAGIC[i] = exports.MAGIC_STR.codePointAt(i);
}
/** @ignore */ function checkForMagicArrowString(buffer, index = 0) {
    for(let i = -1, n = exports.MAGIC.length; ++i < n;){
        if (exports.MAGIC[i] !== buffer[index + i]) {
            return false;
        }
    }
    return true;
}
exports.checkForMagicArrowString = checkForMagicArrowString;
/** @ignore */ exports.magicLength = exports.MAGIC.length;
/** @ignore */ exports.magicAndPadding = exports.magicLength + exports.PADDING;
/** @ignore */ exports.magicX2AndPadding = exports.magicLength * 2 + exports.PADDING; //# sourceMappingURL=message.js.map
}),
"[project]/node_modules/apache-arrow/ipc/reader.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AsyncRecordBatchFileReader = exports.RecordBatchFileReader = exports.AsyncRecordBatchStreamReader = exports.RecordBatchStreamReader = exports.RecordBatchReader = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const data_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/data.js [app-ssr] (ecmascript)");
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const file_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/metadata/file.js [app-ssr] (ecmascript)");
const adapters_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/adapters.js [app-ssr] (ecmascript)");
const stream_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/stream.js [app-ssr] (ecmascript)");
const file_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/file.js [app-ssr] (ecmascript)");
const vectorloader_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/vectorloader.js [app-ssr] (ecmascript)");
const recordbatch_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/recordbatch.js [app-ssr] (ecmascript)");
const interfaces_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/interfaces.js [app-ssr] (ecmascript)");
const message_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/message.js [app-ssr] (ecmascript)");
const compat_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/compat.js [app-ssr] (ecmascript)");
class RecordBatchReader extends interfaces_js_1.ReadableInterop {
    constructor(impl){
        super();
        this._impl = impl;
    }
    get closed() {
        return this._impl.closed;
    }
    get schema() {
        return this._impl.schema;
    }
    get autoDestroy() {
        return this._impl.autoDestroy;
    }
    get dictionaries() {
        return this._impl.dictionaries;
    }
    get numDictionaries() {
        return this._impl.numDictionaries;
    }
    get numRecordBatches() {
        return this._impl.numRecordBatches;
    }
    get footer() {
        return this._impl.isFile() ? this._impl.footer : null;
    }
    isSync() {
        return this._impl.isSync();
    }
    isAsync() {
        return this._impl.isAsync();
    }
    isFile() {
        return this._impl.isFile();
    }
    isStream() {
        return this._impl.isStream();
    }
    next() {
        return this._impl.next();
    }
    throw(value) {
        return this._impl.throw(value);
    }
    return(value) {
        return this._impl.return(value);
    }
    cancel() {
        return this._impl.cancel();
    }
    reset(schema) {
        this._impl.reset(schema);
        this._DOMStream = undefined;
        this._nodeStream = undefined;
        return this;
    }
    open(options) {
        const opening = this._impl.open(options);
        return (0, compat_js_1.isPromise)(opening) ? opening.then(()=>this) : this;
    }
    readRecordBatch(index) {
        return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
    }
    [Symbol.iterator]() {
        return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
        return this._impl[Symbol.asyncIterator]();
    }
    toDOMStream() {
        return adapters_js_1.default.toDOMStream(this.isSync() ? {
            [Symbol.iterator]: ()=>this
        } : {
            [Symbol.asyncIterator]: ()=>this
        });
    }
    toNodeStream() {
        return adapters_js_1.default.toNodeStream(this.isSync() ? {
            [Symbol.iterator]: ()=>this
        } : {
            [Symbol.asyncIterator]: ()=>this
        }, {
            objectMode: true
        });
    }
    /** @nocollapse */ // @ts-ignore
    static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */ static throughDOM(// @ts-ignore
    writableStrategy, // @ts-ignore
    readableStrategy) {
        throw new Error(`"throughDOM" not available in this environment`);
    }
    /** @nocollapse */ static from(source) {
        if (source instanceof RecordBatchReader) {
            return source;
        } else if ((0, compat_js_1.isArrowJSON)(source)) {
            return fromArrowJSON(source);
        } else if ((0, compat_js_1.isFileHandle)(source)) {
            return fromFileHandle(source);
        } else if ((0, compat_js_1.isPromise)(source)) {
            return (()=>tslib_1.__awaiter(this, void 0, void 0, function*() {
                    return yield RecordBatchReader.from((yield source));
                }))();
        } else if ((0, compat_js_1.isFetchResponse)(source) || (0, compat_js_1.isReadableDOMStream)(source) || (0, compat_js_1.isReadableNodeStream)(source) || (0, compat_js_1.isAsyncIterable)(source)) {
            return fromAsyncByteStream(new stream_js_1.AsyncByteStream(source));
        }
        return fromByteStream(new stream_js_1.ByteStream(source));
    }
    /** @nocollapse */ static readAll(source) {
        if (source instanceof RecordBatchReader) {
            return source.isSync() ? readAllSync(source) : readAllAsync(source);
        } else if ((0, compat_js_1.isArrowJSON)(source) || ArrayBuffer.isView(source) || (0, compat_js_1.isIterable)(source) || (0, compat_js_1.isIteratorResult)(source)) {
            return readAllSync(source);
        }
        return readAllAsync(source);
    }
}
exports.RecordBatchReader = RecordBatchReader;
//
// Since TS is a structural type system, we define the following subclass stubs
// so that concrete types exist to associate with the interfaces below.
//
// The implementation for each RecordBatchReader is hidden away in the set of
// `RecordBatchReaderImpl` classes in the second half of this file. This allows
// us to export a single RecordBatchReader class, and swap out the impl based
// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.
//
// Async/await makes our job a bit harder, since it forces everything to be
// either fully sync or fully async. This is why the logic for the reader impls
// has been duplicated into both sync and async variants. Since the RBR
// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for
// example will return async/await-friendly Promises, but one with a (sync)
// RecordBatchStreamReaderImpl will always return values. Nothing should be
// different about their logic, aside from the async handling. This is also why
// this code looks highly structured, as it should be nearly identical and easy
// to follow.
//
/** @ignore */ class RecordBatchStreamReader extends RecordBatchReader {
    constructor(_impl){
        super(_impl);
        this._impl = _impl;
    }
    readAll() {
        return [
            ...this
        ];
    }
    [Symbol.iterator]() {
        return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
        return tslib_1.__asyncGenerator(this, arguments, function* _a() {
            yield tslib_1.__await((yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(this[Symbol.iterator]()))));
        });
    }
}
exports.RecordBatchStreamReader = RecordBatchStreamReader;
/** @ignore */ class AsyncRecordBatchStreamReader extends RecordBatchReader {
    constructor(_impl){
        super(_impl);
        this._impl = _impl;
    }
    readAll() {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            var _a, e_1, _b, _c;
            const batches = new Array();
            try {
                for(var _d = true, _e = tslib_1.__asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true){
                    _c = _f.value;
                    _d = false;
                    const batch = _c;
                    batches.push(batch);
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            return batches;
        });
    }
    [Symbol.iterator]() {
        throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
    }
    [Symbol.asyncIterator]() {
        return this._impl[Symbol.asyncIterator]();
    }
}
exports.AsyncRecordBatchStreamReader = AsyncRecordBatchStreamReader;
/** @ignore */ class RecordBatchFileReader extends RecordBatchStreamReader {
    constructor(_impl){
        super(_impl);
        this._impl = _impl;
    }
}
exports.RecordBatchFileReader = RecordBatchFileReader;
/** @ignore */ class AsyncRecordBatchFileReader extends AsyncRecordBatchStreamReader {
    constructor(_impl){
        super(_impl);
        this._impl = _impl;
    }
}
exports.AsyncRecordBatchFileReader = AsyncRecordBatchFileReader;
/** @ignore */ class RecordBatchReaderImpl {
    get numDictionaries() {
        return this._dictionaryIndex;
    }
    get numRecordBatches() {
        return this._recordBatchIndex;
    }
    constructor(dictionaries = new Map()){
        this.closed = false;
        this.autoDestroy = true;
        this._dictionaryIndex = 0;
        this._recordBatchIndex = 0;
        this.dictionaries = dictionaries;
    }
    isSync() {
        return false;
    }
    isAsync() {
        return false;
    }
    isFile() {
        return false;
    }
    isStream() {
        return false;
    }
    reset(schema) {
        this._dictionaryIndex = 0;
        this._recordBatchIndex = 0;
        this.schema = schema;
        this.dictionaries = new Map();
        return this;
    }
    _loadRecordBatch(header, body) {
        const children = this._loadVectors(header, body, this.schema.fields);
        const data = (0, data_js_1.makeData)({
            type: new type_js_1.Struct(this.schema.fields),
            length: header.length,
            children
        });
        return new recordbatch_js_1.RecordBatch(this.schema, data);
    }
    _loadDictionaryBatch(header, body) {
        const { id, isDelta } = header;
        const { dictionaries, schema } = this;
        const dictionary = dictionaries.get(id);
        const type = schema.dictionaries.get(id);
        const data = this._loadVectors(header.data, body, [
            type
        ]);
        return (dictionary && isDelta ? dictionary.concat(new vector_js_1.Vector(data)) : new vector_js_1.Vector(data)).memoize();
    }
    _loadVectors(header, body, types) {
        return new vectorloader_js_1.VectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
    }
}
/** @ignore */ class RecordBatchStreamReaderImpl extends RecordBatchReaderImpl {
    constructor(source, dictionaries){
        super(dictionaries);
        this._reader = !(0, compat_js_1.isArrowJSON)(source) ? new message_js_1.MessageReader(this._handle = source) : new message_js_1.JSONMessageReader(this._handle = source);
    }
    isSync() {
        return true;
    }
    isStream() {
        return true;
    }
    [Symbol.iterator]() {
        return this;
    }
    cancel() {
        if (!this.closed && (this.closed = true)) {
            this.reset()._reader.return();
            this._reader = null;
            this.dictionaries = null;
        }
    }
    open(options) {
        if (!this.closed) {
            this.autoDestroy = shouldAutoDestroy(this, options);
            if (!(this.schema || (this.schema = this._reader.readSchema()))) {
                this.cancel();
            }
        }
        return this;
    }
    throw(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
            return this.reset()._reader.throw(value);
        }
        return interfaces_js_1.ITERATOR_DONE;
    }
    return(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
            return this.reset()._reader.return(value);
        }
        return interfaces_js_1.ITERATOR_DONE;
    }
    next() {
        if (this.closed) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        let message;
        const { _reader: reader } = this;
        while(message = this._readNextMessageAndValidate()){
            if (message.isSchema()) {
                this.reset(message.header());
            } else if (message.isRecordBatch()) {
                this._recordBatchIndex++;
                const header = message.header();
                const buffer = reader.readMessageBody(message.bodyLength);
                const recordBatch = this._loadRecordBatch(header, buffer);
                return {
                    done: false,
                    value: recordBatch
                };
            } else if (message.isDictionaryBatch()) {
                this._dictionaryIndex++;
                const header = message.header();
                const buffer = reader.readMessageBody(message.bodyLength);
                const vector = this._loadDictionaryBatch(header, buffer);
                this.dictionaries.set(header.id, vector);
            }
        }
        if (this.schema && this._recordBatchIndex === 0) {
            this._recordBatchIndex++;
            return {
                done: false,
                value: new recordbatch_js_1._InternalEmptyPlaceholderRecordBatch(this.schema)
            };
        }
        return this.return();
    }
    _readNextMessageAndValidate(type) {
        return this._reader.readMessage(type);
    }
}
/** @ignore */ class AsyncRecordBatchStreamReaderImpl extends RecordBatchReaderImpl {
    constructor(source, dictionaries){
        super(dictionaries);
        this._reader = new message_js_1.AsyncMessageReader(this._handle = source);
    }
    isAsync() {
        return true;
    }
    isStream() {
        return true;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    cancel() {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            if (!this.closed && (this.closed = true)) {
                yield this.reset()._reader.return();
                this._reader = null;
                this.dictionaries = null;
            }
        });
    }
    open(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            if (!this.closed) {
                this.autoDestroy = shouldAutoDestroy(this, options);
                if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
                    yield this.cancel();
                }
            }
            return this;
        });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            if (!this.closed && this.autoDestroy && (this.closed = true)) {
                return yield this.reset()._reader.throw(value);
            }
            return interfaces_js_1.ITERATOR_DONE;
        });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            if (!this.closed && this.autoDestroy && (this.closed = true)) {
                return yield this.reset()._reader.return(value);
            }
            return interfaces_js_1.ITERATOR_DONE;
        });
    }
    next() {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            if (this.closed) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            let message;
            const { _reader: reader } = this;
            while(message = yield this._readNextMessageAndValidate()){
                if (message.isSchema()) {
                    yield this.reset(message.header());
                } else if (message.isRecordBatch()) {
                    this._recordBatchIndex++;
                    const header = message.header();
                    const buffer = yield reader.readMessageBody(message.bodyLength);
                    const recordBatch = this._loadRecordBatch(header, buffer);
                    return {
                        done: false,
                        value: recordBatch
                    };
                } else if (message.isDictionaryBatch()) {
                    this._dictionaryIndex++;
                    const header = message.header();
                    const buffer = yield reader.readMessageBody(message.bodyLength);
                    const vector = this._loadDictionaryBatch(header, buffer);
                    this.dictionaries.set(header.id, vector);
                }
            }
            if (this.schema && this._recordBatchIndex === 0) {
                this._recordBatchIndex++;
                return {
                    done: false,
                    value: new recordbatch_js_1._InternalEmptyPlaceholderRecordBatch(this.schema)
                };
            }
            return yield this.return();
        });
    }
    _readNextMessageAndValidate(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            return yield this._reader.readMessage(type);
        });
    }
}
/** @ignore */ class RecordBatchFileReaderImpl extends RecordBatchStreamReaderImpl {
    get footer() {
        return this._footer;
    }
    get numDictionaries() {
        return this._footer ? this._footer.numDictionaries : 0;
    }
    get numRecordBatches() {
        return this._footer ? this._footer.numRecordBatches : 0;
    }
    constructor(source, dictionaries){
        super(source instanceof file_js_2.RandomAccessFile ? source : new file_js_2.RandomAccessFile(source), dictionaries);
    }
    isSync() {
        return true;
    }
    isFile() {
        return true;
    }
    open(options) {
        if (!this.closed && !this._footer) {
            this.schema = (this._footer = this._readFooter()).schema;
            for (const block of this._footer.dictionaryBatches()){
                block && this._readDictionaryBatch(this._dictionaryIndex++);
            }
        }
        return super.open(options);
    }
    readRecordBatch(index) {
        var _a;
        if (this.closed) {
            return null;
        }
        if (!this._footer) {
            this.open();
        }
        const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);
        if (block && this._handle.seek(block.offset)) {
            const message = this._reader.readMessage(enum_js_1.MessageHeader.RecordBatch);
            if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
                const header = message.header();
                const buffer = this._reader.readMessageBody(message.bodyLength);
                const recordBatch = this._loadRecordBatch(header, buffer);
                return recordBatch;
            }
        }
        return null;
    }
    _readDictionaryBatch(index) {
        var _a;
        const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);
        if (block && this._handle.seek(block.offset)) {
            const message = this._reader.readMessage(enum_js_1.MessageHeader.DictionaryBatch);
            if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
                const header = message.header();
                const buffer = this._reader.readMessageBody(message.bodyLength);
                const vector = this._loadDictionaryBatch(header, buffer);
                this.dictionaries.set(header.id, vector);
            }
        }
    }
    _readFooter() {
        const { _handle } = this;
        const offset = _handle.size - message_js_1.magicAndPadding;
        const length = _handle.readInt32(offset);
        const buffer = _handle.readAt(offset - length, length);
        return file_js_1.Footer.decode(buffer);
    }
    _readNextMessageAndValidate(type) {
        var _a;
        if (!this._footer) {
            this.open();
        }
        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
            const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(this._recordBatchIndex);
            if (block && this._handle.seek(block.offset)) {
                return this._reader.readMessage(type);
            }
        }
        return null;
    }
}
/** @ignore */ class AsyncRecordBatchFileReaderImpl extends AsyncRecordBatchStreamReaderImpl {
    get footer() {
        return this._footer;
    }
    get numDictionaries() {
        return this._footer ? this._footer.numDictionaries : 0;
    }
    get numRecordBatches() {
        return this._footer ? this._footer.numRecordBatches : 0;
    }
    constructor(source, ...rest){
        const byteLength = typeof rest[0] !== 'number' ? rest.shift() : undefined;
        const dictionaries = rest[0] instanceof Map ? rest.shift() : undefined;
        super(source instanceof file_js_2.AsyncRandomAccessFile ? source : new file_js_2.AsyncRandomAccessFile(source, byteLength), dictionaries);
    }
    isFile() {
        return true;
    }
    isAsync() {
        return true;
    }
    open(options) {
        const _super = Object.create(null, {
            open: {
                get: ()=>super.open
            }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            if (!this.closed && !this._footer) {
                this.schema = (this._footer = yield this._readFooter()).schema;
                for (const block of this._footer.dictionaryBatches()){
                    block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
                }
            }
            return yield _super.open.call(this, options);
        });
    }
    readRecordBatch(index) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            var _a;
            if (this.closed) {
                return null;
            }
            if (!this._footer) {
                yield this.open();
            }
            const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);
            if (block && (yield this._handle.seek(block.offset))) {
                const message = yield this._reader.readMessage(enum_js_1.MessageHeader.RecordBatch);
                if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
                    const header = message.header();
                    const buffer = yield this._reader.readMessageBody(message.bodyLength);
                    const recordBatch = this._loadRecordBatch(header, buffer);
                    return recordBatch;
                }
            }
            return null;
        });
    }
    _readDictionaryBatch(index) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            var _a;
            const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);
            if (block && (yield this._handle.seek(block.offset))) {
                const message = yield this._reader.readMessage(enum_js_1.MessageHeader.DictionaryBatch);
                if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
                    const header = message.header();
                    const buffer = yield this._reader.readMessageBody(message.bodyLength);
                    const vector = this._loadDictionaryBatch(header, buffer);
                    this.dictionaries.set(header.id, vector);
                }
            }
        });
    }
    _readFooter() {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            const { _handle } = this;
            _handle._pending && (yield _handle._pending);
            const offset = _handle.size - message_js_1.magicAndPadding;
            const length = yield _handle.readInt32(offset);
            const buffer = yield _handle.readAt(offset - length, length);
            return file_js_1.Footer.decode(buffer);
        });
    }
    _readNextMessageAndValidate(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            if (!this._footer) {
                yield this.open();
            }
            if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
                const block = this._footer.getRecordBatch(this._recordBatchIndex);
                if (block && (yield this._handle.seek(block.offset))) {
                    return yield this._reader.readMessage(type);
                }
            }
            return null;
        });
    }
}
/** @ignore */ class RecordBatchJSONReaderImpl extends RecordBatchStreamReaderImpl {
    constructor(source, dictionaries){
        super(source, dictionaries);
    }
    _loadVectors(header, body, types) {
        return new vectorloader_js_1.JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
    }
}
//
// Define some helper functions and static implementations down here. There's
// a bit of branching in the static methods that can lead to the same routines
// being executed, so we've broken those out here for readability.
//
/** @ignore */ function shouldAutoDestroy(self, options) {
    return options && typeof options['autoDestroy'] === 'boolean' ? options['autoDestroy'] : self['autoDestroy'];
}
/** @ignore */ function* readAllSync(source) {
    const reader = RecordBatchReader.from(source);
    try {
        if (!reader.open({
            autoDestroy: false
        }).closed) {
            do {
                yield reader;
            }while (!reader.reset().open().closed)
        }
    } finally{
        reader.cancel();
    }
}
/** @ignore */ function readAllAsync(source) {
    return tslib_1.__asyncGenerator(this, arguments, function* readAllAsync_1() {
        const reader = yield tslib_1.__await(RecordBatchReader.from(source));
        try {
            if (!(yield tslib_1.__await(reader.open({
                autoDestroy: false
            }))).closed) {
                do {
                    yield yield tslib_1.__await(reader);
                }while (!(yield tslib_1.__await(reader.reset().open())).closed)
            }
        } finally{
            yield tslib_1.__await(reader.cancel());
        }
    });
}
/** @ignore */ function fromArrowJSON(source) {
    return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));
}
/** @ignore */ function fromByteStream(source) {
    const bytes = source.peek(message_js_1.magicLength + 7 & ~7);
    return bytes && bytes.byteLength >= 4 ? !(0, message_js_1.checkForMagicArrowString)(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function*() {}()));
}
/** @ignore */ function fromAsyncByteStream(source) {
    return tslib_1.__awaiter(this, void 0, void 0, function*() {
        const bytes = yield source.peek(message_js_1.magicLength + 7 & ~7);
        return bytes && bytes.byteLength >= 4 ? !(0, message_js_1.checkForMagicArrowString)(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl((yield source.read()))) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {
            return tslib_1.__asyncGenerator(this, arguments, function*() {});
        }()));
    });
}
/** @ignore */ function fromFileHandle(source) {
    return tslib_1.__awaiter(this, void 0, void 0, function*() {
        const { size } = yield source.stat();
        const file = new file_js_2.AsyncRandomAccessFile(source, size);
        if (size >= message_js_1.magicX2AndPadding && (0, message_js_1.checkForMagicArrowString)((yield file.readAt(0, message_js_1.magicLength + 7 & ~7)))) {
            return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
        }
        return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
    });
} //# sourceMappingURL=reader.js.map
}),
"[project]/node_modules/apache-arrow/visitor/vectorassembler.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorAssembler = void 0;
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const recordbatch_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/recordbatch.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
const bit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bit.js [app-ssr] (ecmascript)");
const message_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/metadata/message.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const bigint_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bigint.js [app-ssr] (ecmascript)");
/** @ignore */ class VectorAssembler extends visitor_js_1.Visitor {
    /** @nocollapse */ static assemble(...args) {
        const unwrap = (nodes)=>nodes.flatMap((node)=>Array.isArray(node) ? unwrap(node) : node instanceof recordbatch_js_1.RecordBatch ? node.data.children : node.data);
        const assembler = new VectorAssembler();
        assembler.visitMany(unwrap(args));
        return assembler;
    }
    constructor(){
        super();
        this._byteLength = 0;
        this._nodes = [];
        this._buffers = [];
        this._bufferRegions = [];
    }
    visit(data) {
        if (data instanceof vector_js_1.Vector) {
            this.visitMany(data.data);
            return this;
        }
        const { type } = data;
        if (!type_js_1.DataType.isDictionary(type)) {
            const { length } = data;
            if (length > 2147483647) {
                /* istanbul ignore next */ throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');
            }
            if (type_js_1.DataType.isUnion(type)) {
                this.nodes.push(new message_js_1.FieldNode(length, 0));
            } else {
                const { nullCount } = data;
                if (!type_js_1.DataType.isNull(type)) {
                    addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) // placeholder validity buffer
                     : (0, bit_js_1.truncateBitmap)(data.offset, length, data.nullBitmap));
                }
                this.nodes.push(new message_js_1.FieldNode(length, nullCount));
            }
        }
        return super.visit(data);
    }
    visitNull(_null) {
        return this;
    }
    visitDictionary(data) {
        // Assemble the indices here, Dictionary assembled separately.
        return this.visit(data.clone(data.type.indices));
    }
    get nodes() {
        return this._nodes;
    }
    get buffers() {
        return this._buffers;
    }
    get byteLength() {
        return this._byteLength;
    }
    get bufferRegions() {
        return this._bufferRegions;
    }
}
exports.VectorAssembler = VectorAssembler;
/** @ignore */ function addBuffer(values) {
    const byteLength = values.byteLength + 7 & ~7; // Round up to a multiple of 8
    this.buffers.push(values);
    this.bufferRegions.push(new message_js_1.BufferRegion(this._byteLength, byteLength));
    this._byteLength += byteLength;
    return this;
}
/** @ignore */ function assembleUnion(data) {
    var _a;
    const { type, length, typeIds, valueOffsets } = data;
    // All Union Vectors have a typeIds buffer
    addBuffer.call(this, typeIds);
    // If this is a Sparse Union, treat it like all other Nested types
    if (type.mode === enum_js_1.UnionMode.Sparse) {
        return assembleNestedVector.call(this, data);
    } else if (type.mode === enum_js_1.UnionMode.Dense) {
        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children
        if (data.offset <= 0) {
            // If the Vector hasn't been sliced, write the existing valueOffsets
            addBuffer.call(this, valueOffsets);
            // We can treat this like all other Nested types
            return assembleNestedVector.call(this, data);
        } else {
            // A sliced Dense Union is an unpleasant case. Because the offsets are different for
            // each child vector, we need to "rebase" the valueOffsets for each child
            // Union typeIds are not necessary 0-indexed
            const shiftedOffsets = new Int32Array(length);
            const childOffsets = Object.create(null);
            const childLengths = Object.create(null);
            // If we have a non-zero offset, then the value offsets do not start at
            // zero. We must a) create a new offsets array with shifted offsets and
            // b) slice the values array accordingly
            for(let typeId, shift, index = -1; ++index < length;){
                if ((typeId = typeIds[index]) === undefined) {
                    continue;
                }
                if ((shift = childOffsets[typeId]) === undefined) {
                    shift = childOffsets[typeId] = valueOffsets[index];
                }
                shiftedOffsets[index] = valueOffsets[index] - shift;
                childLengths[typeId] = ((_a = childLengths[typeId]) !== null && _a !== void 0 ? _a : 0) + 1;
            }
            addBuffer.call(this, shiftedOffsets);
            // Slice and visit children accordingly
            this.visitMany(data.children.map((child, childIndex)=>{
                const typeId = type.typeIds[childIndex];
                const childOffset = childOffsets[typeId];
                const childLength = childLengths[typeId];
                return child.slice(childOffset, Math.min(length, childLength));
            }));
        }
    }
    return this;
}
/** @ignore */ function assembleBoolVector(data) {
    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed
    let values;
    if (data.nullCount >= data.length) {
        // If all values are null, just insert a placeholder empty data buffer (fastest path)
        return addBuffer.call(this, new Uint8Array(0));
    } else if ((values = data.values) instanceof Uint8Array) {
        // If values is already a Uint8Array, slice the bitmap (fast path)
        return addBuffer.call(this, (0, bit_js_1.truncateBitmap)(data.offset, data.length, values));
    }
    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the
    // values as bools and re-pack them into a Uint8Array. This code isn't
    // reachable unless you're trying to manipulate the Data internals,
    // we're only doing this for safety.
    /* istanbul ignore next */ return addBuffer.call(this, (0, bit_js_1.packBools)(data.values));
}
/** @ignore */ function assembleFlatVector(data) {
    return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));
}
/** @ignore */ function assembleFlatListVector(data) {
    const { length, values, valueOffsets } = data;
    const begin = (0, bigint_js_1.bigIntToNumber)(valueOffsets[0]);
    const end = (0, bigint_js_1.bigIntToNumber)(valueOffsets[length]);
    const byteLength = Math.min(end - begin, values.byteLength - begin);
    // Push in the order FlatList types read their buffers
    addBuffer.call(this, (0, buffer_js_1.rebaseValueOffsets)(-begin, length + 1, valueOffsets)); // valueOffsets buffer first
    addBuffer.call(this, values.subarray(begin, begin + byteLength)); // sliced values buffer second
    return this;
}
/** @ignore */ function assembleListVector(data) {
    const { length, valueOffsets } = data;
    // If we have valueOffsets (MapVector, ListVector), push that buffer first
    if (valueOffsets) {
        const { [0]: begin, [length]: end } = valueOffsets;
        addBuffer.call(this, (0, buffer_js_1.rebaseValueOffsets)(-begin, length + 1, valueOffsets));
        // Then insert the List's values child
        return this.visit(data.children[0].slice(begin, end - begin));
    }
    // Then insert the List's values child
    return this.visit(data.children[0]);
}
/** @ignore */ function assembleNestedVector(data) {
    return this.visitMany(data.type.children.map((_, i)=>data.children[i]).filter(Boolean))[0];
}
VectorAssembler.prototype.visitBool = assembleBoolVector;
VectorAssembler.prototype.visitInt = assembleFlatVector;
VectorAssembler.prototype.visitFloat = assembleFlatVector;
VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitLargeUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitBinary = assembleFlatListVector;
VectorAssembler.prototype.visitLargeBinary = assembleFlatListVector;
VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
VectorAssembler.prototype.visitDate = assembleFlatVector;
VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
VectorAssembler.prototype.visitTime = assembleFlatVector;
VectorAssembler.prototype.visitDecimal = assembleFlatVector;
VectorAssembler.prototype.visitList = assembleListVector;
VectorAssembler.prototype.visitStruct = assembleNestedVector;
VectorAssembler.prototype.visitUnion = assembleUnion;
VectorAssembler.prototype.visitInterval = assembleFlatVector;
VectorAssembler.prototype.visitDuration = assembleFlatVector;
VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
VectorAssembler.prototype.visitMap = assembleListVector; //# sourceMappingURL=vectorassembler.js.map
}),
"[project]/node_modules/apache-arrow/visitor/jsontypeassembler.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JSONTypeAssembler = void 0;
const visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/type.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
/** @ignore */ class JSONTypeAssembler extends visitor_js_1.Visitor {
    visit(node) {
        return node == null ? undefined : super.visit(node);
    }
    visitNull({ typeId }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase()
        };
    }
    visitInt({ typeId, bitWidth, isSigned }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'bitWidth': bitWidth,
            'isSigned': isSigned
        };
    }
    visitFloat({ typeId, precision }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'precision': enum_js_1.Precision[precision]
        };
    }
    visitBinary({ typeId }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase()
        };
    }
    visitLargeBinary({ typeId }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase()
        };
    }
    visitBool({ typeId }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase()
        };
    }
    visitUtf8({ typeId }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase()
        };
    }
    visitLargeUtf8({ typeId }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase()
        };
    }
    visitDecimal({ typeId, scale, precision, bitWidth }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'scale': scale,
            'precision': precision,
            'bitWidth': bitWidth
        };
    }
    visitDate({ typeId, unit }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'unit': enum_js_1.DateUnit[unit]
        };
    }
    visitTime({ typeId, unit, bitWidth }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'unit': enum_js_1.TimeUnit[unit],
            bitWidth
        };
    }
    visitTimestamp({ typeId, timezone, unit }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'unit': enum_js_1.TimeUnit[unit],
            timezone
        };
    }
    visitInterval({ typeId, unit }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'unit': enum_js_1.IntervalUnit[unit]
        };
    }
    visitDuration({ typeId, unit }) {
        return {
            'name': type_js_1.Type[typeId].toLocaleLowerCase(),
            'unit': enum_js_1.TimeUnit[unit]
        };
    }
    visitList({ typeId }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase()
        };
    }
    visitStruct({ typeId }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase()
        };
    }
    visitUnion({ typeId, mode, typeIds }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'mode': enum_js_1.UnionMode[mode].toUpperCase(),
            'typeIds': [
                ...typeIds
            ]
        };
    }
    visitDictionary(node) {
        return this.visit(node.dictionary);
    }
    visitFixedSizeBinary({ typeId, byteWidth }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'byteWidth': byteWidth
        };
    }
    visitFixedSizeList({ typeId, listSize }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'listSize': listSize
        };
    }
    visitMap({ typeId, keysSorted }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'keysSorted': keysSorted
        };
    }
}
exports.JSONTypeAssembler = JSONTypeAssembler; //# sourceMappingURL=jsontypeassembler.js.map
}),
"[project]/node_modules/apache-arrow/visitor/jsonvectorassembler.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JSONVectorAssembler = void 0;
const bn_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bn.js [app-ssr] (ecmascript)");
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const enum_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const bit_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bit.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
/** @ignore */ class JSONVectorAssembler extends visitor_js_1.Visitor {
    /** @nocollapse */ static assemble(...batches) {
        const assembler = new JSONVectorAssembler();
        return batches.map(({ schema, data })=>{
            return assembler.visitMany(schema.fields, data.children);
        });
    }
    visit({ name }, data) {
        const { length } = data;
        const { offset, nullCount, nullBitmap } = data;
        const type = type_js_1.DataType.isDictionary(data.type) ? data.type.indices : data.type;
        const buffers = Object.assign([], data.buffers, {
            [enum_js_1.BufferType.VALIDITY]: undefined
        });
        return Object.assign({
            'name': name,
            'count': length,
            'VALIDITY': type_js_1.DataType.isNull(type) || type_js_1.DataType.isUnion(type) ? undefined : nullCount <= 0 ? Array.from({
                length
            }, ()=>1) : [
                ...new bit_js_1.BitIterator(nullBitmap, offset, length, null, bit_js_1.getBit)
            ]
        }, super.visit(data.clone(type, offset, length, 0, buffers)));
    }
    visitNull() {
        return {};
    }
    visitBool({ values, offset, length }) {
        return {
            'DATA': [
                ...new bit_js_1.BitIterator(values, offset, length, null, bit_js_1.getBool)
            ]
        };
    }
    visitInt(data) {
        return {
            'DATA': data.type.bitWidth < 64 ? [
                ...data.values
            ] : [
                ...bigNumsToStrings(data.values, 2)
            ]
        };
    }
    visitFloat(data) {
        return {
            'DATA': [
                ...data.values
            ]
        };
    }
    visitUtf8(data) {
        return {
            'DATA': [
                ...new vector_js_1.Vector([
                    data
                ])
            ],
            'OFFSET': [
                ...data.valueOffsets
            ]
        };
    }
    visitLargeUtf8(data) {
        return {
            'DATA': [
                ...new vector_js_1.Vector([
                    data
                ])
            ],
            'OFFSET': [
                ...bigNumsToStrings(data.valueOffsets, 2)
            ]
        };
    }
    visitBinary(data) {
        return {
            'DATA': [
                ...binaryToString(new vector_js_1.Vector([
                    data
                ]))
            ],
            'OFFSET': [
                ...data.valueOffsets
            ]
        };
    }
    visitLargeBinary(data) {
        return {
            'DATA': [
                ...binaryToString(new vector_js_1.Vector([
                    data
                ]))
            ],
            'OFFSET': [
                ...bigNumsToStrings(data.valueOffsets, 2)
            ]
        };
    }
    visitFixedSizeBinary(data) {
        return {
            'DATA': [
                ...binaryToString(new vector_js_1.Vector([
                    data
                ]))
            ]
        };
    }
    visitDate(data) {
        return {
            'DATA': data.type.unit === enum_js_2.DateUnit.DAY ? [
                ...data.values
            ] : [
                ...bigNumsToStrings(data.values, 2)
            ]
        };
    }
    visitTimestamp(data) {
        return {
            'DATA': [
                ...bigNumsToStrings(data.values, 2)
            ]
        };
    }
    visitTime(data) {
        return {
            'DATA': data.type.unit < enum_js_2.TimeUnit.MICROSECOND ? [
                ...data.values
            ] : [
                ...bigNumsToStrings(data.values, 2)
            ]
        };
    }
    visitDecimal(data) {
        return {
            'DATA': [
                ...bigNumsToStrings(data.values, 4)
            ]
        };
    }
    visitList(data) {
        return {
            'OFFSET': [
                ...data.valueOffsets
            ],
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitStruct(data) {
        return {
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitUnion(data) {
        return {
            'TYPE_ID': [
                ...data.typeIds
            ],
            'OFFSET': data.type.mode === enum_js_2.UnionMode.Dense ? [
                ...data.valueOffsets
            ] : undefined,
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitInterval(data) {
        return {
            'DATA': [
                ...data.values
            ]
        };
    }
    visitDuration(data) {
        return {
            'DATA': [
                ...bigNumsToStrings(data.values, 2)
            ]
        };
    }
    visitFixedSizeList(data) {
        return {
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitMap(data) {
        return {
            'OFFSET': [
                ...data.valueOffsets
            ],
            'children': this.visitMany(data.type.children, data.children)
        };
    }
}
exports.JSONVectorAssembler = JSONVectorAssembler;
/** @ignore */ function* binaryToString(vector) {
    for (const octets of vector){
        yield octets.reduce((str, byte)=>{
            return `${str}${('0' + (byte & 0xFF).toString(16)).slice(-2)}`;
        }, '').toUpperCase();
    }
}
/** @ignore */ function* bigNumsToStrings(values, stride) {
    const u32s = new Uint32Array(values.buffer);
    for(let i = -1, n = u32s.length / stride; ++i < n;){
        yield `${bn_js_1.BN.new(u32s.subarray((i + 0) * stride, (i + 1) * stride), false)}`;
    }
} //# sourceMappingURL=jsonvectorassembler.js.map
}),
"[project]/node_modules/apache-arrow/ipc/writer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RecordBatchJSONWriter = exports.RecordBatchFileWriter = exports.RecordBatchStreamWriter = exports.RecordBatchWriter = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const table_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/table.js [app-ssr] (ecmascript)");
const message_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/message.js [app-ssr] (ecmascript)");
const vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
const type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
const message_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/metadata/message.js [app-ssr] (ecmascript)");
const metadata = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/metadata/message.js [app-ssr] (ecmascript)");
const file_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/metadata/file.js [app-ssr] (ecmascript)");
const enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
const typecomparator_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/typecomparator.js [app-ssr] (ecmascript)");
const stream_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/stream.js [app-ssr] (ecmascript)");
const vectorassembler_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/vectorassembler.js [app-ssr] (ecmascript)");
const jsontypeassembler_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/jsontypeassembler.js [app-ssr] (ecmascript)");
const jsonvectorassembler_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/jsonvectorassembler.js [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
const recordbatch_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/recordbatch.js [app-ssr] (ecmascript)");
const interfaces_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/interfaces.js [app-ssr] (ecmascript)");
const compat_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/compat.js [app-ssr] (ecmascript)");
class RecordBatchWriter extends interfaces_js_1.ReadableInterop {
    /** @nocollapse */ // @ts-ignore
    static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */ static throughDOM(// @ts-ignore
    writableStrategy, // @ts-ignore
    readableStrategy) {
        throw new Error(`"throughDOM" not available in this environment`);
    }
    constructor(options){
        super();
        this._position = 0;
        this._started = false;
        // @ts-ignore
        this._sink = new stream_js_1.AsyncByteQueue();
        this._schema = null;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._seenDictionaries = new Map();
        this._dictionaryDeltaOffsets = new Map();
        (0, compat_js_1.isObject)(options) || (options = {
            autoDestroy: true,
            writeLegacyIpcFormat: false
        });
        this._autoDestroy = typeof options.autoDestroy === 'boolean' ? options.autoDestroy : true;
        this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === 'boolean' ? options.writeLegacyIpcFormat : false;
    }
    toString(sync = false) {
        return this._sink.toString(sync);
    }
    toUint8Array(sync = false) {
        return this._sink.toUint8Array(sync);
    }
    writeAll(input) {
        if ((0, compat_js_1.isPromise)(input)) {
            return input.then((x)=>this.writeAll(x));
        } else if ((0, compat_js_1.isAsyncIterable)(input)) {
            return writeAllAsync(this, input);
        }
        return writeAll(this, input);
    }
    get closed() {
        return this._sink.closed;
    }
    [Symbol.asyncIterator]() {
        return this._sink[Symbol.asyncIterator]();
    }
    toDOMStream(options) {
        return this._sink.toDOMStream(options);
    }
    toNodeStream(options) {
        return this._sink.toNodeStream(options);
    }
    close() {
        return this.reset()._sink.close();
    }
    abort(reason) {
        return this.reset()._sink.abort(reason);
    }
    finish() {
        this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
        return this;
    }
    reset(sink = this._sink, schema = null) {
        if (sink === this._sink || sink instanceof stream_js_1.AsyncByteQueue) {
            this._sink = sink;
        } else {
            this._sink = new stream_js_1.AsyncByteQueue();
            if (sink && (0, compat_js_1.isWritableDOMStream)(sink)) {
                this.toDOMStream({
                    type: 'bytes'
                }).pipeTo(sink);
            } else if (sink && (0, compat_js_1.isWritableNodeStream)(sink)) {
                this.toNodeStream({
                    objectMode: false
                }).pipe(sink);
            }
        }
        if (this._started && this._schema) {
            this._writeFooter(this._schema);
        }
        this._started = false;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._seenDictionaries = new Map();
        this._dictionaryDeltaOffsets = new Map();
        if (!schema || !(0, typecomparator_js_1.compareSchemas)(schema, this._schema)) {
            if (schema == null) {
                this._position = 0;
                this._schema = null;
            } else {
                this._started = true;
                this._schema = schema;
                this._writeSchema(schema);
            }
        }
        return this;
    }
    write(payload) {
        let schema = null;
        if (!this._sink) {
            throw new Error(`RecordBatchWriter is closed`);
        } else if (payload == null) {
            return this.finish() && undefined;
        } else if (payload instanceof table_js_1.Table && !(schema = payload.schema)) {
            return this.finish() && undefined;
        } else if (payload instanceof recordbatch_js_1.RecordBatch && !(schema = payload.schema)) {
            return this.finish() && undefined;
        }
        if (schema && !(0, typecomparator_js_1.compareSchemas)(schema, this._schema)) {
            if (this._started && this._autoDestroy) {
                return this.close();
            }
            this.reset(this._sink, schema);
        }
        if (payload instanceof recordbatch_js_1.RecordBatch) {
            if (!(payload instanceof recordbatch_js_1._InternalEmptyPlaceholderRecordBatch)) {
                this._writeRecordBatch(payload);
            }
        } else if (payload instanceof table_js_1.Table) {
            this.writeAll(payload.batches);
        } else if ((0, compat_js_1.isIterable)(payload)) {
            this.writeAll(payload);
        }
    }
    _writeMessage(message, alignment = 8) {
        const a = alignment - 1;
        const buffer = message_js_2.Message.encode(message);
        const flatbufferSize = buffer.byteLength;
        const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
        const alignedSize = flatbufferSize + prefixSize + a & ~a;
        const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
        if (message.headerType === enum_js_1.MessageHeader.RecordBatch) {
            this._recordBatchBlocks.push(new file_js_1.FileBlock(alignedSize, message.bodyLength, this._position));
        } else if (message.headerType === enum_js_1.MessageHeader.DictionaryBatch) {
            this._dictionaryBlocks.push(new file_js_1.FileBlock(alignedSize, message.bodyLength, this._position));
        }
        // If not in legacy pre-0.15.0 mode, write the stream continuation indicator
        if (!this._writeLegacyIpcFormat) {
            this._write(Int32Array.of(-1));
        }
        // Write the flatbuffer size prefix including padding
        this._write(Int32Array.of(alignedSize - prefixSize));
        // Write the flatbuffer
        if (flatbufferSize > 0) {
            this._write(buffer);
        }
        // Write any padding
        return this._writePadding(nPaddingBytes);
    }
    _write(chunk) {
        if (this._started) {
            const buffer = (0, buffer_js_1.toUint8Array)(chunk);
            if (buffer && buffer.byteLength > 0) {
                this._sink.write(buffer);
                this._position += buffer.byteLength;
            }
        }
        return this;
    }
    _writeSchema(schema) {
        return this._writeMessage(message_js_2.Message.from(schema));
    }
    // @ts-ignore
    _writeFooter(schema) {
        // eos bytes
        return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
    }
    _writeMagic() {
        return this._write(message_js_1.MAGIC);
    }
    _writePadding(nBytes) {
        return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
    }
    _writeRecordBatch(batch) {
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_js_1.VectorAssembler.assemble(batch);
        const recordBatch = new metadata.RecordBatch(batch.numRows, nodes, bufferRegions);
        const message = message_js_2.Message.from(recordBatch, byteLength);
        return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_js_1.VectorAssembler.assemble(new vector_js_1.Vector([
            dictionary
        ]));
        const recordBatch = new metadata.RecordBatch(dictionary.length, nodes, bufferRegions);
        const dictionaryBatch = new metadata.DictionaryBatch(recordBatch, id, isDelta);
        const message = message_js_2.Message.from(dictionaryBatch, byteLength);
        return this._writeMessage(message)._writeBodyBuffers(buffers);
    }
    _writeBodyBuffers(buffers) {
        let buffer;
        let size, padding;
        for(let i = -1, n = buffers.length; ++i < n;){
            if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {
                this._write(buffer);
                if ((padding = (size + 7 & ~7) - size) > 0) {
                    this._writePadding(padding);
                }
            }
        }
        return this;
    }
    _writeDictionaries(batch) {
        var _a, _b;
        for (const [id, dictionary] of batch.dictionaries){
            const chunks = (_a = dictionary === null || dictionary === void 0 ? void 0 : dictionary.data) !== null && _a !== void 0 ? _a : [];
            const prevDictionary = this._seenDictionaries.get(id);
            const offset = (_b = this._dictionaryDeltaOffsets.get(id)) !== null && _b !== void 0 ? _b : 0;
            // * If no previous dictionary was written, write an initial DictionaryMessage.
            // * If the current dictionary does not share chunks with the previous dictionary, write a replacement DictionaryMessage.
            if (!prevDictionary || prevDictionary.data[0] !== chunks[0]) {
                // * If `index > 0`, then `isDelta` is true.
                // * If `index = 0`, then `isDelta` is false, because this is either the initial or a replacement DictionaryMessage.
                for (const [index, chunk] of chunks.entries())this._writeDictionaryBatch(chunk, id, index > 0);
            } else if (offset < chunks.length) {
                for (const chunk of chunks.slice(offset))this._writeDictionaryBatch(chunk, id, true);
            }
            this._seenDictionaries.set(id, dictionary);
            this._dictionaryDeltaOffsets.set(id, chunks.length);
        }
        return this;
    }
}
exports.RecordBatchWriter = RecordBatchWriter;
/** @ignore */ class RecordBatchStreamWriter extends RecordBatchWriter {
    /** @nocollapse */ static writeAll(input, options) {
        const writer = new RecordBatchStreamWriter(options);
        if ((0, compat_js_1.isPromise)(input)) {
            return input.then((x)=>writer.writeAll(x));
        } else if ((0, compat_js_1.isAsyncIterable)(input)) {
            return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
    }
}
exports.RecordBatchStreamWriter = RecordBatchStreamWriter;
/** @ignore */ class RecordBatchFileWriter extends RecordBatchWriter {
    /** @nocollapse */ static writeAll(input) {
        const writer = new RecordBatchFileWriter();
        if ((0, compat_js_1.isPromise)(input)) {
            return input.then((x)=>writer.writeAll(x));
        } else if ((0, compat_js_1.isAsyncIterable)(input)) {
            return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
    }
    constructor(){
        super();
        this._autoDestroy = true;
    }
    // @ts-ignore
    _writeSchema(schema) {
        return this._writeMagic()._writePadding(2);
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
        if (!isDelta && this._seenDictionaries.has(id)) {
            throw new Error('The Arrow File format does not support replacement dictionaries. ');
        }
        return super._writeDictionaryBatch(dictionary, id, isDelta);
    }
    _writeFooter(schema) {
        const buffer = file_js_1.Footer.encode(new file_js_1.Footer(schema, enum_js_1.MetadataVersion.V5, this._recordBatchBlocks, this._dictionaryBlocks));
        return super._writeFooter(schema) // EOS bytes for sequential readers
        ._write(buffer) // Write the flatbuffer
        ._write(Int32Array.of(buffer.byteLength)) // then the footer size suffix
        ._writeMagic(); // then the magic suffix
    }
}
exports.RecordBatchFileWriter = RecordBatchFileWriter;
/** @ignore */ class RecordBatchJSONWriter extends RecordBatchWriter {
    /** @nocollapse */ static writeAll(input) {
        return new RecordBatchJSONWriter().writeAll(input);
    }
    constructor(){
        super();
        this._autoDestroy = true;
        this._recordBatches = [];
        this._recordBatchesWithDictionaries = [];
    }
    _writeMessage() {
        return this;
    }
    // @ts-ignore
    _writeFooter(schema) {
        return this;
    }
    _writeSchema(schema) {
        return this._write(`{\n  "schema": ${JSON.stringify({
            fields: schema.fields.map((field)=>fieldToJSON(field))
        }, null, 2)}`);
    }
    _writeDictionaries(batch) {
        if (batch.dictionaries.size > 0) {
            this._recordBatchesWithDictionaries.push(batch);
        }
        return this;
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
        this._write(this._dictionaryBlocks.length === 0 ? `    ` : `,\n    `);
        this._write(dictionaryBatchToJSON(dictionary, id, isDelta));
        this._dictionaryBlocks.push(new file_js_1.FileBlock(0, 0, 0));
        return this;
    }
    _writeRecordBatch(batch) {
        this._writeDictionaries(batch);
        this._recordBatches.push(batch);
        return this;
    }
    close() {
        if (this._recordBatchesWithDictionaries.length > 0) {
            this._write(`,\n  "dictionaries": [\n`);
            for (const batch of this._recordBatchesWithDictionaries){
                super._writeDictionaries(batch);
            }
            this._write(`\n  ]`);
        }
        if (this._recordBatches.length > 0) {
            for(let i = -1, n = this._recordBatches.length; ++i < n;){
                this._write(i === 0 ? `,\n  "batches": [\n    ` : `,\n    `);
                this._write(recordBatchToJSON(this._recordBatches[i]));
                this._recordBatchBlocks.push(new file_js_1.FileBlock(0, 0, 0));
            }
            this._write(`\n  ]`);
        }
        if (this._schema) {
            this._write(`\n}`);
        }
        this._recordBatchesWithDictionaries = [];
        this._recordBatches = [];
        return super.close();
    }
}
exports.RecordBatchJSONWriter = RecordBatchJSONWriter;
/** @ignore */ function writeAll(writer, input) {
    let chunks = input;
    if (input instanceof table_js_1.Table) {
        chunks = input.batches;
        writer.reset(undefined, input.schema);
    }
    for (const batch of chunks){
        writer.write(batch);
    }
    return writer.finish();
}
/** @ignore */ function writeAllAsync(writer, batches) {
    return tslib_1.__awaiter(this, void 0, void 0, function*() {
        var _a, batches_1, batches_1_1;
        var _b, e_1, _c, _d;
        try {
            for(_a = true, batches_1 = tslib_1.__asyncValues(batches); batches_1_1 = yield batches_1.next(), _b = batches_1_1.done, !_b; _a = true){
                _d = batches_1_1.value;
                _a = false;
                const batch = _d;
                writer.write(batch);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (!_a && !_b && (_c = batches_1.return)) yield _c.call(batches_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        return writer.finish();
    });
}
/** @ignore */ function fieldToJSON({ name, type, nullable }) {
    const assembler = new jsontypeassembler_js_1.JSONTypeAssembler();
    return {
        'name': name,
        'nullable': nullable,
        'type': assembler.visit(type),
        'children': (type.children || []).map((field)=>fieldToJSON(field)),
        'dictionary': !type_js_1.DataType.isDictionary(type) ? undefined : {
            'id': type.id,
            'isOrdered': type.isOrdered,
            'indexType': assembler.visit(type.indices)
        }
    };
}
/** @ignore */ function dictionaryBatchToJSON(dictionary, id, isDelta = false) {
    const [columns] = jsonvectorassembler_js_1.JSONVectorAssembler.assemble(new recordbatch_js_1.RecordBatch({
        [id]: dictionary
    }));
    return JSON.stringify({
        'id': id,
        'isDelta': isDelta,
        'data': {
            'count': dictionary.length,
            'columns': columns
        }
    }, null, 2);
}
/** @ignore */ function recordBatchToJSON(records) {
    const [columns] = jsonvectorassembler_js_1.JSONVectorAssembler.assemble(records);
    return JSON.stringify({
        'count': records.numRows,
        'columns': columns
    }, null, 2);
} //# sourceMappingURL=writer.js.map
}),
"[project]/node_modules/apache-arrow/io/node/iterable.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toNodeStream = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const compat_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/compat.js [app-ssr] (ecmascript)");
/** @ignore */ function toNodeStream(source, options) {
    if ((0, compat_js_1.isAsyncIterable)(source)) {
        return new AsyncIterableReadable(source[Symbol.asyncIterator](), options);
    }
    if ((0, compat_js_1.isIterable)(source)) {
        return new IterableReadable(source[Symbol.iterator](), options);
    }
    /* istanbul ignore next */ throw new Error(`toNodeStream() must be called with an Iterable or AsyncIterable`);
}
exports.toNodeStream = toNodeStream;
/** @ignore */ class IterableReadable extends node_stream_1.Readable {
    constructor(it, options){
        super(options);
        this._iterator = it;
        this._pulling = false;
        this._bytesMode = !options || !options.objectMode;
    }
    _read(size) {
        const it = this._iterator;
        if (it && !this._pulling && (this._pulling = true)) {
            this._pulling = this._pull(size, it);
        }
    }
    _destroy(e, cb) {
        const it = this._iterator;
        let fn;
        it && (fn = e != null && it.throw || it.return);
        fn === null || fn === void 0 ? void 0 : fn.call(it, e);
        cb && cb(null);
    }
    _pull(size, it) {
        const bm = this._bytesMode;
        let r = null;
        while(this.readable && !(r = it.next(bm ? size : null)).done){
            if (size != null) {
                size -= bm && ArrayBuffer.isView(r.value) ? r.value.byteLength : 1;
            }
            if (!this.push(r.value) || size <= 0) {
                break;
            }
        }
        if (((r === null || r === void 0 ? void 0 : r.done) || !this.readable) && (this.push(null) || true)) {
            it.return && it.return();
        }
        return !this.readable;
    }
}
/** @ignore */ class AsyncIterableReadable extends node_stream_1.Readable {
    constructor(it, options){
        super(options);
        this._iterator = it;
        this._pulling = false;
        this._bytesMode = !options || !options.objectMode;
    }
    _read(size) {
        const it = this._iterator;
        if (it && !this._pulling && (this._pulling = true)) {
            (()=>tslib_1.__awaiter(this, void 0, void 0, function*() {
                    return this._pulling = yield this._pull(size, it);
                }))();
        }
    }
    _destroy(e, cb) {
        const it = this._iterator;
        let fn;
        it && (fn = e != null && it.throw || it.return);
        (fn === null || fn === void 0 ? void 0 : fn.call(it, e).then(()=>cb && cb(null))) || cb && cb(null);
    }
    _pull(size, it) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            const bm = this._bytesMode;
            let r = null;
            while(this.readable && !(r = yield it.next(bm ? size : null)).done){
                if (size != null) {
                    size -= bm && ArrayBuffer.isView(r.value) ? r.value.byteLength : 1;
                }
                if (!this.push(r.value) || size <= 0) {
                    break;
                }
            }
            if (((r === null || r === void 0 ? void 0 : r.done) || !this.readable) && (this.push(null) || true)) {
                it.return && it.return();
            }
            return !this.readable;
        });
    }
} //# sourceMappingURL=iterable.js.map
}),
"[project]/node_modules/apache-arrow/io/node/builder.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.builderThroughNodeStream = void 0;
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const factories_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/factories.js [app-ssr] (ecmascript)");
/** @ignore */ function builderThroughNodeStream(options) {
    return new BuilderDuplex((0, factories_js_1.makeBuilder)(options), options);
}
exports.builderThroughNodeStream = builderThroughNodeStream;
/** @ignore */ class BuilderDuplex extends node_stream_1.Duplex {
    constructor(builder, options){
        const { queueingStrategy = 'count', autoDestroy = true } = options;
        const { highWaterMark = queueingStrategy !== 'bytes' ? 1000 : Math.pow(2, 14) } = options;
        super({
            autoDestroy,
            highWaterMark: 1,
            allowHalfOpen: true,
            writableObjectMode: true,
            readableObjectMode: true
        });
        this._numChunks = 0;
        this._finished = false;
        this._builder = builder;
        this._desiredSize = highWaterMark;
        this._getSize = queueingStrategy !== 'bytes' ? builderLength : builderByteLength;
    }
    _read(size) {
        this._maybeFlush(this._builder, this._desiredSize = size);
    }
    _final(cb) {
        this._maybeFlush(this._builder.finish(), this._desiredSize);
        cb && cb();
    }
    _write(value, _, cb) {
        const result = this._maybeFlush(this._builder.append(value), this._desiredSize);
        cb && cb();
        return result;
    }
    _destroy(err, cb) {
        this._builder.clear();
        cb && cb(err);
    }
    _maybeFlush(builder, size) {
        if (this._getSize(builder) >= size) {
            ++this._numChunks && this.push(builder.toVector());
        }
        if (builder.finished) {
            if (builder.length > 0 || this._numChunks === 0) {
                ++this._numChunks && this.push(builder.toVector());
            }
            if (!this._finished && (this._finished = true)) {
                this.push(null);
            }
            return false;
        }
        return this._getSize(builder) < this.writableHighWaterMark;
    }
}
/** @ignore */ const builderLength = (builder)=>builder.length;
/** @ignore */ const builderByteLength = (builder)=>builder.byteLength; //# sourceMappingURL=builder.js.map
}),
"[project]/node_modules/apache-arrow/io/node/reader.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.recordBatchReaderThroughNodeStream = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const stream_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/stream.js [app-ssr] (ecmascript)");
const reader_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/reader.js [app-ssr] (ecmascript)");
/** @ignore */ function recordBatchReaderThroughNodeStream(options) {
    return new RecordBatchReaderDuplex(options);
}
exports.recordBatchReaderThroughNodeStream = recordBatchReaderThroughNodeStream;
/** @ignore */ class RecordBatchReaderDuplex extends node_stream_1.Duplex {
    constructor(options){
        super(Object.assign(Object.assign({
            allowHalfOpen: false
        }, options), {
            readableObjectMode: true,
            writableObjectMode: false
        }));
        this._pulling = false;
        this._autoDestroy = true;
        this._reader = null;
        this._pulling = false;
        this._asyncQueue = new stream_js_1.AsyncByteQueue();
        this._autoDestroy = options && typeof options.autoDestroy === 'boolean' ? options.autoDestroy : true;
    }
    _final(cb) {
        const aq = this._asyncQueue;
        aq === null || aq === void 0 ? void 0 : aq.close();
        cb && cb();
    }
    _write(x, _, cb) {
        const aq = this._asyncQueue;
        aq === null || aq === void 0 ? void 0 : aq.write(x);
        cb && cb();
        return true;
    }
    _read(size) {
        const aq = this._asyncQueue;
        if (aq && !this._pulling && (this._pulling = true)) {
            (()=>tslib_1.__awaiter(this, void 0, void 0, function*() {
                    if (!this._reader) {
                        this._reader = yield this._open(aq);
                    }
                    this._pulling = yield this._pull(size, this._reader);
                }))();
        }
    }
    _destroy(err, cb) {
        const aq = this._asyncQueue;
        if (aq) {
            err ? aq.abort(err) : aq.close();
        }
        cb(this._asyncQueue = this._reader = null);
    }
    _open(source) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            return yield (yield reader_js_1.RecordBatchReader.from(source)).open({
                autoDestroy: this._autoDestroy
            });
        });
    }
    _pull(size, reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            let r = null;
            while(this.readable && !(r = yield reader.next()).done){
                if (!this.push(r.value) || size != null && --size <= 0) {
                    break;
                }
            }
            if (!this.readable || (r === null || r === void 0 ? void 0 : r.done) && (reader.autoDestroy || (yield reader.reset().open()).closed)) {
                this.push(null);
                yield reader.cancel();
            }
            return !this.readable;
        });
    }
} //# sourceMappingURL=reader.js.map
}),
"[project]/node_modules/apache-arrow/io/node/writer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.recordBatchWriterThroughNodeStream = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const stream_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/stream.js [app-ssr] (ecmascript)");
/** @ignore */ function recordBatchWriterThroughNodeStream(options) {
    return new RecordBatchWriterDuplex(new this(options));
}
exports.recordBatchWriterThroughNodeStream = recordBatchWriterThroughNodeStream;
/** @ignore */ class RecordBatchWriterDuplex extends node_stream_1.Duplex {
    constructor(writer, options){
        super(Object.assign(Object.assign({
            allowHalfOpen: false
        }, options), {
            writableObjectMode: true,
            readableObjectMode: false
        }));
        this._pulling = false;
        this._writer = writer;
        this._reader = new stream_js_1.AsyncByteStream(writer);
    }
    _final(cb) {
        const writer = this._writer;
        writer === null || writer === void 0 ? void 0 : writer.close();
        cb && cb();
    }
    _write(x, _, cb) {
        const writer = this._writer;
        writer === null || writer === void 0 ? void 0 : writer.write(x);
        cb && cb();
        return true;
    }
    _read(size) {
        const it = this._reader;
        if (it && !this._pulling && (this._pulling = true)) {
            (()=>tslib_1.__awaiter(this, void 0, void 0, function*() {
                    return this._pulling = yield this._pull(size, it);
                }))();
        }
    }
    _destroy(err, cb) {
        const writer = this._writer;
        if (writer) {
            err ? writer.abort(err) : writer.close();
        }
        cb(this._reader = this._writer = null);
    }
    _pull(size, reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            let r = null;
            while(this.readable && !(r = yield reader.next(size || null)).done){
                if (size != null && r.value) {
                    size -= r.value.byteLength;
                }
                if (!this.push(r.value) || size <= 0) {
                    break;
                }
            }
            if ((r === null || r === void 0 ? void 0 : r.done) || !this.readable) {
                this.push(null);
                yield reader.cancel();
            }
            return !this.readable;
        });
    }
} //# sourceMappingURL=writer.js.map
}),
"[project]/node_modules/apache-arrow/io/whatwg/iterable.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toDOMStream = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const buffer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
const compat_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/compat.js [app-ssr] (ecmascript)");
/** @ignore */ function toDOMStream(source, options) {
    if ((0, compat_js_1.isAsyncIterable)(source)) {
        return asyncIterableAsReadableDOMStream(source, options);
    }
    if ((0, compat_js_1.isIterable)(source)) {
        return iterableAsReadableDOMStream(source, options);
    }
    /* istanbul ignore next */ throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
}
exports.toDOMStream = toDOMStream;
/** @ignore */ function iterableAsReadableDOMStream(source, options) {
    let it = null;
    const bm = (options === null || options === void 0 ? void 0 : options.type) === 'bytes' || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
    return new ReadableStream(Object.assign(Object.assign({}, options), {
        start (controller) {
            next(controller, it || (it = source[Symbol.iterator]()));
        },
        pull (controller) {
            it ? next(controller, it) : controller.close();
        },
        cancel () {
            ((it === null || it === void 0 ? void 0 : it.return) && it.return() || true) && (it = null);
        }
    }), Object.assign({
        highWaterMark: bm ? hwm : undefined
    }, options));
    //TURBOPACK unreachable
    ;
    function next(controller, it) {
        let buf;
        let r = null;
        let size = controller.desiredSize || null;
        while(!(r = it.next(bm ? size : null)).done){
            if (ArrayBuffer.isView(r.value) && (buf = (0, buffer_js_1.toUint8Array)(r.value))) {
                size != null && bm && (size = size - buf.byteLength + 1);
                r.value = buf;
            }
            controller.enqueue(r.value);
            if (size != null && --size <= 0) {
                return;
            }
        }
        controller.close();
    }
}
/** @ignore */ function asyncIterableAsReadableDOMStream(source, options) {
    let it = null;
    const bm = (options === null || options === void 0 ? void 0 : options.type) === 'bytes' || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
    return new ReadableStream(Object.assign(Object.assign({}, options), {
        start (controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function*() {
                yield next(controller, it || (it = source[Symbol.asyncIterator]()));
            });
        },
        pull (controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function*() {
                it ? yield next(controller, it) : controller.close();
            });
        },
        cancel () {
            return tslib_1.__awaiter(this, void 0, void 0, function*() {
                ((it === null || it === void 0 ? void 0 : it.return) && (yield it.return()) || true) && (it = null);
            });
        }
    }), Object.assign({
        highWaterMark: bm ? hwm : undefined
    }, options));
    //TURBOPACK unreachable
    ;
    function next(controller, it) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            let buf;
            let r = null;
            let size = controller.desiredSize || null;
            while(!(r = yield it.next(bm ? size : null)).done){
                if (ArrayBuffer.isView(r.value) && (buf = (0, buffer_js_1.toUint8Array)(r.value))) {
                    size != null && bm && (size = size - buf.byteLength + 1);
                    r.value = buf;
                }
                controller.enqueue(r.value);
                if (size != null && --size <= 0) {
                    return;
                }
            }
            controller.close();
        });
    }
} //# sourceMappingURL=iterable.js.map
}),
"[project]/node_modules/apache-arrow/io/whatwg/builder.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BuilderTransform = exports.builderThroughDOMStream = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const factories_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/factories.js [app-ssr] (ecmascript)");
/** @ignore */ function builderThroughDOMStream(options) {
    return new BuilderTransform(options);
}
exports.builderThroughDOMStream = builderThroughDOMStream;
/** @ignore */ class BuilderTransform {
    constructor(options){
        // Access properties by string indexers to defeat closure compiler
        this._numChunks = 0;
        this._finished = false;
        this._bufferedSize = 0;
        const { ['readableStrategy']: readableStrategy, ['writableStrategy']: writableStrategy, ['queueingStrategy']: queueingStrategy = 'count' } = options, builderOptions = tslib_1.__rest(options, [
            'readableStrategy',
            'writableStrategy',
            'queueingStrategy'
        ]);
        this._controller = null;
        this._builder = (0, factories_js_1.makeBuilder)(builderOptions);
        this._getSize = queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength;
        const { ['highWaterMark']: readableHighWaterMark = queueingStrategy === 'bytes' ? Math.pow(2, 14) : 1000 } = Object.assign({}, readableStrategy);
        const { ['highWaterMark']: writableHighWaterMark = queueingStrategy === 'bytes' ? Math.pow(2, 14) : 1000 } = Object.assign({}, writableStrategy);
        this['readable'] = new ReadableStream({
            ['cancel']: ()=>{
                this._builder.clear();
            },
            ['pull']: (c)=>{
                this._maybeFlush(this._builder, this._controller = c);
            },
            ['start']: (c)=>{
                this._maybeFlush(this._builder, this._controller = c);
            }
        }, {
            'highWaterMark': readableHighWaterMark,
            'size': queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength
        });
        this['writable'] = new WritableStream({
            ['abort']: ()=>{
                this._builder.clear();
            },
            ['write']: ()=>{
                this._maybeFlush(this._builder, this._controller);
            },
            ['close']: ()=>{
                this._maybeFlush(this._builder.finish(), this._controller);
            }
        }, {
            'highWaterMark': writableHighWaterMark,
            'size': (value)=>this._writeValueAndReturnChunkSize(value)
        });
    }
    _writeValueAndReturnChunkSize(value) {
        const bufferedSize = this._bufferedSize;
        this._bufferedSize = this._getSize(this._builder.append(value));
        return this._bufferedSize - bufferedSize;
    }
    _maybeFlush(builder, controller) {
        if (controller == null) {
            return;
        }
        if (this._bufferedSize >= controller.desiredSize) {
            ++this._numChunks && this._enqueue(controller, builder.toVector());
        }
        if (builder.finished) {
            if (builder.length > 0 || this._numChunks === 0) {
                ++this._numChunks && this._enqueue(controller, builder.toVector());
            }
            if (!this._finished && (this._finished = true)) {
                this._enqueue(controller, null);
            }
        }
    }
    _enqueue(controller, chunk) {
        this._bufferedSize = 0;
        this._controller = null;
        chunk == null ? controller.close() : controller.enqueue(chunk);
    }
}
exports.BuilderTransform = BuilderTransform;
/** @ignore */ const chunkLength = (chunk)=>{
    var _a;
    return (_a = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a !== void 0 ? _a : 0;
};
/** @ignore */ const chunkByteLength = (chunk)=>{
    var _a;
    return (_a = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a !== void 0 ? _a : 0;
}; //# sourceMappingURL=builder.js.map
}),
"[project]/node_modules/apache-arrow/io/whatwg/reader.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.recordBatchReaderThroughDOMStream = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const stream_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/stream.js [app-ssr] (ecmascript)");
const reader_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/reader.js [app-ssr] (ecmascript)");
/** @ignore */ function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
    const queue = new stream_js_1.AsyncByteQueue();
    let reader = null;
    const readable = new ReadableStream({
        cancel () {
            return tslib_1.__awaiter(this, void 0, void 0, function*() {
                yield queue.close();
            });
        },
        start (controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function*() {
                yield next(controller, reader || (reader = yield open()));
            });
        },
        pull (controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function*() {
                reader ? yield next(controller, reader) : controller.close();
            });
        }
    });
    return {
        writable: new WritableStream(queue, Object.assign({
            'highWaterMark': Math.pow(2, 14)
        }, writableStrategy)),
        readable
    };
    //TURBOPACK unreachable
    ;
    function open() {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            return yield (yield reader_js_1.RecordBatchReader.from(queue)).open(readableStrategy);
        });
    }
    function next(controller, reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            let size = controller.desiredSize;
            let r = null;
            while(!(r = yield reader.next()).done){
                controller.enqueue(r.value);
                if (size != null && --size <= 0) {
                    return;
                }
            }
            controller.close();
        });
    }
}
exports.recordBatchReaderThroughDOMStream = recordBatchReaderThroughDOMStream; //# sourceMappingURL=reader.js.map
}),
"[project]/node_modules/apache-arrow/io/whatwg/writer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.recordBatchWriterThroughDOMStream = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const stream_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/stream.js [app-ssr] (ecmascript)");
/** @ignore */ function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
    const writer = new this(writableStrategy);
    const reader = new stream_js_1.AsyncByteStream(writer);
    const readable = new ReadableStream({
        // type: 'bytes',
        cancel () {
            return tslib_1.__awaiter(this, void 0, void 0, function*() {
                yield reader.cancel();
            });
        },
        pull (controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function*() {
                yield next(controller);
            });
        },
        start (controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function*() {
                yield next(controller);
            });
        }
    }, Object.assign({
        'highWaterMark': Math.pow(2, 14)
    }, readableStrategy));
    return {
        writable: new WritableStream(writer, writableStrategy),
        readable
    };
    //TURBOPACK unreachable
    ;
    function next(controller) {
        return tslib_1.__awaiter(this, void 0, void 0, function*() {
            let buf = null;
            let size = controller.desiredSize;
            while(buf = yield reader.read(size || null)){
                controller.enqueue(buf);
                if (size != null && (size -= buf.byteLength) <= 0) {
                    return;
                }
            }
            controller.close();
        });
    }
}
exports.recordBatchWriterThroughDOMStream = recordBatchWriterThroughDOMStream; //# sourceMappingURL=writer.js.map
}),
"[project]/node_modules/apache-arrow/ipc/serialization.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tableToIPC = exports.tableFromIPC = void 0;
const table_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/table.js [app-ssr] (ecmascript)");
const compat_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/compat.js [app-ssr] (ecmascript)");
const reader_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/reader.js [app-ssr] (ecmascript)");
const writer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/writer.js [app-ssr] (ecmascript)");
function tableFromIPC(input) {
    const reader = reader_js_1.RecordBatchReader.from(input);
    if ((0, compat_js_1.isPromise)(reader)) {
        return reader.then((reader)=>tableFromIPC(reader));
    }
    if (reader.isAsync()) {
        return reader.readAll().then((xs)=>new table_js_1.Table(xs));
    }
    return new table_js_1.Table(reader.readAll());
}
exports.tableFromIPC = tableFromIPC;
/**
 * Serialize a {@link Table} to the IPC format. This function is a convenience
 * wrapper for {@link RecordBatchStreamWriter} and {@link RecordBatchFileWriter}.
 * Opposite of {@link tableFromIPC}.
 *
 * @param table The Table to serialize.
 * @param type Whether to serialize the Table as a file or a stream.
 */ function tableToIPC(table, type = 'stream') {
    return (type === 'stream' ? writer_js_1.RecordBatchStreamWriter : writer_js_1.RecordBatchFileWriter).writeAll(table).toUint8Array(true);
}
exports.tableToIPC = tableToIPC; //# sourceMappingURL=serialization.js.map
}),
"[project]/node_modules/apache-arrow/Arrow.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DenseUnion = exports.Union = exports.Struct = exports.List = exports.Decimal = exports.TimeNanosecond = exports.TimeMicrosecond = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.DateMillisecond = exports.DateDay = exports.Date_ = exports.FixedSizeBinary = exports.LargeBinary = exports.Binary = exports.LargeUtf8 = exports.Utf8 = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Bool = exports.Null = exports.DataType = exports.makeData = exports.Data = exports.MetadataVersion = exports.IntervalUnit = exports.UnionMode = exports.Precision = exports.TimeUnit = exports.DateUnit = exports.BufferType = exports.Type = exports.MessageHeader = void 0;
exports.TimeBuilder = exports.Uint64Builder = exports.Uint32Builder = exports.Uint16Builder = exports.Uint8Builder = exports.Int64Builder = exports.Int32Builder = exports.Int16Builder = exports.Int8Builder = exports.IntBuilder = exports.Float64Builder = exports.Float32Builder = exports.Float16Builder = exports.FloatBuilder = exports.FixedSizeBinaryBuilder = exports.DictionaryBuilder = exports.DecimalBuilder = exports.DateMillisecondBuilder = exports.DateDayBuilder = exports.DateBuilder = exports.NullBuilder = exports.BoolBuilder = exports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.tableFromJSON = exports.vectorFromArray = exports.makeBuilder = exports.Builder = exports.StructRow = exports.MapRow = exports.Field = exports.Schema = exports.Visitor = exports.makeVector = exports.Vector = exports.tableFromArrays = exports.makeTable = exports.Table = exports.Map_ = exports.FixedSizeList = exports.DurationNanosecond = exports.DurationMicrosecond = exports.DurationMillisecond = exports.DurationSecond = exports.Duration = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.Dictionary = exports.SparseUnion = void 0;
exports.util = exports.RecordBatch = exports.Message = exports.JSONMessageReader = exports.AsyncMessageReader = exports.MessageReader = exports.tableFromIPC = exports.tableToIPC = exports.RecordBatchJSONWriter = exports.RecordBatchStreamWriter = exports.RecordBatchFileWriter = exports.RecordBatchWriter = exports.AsyncRecordBatchStreamReader = exports.AsyncRecordBatchFileReader = exports.RecordBatchStreamReader = exports.RecordBatchFileReader = exports.RecordBatchReader = exports.AsyncByteQueue = exports.AsyncByteStream = exports.ByteStream = exports.DenseUnionBuilder = exports.SparseUnionBuilder = exports.UnionBuilder = exports.StructBuilder = exports.MapBuilder = exports.FixedSizeListBuilder = exports.ListBuilder = exports.LargeBinaryBuilder = exports.BinaryBuilder = exports.LargeUtf8Builder = exports.Utf8Builder = exports.DurationNanosecondBuilder = exports.DurationMicrosecondBuilder = exports.DurationMillisecondBuilder = exports.DurationSecondBuilder = exports.DurationBuilder = exports.IntervalYearMonthBuilder = exports.IntervalDayTimeBuilder = exports.IntervalBuilder = exports.TimestampNanosecondBuilder = exports.TimestampMicrosecondBuilder = exports.TimestampMillisecondBuilder = exports.TimestampSecondBuilder = exports.TimestampBuilder = exports.TimeNanosecondBuilder = exports.TimeMicrosecondBuilder = exports.TimeMillisecondBuilder = exports.TimeSecondBuilder = void 0;
var message_header_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/fb/message-header.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "MessageHeader", {
    enumerable: true,
    get: function() {
        return message_header_js_1.MessageHeader;
    }
});
var enum_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/enum.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Type", {
    enumerable: true,
    get: function() {
        return enum_js_1.Type;
    }
});
Object.defineProperty(exports, "BufferType", {
    enumerable: true,
    get: function() {
        return enum_js_1.BufferType;
    }
});
Object.defineProperty(exports, "DateUnit", {
    enumerable: true,
    get: function() {
        return enum_js_1.DateUnit;
    }
});
Object.defineProperty(exports, "TimeUnit", {
    enumerable: true,
    get: function() {
        return enum_js_1.TimeUnit;
    }
});
Object.defineProperty(exports, "Precision", {
    enumerable: true,
    get: function() {
        return enum_js_1.Precision;
    }
});
Object.defineProperty(exports, "UnionMode", {
    enumerable: true,
    get: function() {
        return enum_js_1.UnionMode;
    }
});
Object.defineProperty(exports, "IntervalUnit", {
    enumerable: true,
    get: function() {
        return enum_js_1.IntervalUnit;
    }
});
Object.defineProperty(exports, "MetadataVersion", {
    enumerable: true,
    get: function() {
        return enum_js_1.MetadataVersion;
    }
});
var data_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/data.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Data", {
    enumerable: true,
    get: function() {
        return data_js_1.Data;
    }
});
Object.defineProperty(exports, "makeData", {
    enumerable: true,
    get: function() {
        return data_js_1.makeData;
    }
});
var type_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/type.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "DataType", {
    enumerable: true,
    get: function() {
        return type_js_1.DataType;
    }
});
Object.defineProperty(exports, "Null", {
    enumerable: true,
    get: function() {
        return type_js_1.Null;
    }
});
Object.defineProperty(exports, "Bool", {
    enumerable: true,
    get: function() {
        return type_js_1.Bool;
    }
});
Object.defineProperty(exports, "Int", {
    enumerable: true,
    get: function() {
        return type_js_1.Int;
    }
});
Object.defineProperty(exports, "Int8", {
    enumerable: true,
    get: function() {
        return type_js_1.Int8;
    }
});
Object.defineProperty(exports, "Int16", {
    enumerable: true,
    get: function() {
        return type_js_1.Int16;
    }
});
Object.defineProperty(exports, "Int32", {
    enumerable: true,
    get: function() {
        return type_js_1.Int32;
    }
});
Object.defineProperty(exports, "Int64", {
    enumerable: true,
    get: function() {
        return type_js_1.Int64;
    }
});
Object.defineProperty(exports, "Uint8", {
    enumerable: true,
    get: function() {
        return type_js_1.Uint8;
    }
});
Object.defineProperty(exports, "Uint16", {
    enumerable: true,
    get: function() {
        return type_js_1.Uint16;
    }
});
Object.defineProperty(exports, "Uint32", {
    enumerable: true,
    get: function() {
        return type_js_1.Uint32;
    }
});
Object.defineProperty(exports, "Uint64", {
    enumerable: true,
    get: function() {
        return type_js_1.Uint64;
    }
});
Object.defineProperty(exports, "Float", {
    enumerable: true,
    get: function() {
        return type_js_1.Float;
    }
});
Object.defineProperty(exports, "Float16", {
    enumerable: true,
    get: function() {
        return type_js_1.Float16;
    }
});
Object.defineProperty(exports, "Float32", {
    enumerable: true,
    get: function() {
        return type_js_1.Float32;
    }
});
Object.defineProperty(exports, "Float64", {
    enumerable: true,
    get: function() {
        return type_js_1.Float64;
    }
});
Object.defineProperty(exports, "Utf8", {
    enumerable: true,
    get: function() {
        return type_js_1.Utf8;
    }
});
Object.defineProperty(exports, "LargeUtf8", {
    enumerable: true,
    get: function() {
        return type_js_1.LargeUtf8;
    }
});
Object.defineProperty(exports, "Binary", {
    enumerable: true,
    get: function() {
        return type_js_1.Binary;
    }
});
Object.defineProperty(exports, "LargeBinary", {
    enumerable: true,
    get: function() {
        return type_js_1.LargeBinary;
    }
});
Object.defineProperty(exports, "FixedSizeBinary", {
    enumerable: true,
    get: function() {
        return type_js_1.FixedSizeBinary;
    }
});
Object.defineProperty(exports, "Date_", {
    enumerable: true,
    get: function() {
        return type_js_1.Date_;
    }
});
Object.defineProperty(exports, "DateDay", {
    enumerable: true,
    get: function() {
        return type_js_1.DateDay;
    }
});
Object.defineProperty(exports, "DateMillisecond", {
    enumerable: true,
    get: function() {
        return type_js_1.DateMillisecond;
    }
});
Object.defineProperty(exports, "Timestamp", {
    enumerable: true,
    get: function() {
        return type_js_1.Timestamp;
    }
});
Object.defineProperty(exports, "TimestampSecond", {
    enumerable: true,
    get: function() {
        return type_js_1.TimestampSecond;
    }
});
Object.defineProperty(exports, "TimestampMillisecond", {
    enumerable: true,
    get: function() {
        return type_js_1.TimestampMillisecond;
    }
});
Object.defineProperty(exports, "TimestampMicrosecond", {
    enumerable: true,
    get: function() {
        return type_js_1.TimestampMicrosecond;
    }
});
Object.defineProperty(exports, "TimestampNanosecond", {
    enumerable: true,
    get: function() {
        return type_js_1.TimestampNanosecond;
    }
});
Object.defineProperty(exports, "Time", {
    enumerable: true,
    get: function() {
        return type_js_1.Time;
    }
});
Object.defineProperty(exports, "TimeSecond", {
    enumerable: true,
    get: function() {
        return type_js_1.TimeSecond;
    }
});
Object.defineProperty(exports, "TimeMillisecond", {
    enumerable: true,
    get: function() {
        return type_js_1.TimeMillisecond;
    }
});
Object.defineProperty(exports, "TimeMicrosecond", {
    enumerable: true,
    get: function() {
        return type_js_1.TimeMicrosecond;
    }
});
Object.defineProperty(exports, "TimeNanosecond", {
    enumerable: true,
    get: function() {
        return type_js_1.TimeNanosecond;
    }
});
Object.defineProperty(exports, "Decimal", {
    enumerable: true,
    get: function() {
        return type_js_1.Decimal;
    }
});
Object.defineProperty(exports, "List", {
    enumerable: true,
    get: function() {
        return type_js_1.List;
    }
});
Object.defineProperty(exports, "Struct", {
    enumerable: true,
    get: function() {
        return type_js_1.Struct;
    }
});
Object.defineProperty(exports, "Union", {
    enumerable: true,
    get: function() {
        return type_js_1.Union;
    }
});
Object.defineProperty(exports, "DenseUnion", {
    enumerable: true,
    get: function() {
        return type_js_1.DenseUnion;
    }
});
Object.defineProperty(exports, "SparseUnion", {
    enumerable: true,
    get: function() {
        return type_js_1.SparseUnion;
    }
});
Object.defineProperty(exports, "Dictionary", {
    enumerable: true,
    get: function() {
        return type_js_1.Dictionary;
    }
});
Object.defineProperty(exports, "Interval", {
    enumerable: true,
    get: function() {
        return type_js_1.Interval;
    }
});
Object.defineProperty(exports, "IntervalDayTime", {
    enumerable: true,
    get: function() {
        return type_js_1.IntervalDayTime;
    }
});
Object.defineProperty(exports, "IntervalYearMonth", {
    enumerable: true,
    get: function() {
        return type_js_1.IntervalYearMonth;
    }
});
Object.defineProperty(exports, "Duration", {
    enumerable: true,
    get: function() {
        return type_js_1.Duration;
    }
});
Object.defineProperty(exports, "DurationSecond", {
    enumerable: true,
    get: function() {
        return type_js_1.DurationSecond;
    }
});
Object.defineProperty(exports, "DurationMillisecond", {
    enumerable: true,
    get: function() {
        return type_js_1.DurationMillisecond;
    }
});
Object.defineProperty(exports, "DurationMicrosecond", {
    enumerable: true,
    get: function() {
        return type_js_1.DurationMicrosecond;
    }
});
Object.defineProperty(exports, "DurationNanosecond", {
    enumerable: true,
    get: function() {
        return type_js_1.DurationNanosecond;
    }
});
Object.defineProperty(exports, "FixedSizeList", {
    enumerable: true,
    get: function() {
        return type_js_1.FixedSizeList;
    }
});
Object.defineProperty(exports, "Map_", {
    enumerable: true,
    get: function() {
        return type_js_1.Map_;
    }
});
var table_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/table.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Table", {
    enumerable: true,
    get: function() {
        return table_js_1.Table;
    }
});
Object.defineProperty(exports, "makeTable", {
    enumerable: true,
    get: function() {
        return table_js_1.makeTable;
    }
});
Object.defineProperty(exports, "tableFromArrays", {
    enumerable: true,
    get: function() {
        return table_js_1.tableFromArrays;
    }
});
var vector_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/vector.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Vector", {
    enumerable: true,
    get: function() {
        return vector_js_1.Vector;
    }
});
Object.defineProperty(exports, "makeVector", {
    enumerable: true,
    get: function() {
        return vector_js_1.makeVector;
    }
});
var visitor_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Visitor", {
    enumerable: true,
    get: function() {
        return visitor_js_1.Visitor;
    }
});
var schema_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/schema.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Schema", {
    enumerable: true,
    get: function() {
        return schema_js_1.Schema;
    }
});
Object.defineProperty(exports, "Field", {
    enumerable: true,
    get: function() {
        return schema_js_1.Field;
    }
});
var map_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/row/map.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "MapRow", {
    enumerable: true,
    get: function() {
        return map_js_1.MapRow;
    }
});
var struct_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/row/struct.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "StructRow", {
    enumerable: true,
    get: function() {
        return struct_js_1.StructRow;
    }
});
var builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Builder", {
    enumerable: true,
    get: function() {
        return builder_js_1.Builder;
    }
});
var factories_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/factories.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "makeBuilder", {
    enumerable: true,
    get: function() {
        return factories_js_1.makeBuilder;
    }
});
Object.defineProperty(exports, "vectorFromArray", {
    enumerable: true,
    get: function() {
        return factories_js_1.vectorFromArray;
    }
});
Object.defineProperty(exports, "tableFromJSON", {
    enumerable: true,
    get: function() {
        return factories_js_1.tableFromJSON;
    }
});
Object.defineProperty(exports, "builderThroughIterable", {
    enumerable: true,
    get: function() {
        return factories_js_1.builderThroughIterable;
    }
});
Object.defineProperty(exports, "builderThroughAsyncIterable", {
    enumerable: true,
    get: function() {
        return factories_js_1.builderThroughAsyncIterable;
    }
});
var bool_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/bool.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "BoolBuilder", {
    enumerable: true,
    get: function() {
        return bool_js_1.BoolBuilder;
    }
});
var null_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/null.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "NullBuilder", {
    enumerable: true,
    get: function() {
        return null_js_1.NullBuilder;
    }
});
var date_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/date.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "DateBuilder", {
    enumerable: true,
    get: function() {
        return date_js_1.DateBuilder;
    }
});
Object.defineProperty(exports, "DateDayBuilder", {
    enumerable: true,
    get: function() {
        return date_js_1.DateDayBuilder;
    }
});
Object.defineProperty(exports, "DateMillisecondBuilder", {
    enumerable: true,
    get: function() {
        return date_js_1.DateMillisecondBuilder;
    }
});
var decimal_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/decimal.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "DecimalBuilder", {
    enumerable: true,
    get: function() {
        return decimal_js_1.DecimalBuilder;
    }
});
var dictionary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/dictionary.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "DictionaryBuilder", {
    enumerable: true,
    get: function() {
        return dictionary_js_1.DictionaryBuilder;
    }
});
var fixedsizebinary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/fixedsizebinary.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "FixedSizeBinaryBuilder", {
    enumerable: true,
    get: function() {
        return fixedsizebinary_js_1.FixedSizeBinaryBuilder;
    }
});
var float_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/float.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "FloatBuilder", {
    enumerable: true,
    get: function() {
        return float_js_1.FloatBuilder;
    }
});
Object.defineProperty(exports, "Float16Builder", {
    enumerable: true,
    get: function() {
        return float_js_1.Float16Builder;
    }
});
Object.defineProperty(exports, "Float32Builder", {
    enumerable: true,
    get: function() {
        return float_js_1.Float32Builder;
    }
});
Object.defineProperty(exports, "Float64Builder", {
    enumerable: true,
    get: function() {
        return float_js_1.Float64Builder;
    }
});
var int_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/int.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "IntBuilder", {
    enumerable: true,
    get: function() {
        return int_js_1.IntBuilder;
    }
});
Object.defineProperty(exports, "Int8Builder", {
    enumerable: true,
    get: function() {
        return int_js_1.Int8Builder;
    }
});
Object.defineProperty(exports, "Int16Builder", {
    enumerable: true,
    get: function() {
        return int_js_1.Int16Builder;
    }
});
Object.defineProperty(exports, "Int32Builder", {
    enumerable: true,
    get: function() {
        return int_js_1.Int32Builder;
    }
});
Object.defineProperty(exports, "Int64Builder", {
    enumerable: true,
    get: function() {
        return int_js_1.Int64Builder;
    }
});
Object.defineProperty(exports, "Uint8Builder", {
    enumerable: true,
    get: function() {
        return int_js_1.Uint8Builder;
    }
});
Object.defineProperty(exports, "Uint16Builder", {
    enumerable: true,
    get: function() {
        return int_js_1.Uint16Builder;
    }
});
Object.defineProperty(exports, "Uint32Builder", {
    enumerable: true,
    get: function() {
        return int_js_1.Uint32Builder;
    }
});
Object.defineProperty(exports, "Uint64Builder", {
    enumerable: true,
    get: function() {
        return int_js_1.Uint64Builder;
    }
});
var time_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/time.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "TimeBuilder", {
    enumerable: true,
    get: function() {
        return time_js_1.TimeBuilder;
    }
});
Object.defineProperty(exports, "TimeSecondBuilder", {
    enumerable: true,
    get: function() {
        return time_js_1.TimeSecondBuilder;
    }
});
Object.defineProperty(exports, "TimeMillisecondBuilder", {
    enumerable: true,
    get: function() {
        return time_js_1.TimeMillisecondBuilder;
    }
});
Object.defineProperty(exports, "TimeMicrosecondBuilder", {
    enumerable: true,
    get: function() {
        return time_js_1.TimeMicrosecondBuilder;
    }
});
Object.defineProperty(exports, "TimeNanosecondBuilder", {
    enumerable: true,
    get: function() {
        return time_js_1.TimeNanosecondBuilder;
    }
});
var timestamp_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/timestamp.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "TimestampBuilder", {
    enumerable: true,
    get: function() {
        return timestamp_js_1.TimestampBuilder;
    }
});
Object.defineProperty(exports, "TimestampSecondBuilder", {
    enumerable: true,
    get: function() {
        return timestamp_js_1.TimestampSecondBuilder;
    }
});
Object.defineProperty(exports, "TimestampMillisecondBuilder", {
    enumerable: true,
    get: function() {
        return timestamp_js_1.TimestampMillisecondBuilder;
    }
});
Object.defineProperty(exports, "TimestampMicrosecondBuilder", {
    enumerable: true,
    get: function() {
        return timestamp_js_1.TimestampMicrosecondBuilder;
    }
});
Object.defineProperty(exports, "TimestampNanosecondBuilder", {
    enumerable: true,
    get: function() {
        return timestamp_js_1.TimestampNanosecondBuilder;
    }
});
var interval_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/interval.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "IntervalBuilder", {
    enumerable: true,
    get: function() {
        return interval_js_1.IntervalBuilder;
    }
});
Object.defineProperty(exports, "IntervalDayTimeBuilder", {
    enumerable: true,
    get: function() {
        return interval_js_1.IntervalDayTimeBuilder;
    }
});
Object.defineProperty(exports, "IntervalYearMonthBuilder", {
    enumerable: true,
    get: function() {
        return interval_js_1.IntervalYearMonthBuilder;
    }
});
var duration_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/duration.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "DurationBuilder", {
    enumerable: true,
    get: function() {
        return duration_js_1.DurationBuilder;
    }
});
Object.defineProperty(exports, "DurationSecondBuilder", {
    enumerable: true,
    get: function() {
        return duration_js_1.DurationSecondBuilder;
    }
});
Object.defineProperty(exports, "DurationMillisecondBuilder", {
    enumerable: true,
    get: function() {
        return duration_js_1.DurationMillisecondBuilder;
    }
});
Object.defineProperty(exports, "DurationMicrosecondBuilder", {
    enumerable: true,
    get: function() {
        return duration_js_1.DurationMicrosecondBuilder;
    }
});
Object.defineProperty(exports, "DurationNanosecondBuilder", {
    enumerable: true,
    get: function() {
        return duration_js_1.DurationNanosecondBuilder;
    }
});
var utf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/utf8.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Utf8Builder", {
    enumerable: true,
    get: function() {
        return utf8_js_1.Utf8Builder;
    }
});
var largeutf8_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/largeutf8.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "LargeUtf8Builder", {
    enumerable: true,
    get: function() {
        return largeutf8_js_1.LargeUtf8Builder;
    }
});
var binary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/binary.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "BinaryBuilder", {
    enumerable: true,
    get: function() {
        return binary_js_1.BinaryBuilder;
    }
});
var largebinary_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/largebinary.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "LargeBinaryBuilder", {
    enumerable: true,
    get: function() {
        return largebinary_js_1.LargeBinaryBuilder;
    }
});
var list_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/list.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "ListBuilder", {
    enumerable: true,
    get: function() {
        return list_js_1.ListBuilder;
    }
});
var fixedsizelist_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/fixedsizelist.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "FixedSizeListBuilder", {
    enumerable: true,
    get: function() {
        return fixedsizelist_js_1.FixedSizeListBuilder;
    }
});
var map_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/map.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "MapBuilder", {
    enumerable: true,
    get: function() {
        return map_js_2.MapBuilder;
    }
});
var struct_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/struct.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "StructBuilder", {
    enumerable: true,
    get: function() {
        return struct_js_2.StructBuilder;
    }
});
var union_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder/union.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "UnionBuilder", {
    enumerable: true,
    get: function() {
        return union_js_1.UnionBuilder;
    }
});
Object.defineProperty(exports, "SparseUnionBuilder", {
    enumerable: true,
    get: function() {
        return union_js_1.SparseUnionBuilder;
    }
});
Object.defineProperty(exports, "DenseUnionBuilder", {
    enumerable: true,
    get: function() {
        return union_js_1.DenseUnionBuilder;
    }
});
var stream_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/stream.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "ByteStream", {
    enumerable: true,
    get: function() {
        return stream_js_1.ByteStream;
    }
});
Object.defineProperty(exports, "AsyncByteStream", {
    enumerable: true,
    get: function() {
        return stream_js_1.AsyncByteStream;
    }
});
Object.defineProperty(exports, "AsyncByteQueue", {
    enumerable: true,
    get: function() {
        return stream_js_1.AsyncByteQueue;
    }
});
var reader_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/reader.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "RecordBatchReader", {
    enumerable: true,
    get: function() {
        return reader_js_1.RecordBatchReader;
    }
});
Object.defineProperty(exports, "RecordBatchFileReader", {
    enumerable: true,
    get: function() {
        return reader_js_1.RecordBatchFileReader;
    }
});
Object.defineProperty(exports, "RecordBatchStreamReader", {
    enumerable: true,
    get: function() {
        return reader_js_1.RecordBatchStreamReader;
    }
});
Object.defineProperty(exports, "AsyncRecordBatchFileReader", {
    enumerable: true,
    get: function() {
        return reader_js_1.AsyncRecordBatchFileReader;
    }
});
Object.defineProperty(exports, "AsyncRecordBatchStreamReader", {
    enumerable: true,
    get: function() {
        return reader_js_1.AsyncRecordBatchStreamReader;
    }
});
var writer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/writer.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "RecordBatchWriter", {
    enumerable: true,
    get: function() {
        return writer_js_1.RecordBatchWriter;
    }
});
Object.defineProperty(exports, "RecordBatchFileWriter", {
    enumerable: true,
    get: function() {
        return writer_js_1.RecordBatchFileWriter;
    }
});
Object.defineProperty(exports, "RecordBatchStreamWriter", {
    enumerable: true,
    get: function() {
        return writer_js_1.RecordBatchStreamWriter;
    }
});
Object.defineProperty(exports, "RecordBatchJSONWriter", {
    enumerable: true,
    get: function() {
        return writer_js_1.RecordBatchJSONWriter;
    }
});
var serialization_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/serialization.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "tableToIPC", {
    enumerable: true,
    get: function() {
        return serialization_js_1.tableToIPC;
    }
});
Object.defineProperty(exports, "tableFromIPC", {
    enumerable: true,
    get: function() {
        return serialization_js_1.tableFromIPC;
    }
});
var message_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/message.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "MessageReader", {
    enumerable: true,
    get: function() {
        return message_js_1.MessageReader;
    }
});
Object.defineProperty(exports, "AsyncMessageReader", {
    enumerable: true,
    get: function() {
        return message_js_1.AsyncMessageReader;
    }
});
Object.defineProperty(exports, "JSONMessageReader", {
    enumerable: true,
    get: function() {
        return message_js_1.JSONMessageReader;
    }
});
var message_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/metadata/message.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Message", {
    enumerable: true,
    get: function() {
        return message_js_2.Message;
    }
});
var recordbatch_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/recordbatch.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "RecordBatch", {
    enumerable: true,
    get: function() {
        return recordbatch_js_1.RecordBatch;
    }
});
const util_bn_ = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bn.js [app-ssr] (ecmascript)");
const util_int_ = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/int.js [app-ssr] (ecmascript)");
const util_bit_ = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/bit.js [app-ssr] (ecmascript)");
const util_math_ = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/math.js [app-ssr] (ecmascript)");
const util_buffer_ = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/buffer.js [app-ssr] (ecmascript)");
const util_vector_ = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/vector.js [app-ssr] (ecmascript)");
const util_pretty_ = __turbopack_context__.r("[project]/node_modules/apache-arrow/util/pretty.js [app-ssr] (ecmascript)");
const typecomparator_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/visitor/typecomparator.js [app-ssr] (ecmascript)");
/** @ignore */ exports.util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, util_bn_), util_int_), util_bit_), util_math_), util_buffer_), util_vector_), util_pretty_), {
    compareSchemas: typecomparator_js_1.compareSchemas,
    compareFields: typecomparator_js_1.compareFields,
    compareTypes: typecomparator_js_1.compareTypes
}); //# sourceMappingURL=Arrow.js.map
}),
"[project]/node_modules/apache-arrow/Arrow.dom.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Union = exports.StructRow = exports.Struct = exports.List = exports.Decimal = exports.TimeNanosecond = exports.TimeMicrosecond = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.DateMillisecond = exports.DateDay = exports.Date_ = exports.FixedSizeBinary = exports.LargeBinary = exports.Binary = exports.LargeUtf8 = exports.Utf8 = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Bool = exports.Null = exports.DataType = exports.makeData = exports.Data = exports.BufferType = exports.UnionMode = exports.Type = exports.TimeUnit = exports.Precision = exports.MetadataVersion = exports.MessageHeader = exports.IntervalUnit = exports.DateUnit = void 0;
exports.LargeBinaryBuilder = exports.BinaryBuilder = exports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.makeBuilder = exports.Builder = exports.util = exports.RecordBatch = exports.Message = exports.JSONMessageReader = exports.AsyncMessageReader = exports.MessageReader = exports.tableToIPC = exports.tableFromIPC = exports.RecordBatchJSONWriter = exports.RecordBatchStreamWriter = exports.RecordBatchFileWriter = exports.RecordBatchWriter = exports.AsyncRecordBatchStreamReader = exports.AsyncRecordBatchFileReader = exports.RecordBatchStreamReader = exports.RecordBatchFileReader = exports.RecordBatchReader = exports.AsyncByteQueue = exports.AsyncByteStream = exports.ByteStream = exports.tableFromJSON = exports.vectorFromArray = exports.makeVector = exports.Vector = exports.Visitor = exports.Field = exports.Schema = exports.tableFromArrays = exports.makeTable = exports.Table = exports.MapRow = exports.Map_ = exports.FixedSizeList = exports.DurationNanosecond = exports.DurationMicrosecond = exports.DurationMillisecond = exports.DurationSecond = exports.Duration = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.Dictionary = exports.SparseUnion = exports.DenseUnion = void 0;
exports.LargeUtf8Builder = exports.Utf8Builder = exports.SparseUnionBuilder = exports.DenseUnionBuilder = exports.UnionBuilder = exports.TimeNanosecondBuilder = exports.TimeMicrosecondBuilder = exports.TimeMillisecondBuilder = exports.TimeSecondBuilder = exports.TimeBuilder = exports.TimestampNanosecondBuilder = exports.TimestampMicrosecondBuilder = exports.TimestampMillisecondBuilder = exports.TimestampSecondBuilder = exports.TimestampBuilder = exports.StructBuilder = exports.NullBuilder = exports.MapBuilder = exports.ListBuilder = exports.Uint64Builder = exports.Uint32Builder = exports.Uint16Builder = exports.Uint8Builder = exports.Int64Builder = exports.Int32Builder = exports.Int16Builder = exports.Int8Builder = exports.IntBuilder = exports.DurationNanosecondBuilder = exports.DurationMicrosecondBuilder = exports.DurationMillisecondBuilder = exports.DurationSecondBuilder = exports.DurationBuilder = exports.IntervalYearMonthBuilder = exports.IntervalDayTimeBuilder = exports.IntervalBuilder = exports.Float64Builder = exports.Float32Builder = exports.Float16Builder = exports.FloatBuilder = exports.FixedSizeListBuilder = exports.FixedSizeBinaryBuilder = exports.DictionaryBuilder = exports.DecimalBuilder = exports.DateMillisecondBuilder = exports.DateDayBuilder = exports.DateBuilder = exports.BoolBuilder = void 0;
const adapters_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/adapters.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const reader_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/reader.js [app-ssr] (ecmascript)");
const writer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/writer.js [app-ssr] (ecmascript)");
const iterable_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/whatwg/iterable.js [app-ssr] (ecmascript)");
const builder_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/whatwg/builder.js [app-ssr] (ecmascript)");
const reader_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/whatwg/reader.js [app-ssr] (ecmascript)");
const writer_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/whatwg/writer.js [app-ssr] (ecmascript)");
adapters_js_1.default.toDOMStream = iterable_js_1.toDOMStream;
builder_js_1.Builder['throughDOM'] = builder_js_2.builderThroughDOMStream;
reader_js_1.RecordBatchReader['throughDOM'] = reader_js_2.recordBatchReaderThroughDOMStream;
reader_js_1.RecordBatchFileReader['throughDOM'] = reader_js_2.recordBatchReaderThroughDOMStream;
reader_js_1.RecordBatchStreamReader['throughDOM'] = reader_js_2.recordBatchReaderThroughDOMStream;
writer_js_1.RecordBatchWriter['throughDOM'] = writer_js_2.recordBatchWriterThroughDOMStream;
writer_js_1.RecordBatchFileWriter['throughDOM'] = writer_js_2.recordBatchWriterThroughDOMStream;
writer_js_1.RecordBatchStreamWriter['throughDOM'] = writer_js_2.recordBatchWriterThroughDOMStream;
var Arrow_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/Arrow.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "DateUnit", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.DateUnit;
    }
});
Object.defineProperty(exports, "IntervalUnit", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.IntervalUnit;
    }
});
Object.defineProperty(exports, "MessageHeader", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.MessageHeader;
    }
});
Object.defineProperty(exports, "MetadataVersion", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.MetadataVersion;
    }
});
Object.defineProperty(exports, "Precision", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Precision;
    }
});
Object.defineProperty(exports, "TimeUnit", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.TimeUnit;
    }
});
Object.defineProperty(exports, "Type", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Type;
    }
});
Object.defineProperty(exports, "UnionMode", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.UnionMode;
    }
});
Object.defineProperty(exports, "BufferType", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.BufferType;
    }
});
Object.defineProperty(exports, "Data", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Data;
    }
});
Object.defineProperty(exports, "makeData", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.makeData;
    }
});
Object.defineProperty(exports, "DataType", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.DataType;
    }
});
Object.defineProperty(exports, "Null", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Null;
    }
});
Object.defineProperty(exports, "Bool", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Bool;
    }
});
Object.defineProperty(exports, "Int", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Int;
    }
});
Object.defineProperty(exports, "Int8", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Int8;
    }
});
Object.defineProperty(exports, "Int16", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Int16;
    }
});
Object.defineProperty(exports, "Int32", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Int32;
    }
});
Object.defineProperty(exports, "Int64", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Int64;
    }
});
Object.defineProperty(exports, "Uint8", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Uint8;
    }
});
Object.defineProperty(exports, "Uint16", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Uint16;
    }
});
Object.defineProperty(exports, "Uint32", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Uint32;
    }
});
Object.defineProperty(exports, "Uint64", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Uint64;
    }
});
Object.defineProperty(exports, "Float", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Float;
    }
});
Object.defineProperty(exports, "Float16", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Float16;
    }
});
Object.defineProperty(exports, "Float32", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Float32;
    }
});
Object.defineProperty(exports, "Float64", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Float64;
    }
});
Object.defineProperty(exports, "Utf8", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Utf8;
    }
});
Object.defineProperty(exports, "LargeUtf8", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.LargeUtf8;
    }
});
Object.defineProperty(exports, "Binary", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Binary;
    }
});
Object.defineProperty(exports, "LargeBinary", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.LargeBinary;
    }
});
Object.defineProperty(exports, "FixedSizeBinary", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.FixedSizeBinary;
    }
});
Object.defineProperty(exports, "Date_", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Date_;
    }
});
Object.defineProperty(exports, "DateDay", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.DateDay;
    }
});
Object.defineProperty(exports, "DateMillisecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.DateMillisecond;
    }
});
Object.defineProperty(exports, "Timestamp", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Timestamp;
    }
});
Object.defineProperty(exports, "TimestampSecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.TimestampSecond;
    }
});
Object.defineProperty(exports, "TimestampMillisecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.TimestampMillisecond;
    }
});
Object.defineProperty(exports, "TimestampMicrosecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.TimestampMicrosecond;
    }
});
Object.defineProperty(exports, "TimestampNanosecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.TimestampNanosecond;
    }
});
Object.defineProperty(exports, "Time", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Time;
    }
});
Object.defineProperty(exports, "TimeSecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.TimeSecond;
    }
});
Object.defineProperty(exports, "TimeMillisecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.TimeMillisecond;
    }
});
Object.defineProperty(exports, "TimeMicrosecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.TimeMicrosecond;
    }
});
Object.defineProperty(exports, "TimeNanosecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.TimeNanosecond;
    }
});
Object.defineProperty(exports, "Decimal", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Decimal;
    }
});
Object.defineProperty(exports, "List", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.List;
    }
});
Object.defineProperty(exports, "Struct", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Struct;
    }
});
Object.defineProperty(exports, "StructRow", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.StructRow;
    }
});
Object.defineProperty(exports, "Union", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Union;
    }
});
Object.defineProperty(exports, "DenseUnion", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.DenseUnion;
    }
});
Object.defineProperty(exports, "SparseUnion", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.SparseUnion;
    }
});
Object.defineProperty(exports, "Dictionary", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Dictionary;
    }
});
Object.defineProperty(exports, "Interval", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Interval;
    }
});
Object.defineProperty(exports, "IntervalDayTime", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.IntervalDayTime;
    }
});
Object.defineProperty(exports, "IntervalYearMonth", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.IntervalYearMonth;
    }
});
Object.defineProperty(exports, "Duration", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Duration;
    }
});
Object.defineProperty(exports, "DurationSecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.DurationSecond;
    }
});
Object.defineProperty(exports, "DurationMillisecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.DurationMillisecond;
    }
});
Object.defineProperty(exports, "DurationMicrosecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.DurationMicrosecond;
    }
});
Object.defineProperty(exports, "DurationNanosecond", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.DurationNanosecond;
    }
});
Object.defineProperty(exports, "FixedSizeList", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.FixedSizeList;
    }
});
Object.defineProperty(exports, "Map_", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Map_;
    }
});
Object.defineProperty(exports, "MapRow", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.MapRow;
    }
});
Object.defineProperty(exports, "Table", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Table;
    }
});
Object.defineProperty(exports, "makeTable", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.makeTable;
    }
});
Object.defineProperty(exports, "tableFromArrays", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.tableFromArrays;
    }
});
Object.defineProperty(exports, "Schema", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Schema;
    }
});
Object.defineProperty(exports, "Field", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Field;
    }
});
Object.defineProperty(exports, "Visitor", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Visitor;
    }
});
Object.defineProperty(exports, "Vector", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Vector;
    }
});
Object.defineProperty(exports, "makeVector", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.makeVector;
    }
});
Object.defineProperty(exports, "vectorFromArray", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.vectorFromArray;
    }
});
Object.defineProperty(exports, "tableFromJSON", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.tableFromJSON;
    }
});
Object.defineProperty(exports, "ByteStream", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.ByteStream;
    }
});
Object.defineProperty(exports, "AsyncByteStream", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.AsyncByteStream;
    }
});
Object.defineProperty(exports, "AsyncByteQueue", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.AsyncByteQueue;
    }
});
Object.defineProperty(exports, "RecordBatchReader", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.RecordBatchReader;
    }
});
Object.defineProperty(exports, "RecordBatchFileReader", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.RecordBatchFileReader;
    }
});
Object.defineProperty(exports, "RecordBatchStreamReader", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.RecordBatchStreamReader;
    }
});
Object.defineProperty(exports, "AsyncRecordBatchFileReader", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.AsyncRecordBatchFileReader;
    }
});
Object.defineProperty(exports, "AsyncRecordBatchStreamReader", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.AsyncRecordBatchStreamReader;
    }
});
Object.defineProperty(exports, "RecordBatchWriter", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.RecordBatchWriter;
    }
});
Object.defineProperty(exports, "RecordBatchFileWriter", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.RecordBatchFileWriter;
    }
});
Object.defineProperty(exports, "RecordBatchStreamWriter", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.RecordBatchStreamWriter;
    }
});
Object.defineProperty(exports, "RecordBatchJSONWriter", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.RecordBatchJSONWriter;
    }
});
Object.defineProperty(exports, "tableFromIPC", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.tableFromIPC;
    }
});
Object.defineProperty(exports, "tableToIPC", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.tableToIPC;
    }
});
Object.defineProperty(exports, "MessageReader", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.MessageReader;
    }
});
Object.defineProperty(exports, "AsyncMessageReader", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.AsyncMessageReader;
    }
});
Object.defineProperty(exports, "JSONMessageReader", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.JSONMessageReader;
    }
});
Object.defineProperty(exports, "Message", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Message;
    }
});
Object.defineProperty(exports, "RecordBatch", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.RecordBatch;
    }
});
Object.defineProperty(exports, "util", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.util;
    }
});
Object.defineProperty(exports, "Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.Builder;
    }
});
Object.defineProperty(exports, "makeBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.makeBuilder;
    }
});
Object.defineProperty(exports, "builderThroughIterable", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.builderThroughIterable;
    }
});
Object.defineProperty(exports, "builderThroughAsyncIterable", {
    enumerable: true,
    get: function() {
        return Arrow_js_1.builderThroughAsyncIterable;
    }
});
var Arrow_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/Arrow.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "BinaryBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.BinaryBuilder;
    }
});
Object.defineProperty(exports, "LargeBinaryBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.LargeBinaryBuilder;
    }
});
Object.defineProperty(exports, "BoolBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.BoolBuilder;
    }
});
Object.defineProperty(exports, "DateBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.DateBuilder;
    }
});
Object.defineProperty(exports, "DateDayBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.DateDayBuilder;
    }
});
Object.defineProperty(exports, "DateMillisecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.DateMillisecondBuilder;
    }
});
Object.defineProperty(exports, "DecimalBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.DecimalBuilder;
    }
});
Object.defineProperty(exports, "DictionaryBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.DictionaryBuilder;
    }
});
Object.defineProperty(exports, "FixedSizeBinaryBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.FixedSizeBinaryBuilder;
    }
});
Object.defineProperty(exports, "FixedSizeListBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.FixedSizeListBuilder;
    }
});
Object.defineProperty(exports, "FloatBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.FloatBuilder;
    }
});
Object.defineProperty(exports, "Float16Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.Float16Builder;
    }
});
Object.defineProperty(exports, "Float32Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.Float32Builder;
    }
});
Object.defineProperty(exports, "Float64Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.Float64Builder;
    }
});
Object.defineProperty(exports, "IntervalBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.IntervalBuilder;
    }
});
Object.defineProperty(exports, "IntervalDayTimeBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.IntervalDayTimeBuilder;
    }
});
Object.defineProperty(exports, "IntervalYearMonthBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.IntervalYearMonthBuilder;
    }
});
Object.defineProperty(exports, "DurationBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.DurationBuilder;
    }
});
Object.defineProperty(exports, "DurationSecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.DurationSecondBuilder;
    }
});
Object.defineProperty(exports, "DurationMillisecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.DurationMillisecondBuilder;
    }
});
Object.defineProperty(exports, "DurationMicrosecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.DurationMicrosecondBuilder;
    }
});
Object.defineProperty(exports, "DurationNanosecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.DurationNanosecondBuilder;
    }
});
Object.defineProperty(exports, "IntBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.IntBuilder;
    }
});
Object.defineProperty(exports, "Int8Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.Int8Builder;
    }
});
Object.defineProperty(exports, "Int16Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.Int16Builder;
    }
});
Object.defineProperty(exports, "Int32Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.Int32Builder;
    }
});
Object.defineProperty(exports, "Int64Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.Int64Builder;
    }
});
Object.defineProperty(exports, "Uint8Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.Uint8Builder;
    }
});
Object.defineProperty(exports, "Uint16Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.Uint16Builder;
    }
});
Object.defineProperty(exports, "Uint32Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.Uint32Builder;
    }
});
Object.defineProperty(exports, "Uint64Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.Uint64Builder;
    }
});
Object.defineProperty(exports, "ListBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.ListBuilder;
    }
});
Object.defineProperty(exports, "MapBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.MapBuilder;
    }
});
Object.defineProperty(exports, "NullBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.NullBuilder;
    }
});
Object.defineProperty(exports, "StructBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.StructBuilder;
    }
});
Object.defineProperty(exports, "TimestampBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.TimestampBuilder;
    }
});
Object.defineProperty(exports, "TimestampSecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.TimestampSecondBuilder;
    }
});
Object.defineProperty(exports, "TimestampMillisecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.TimestampMillisecondBuilder;
    }
});
Object.defineProperty(exports, "TimestampMicrosecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.TimestampMicrosecondBuilder;
    }
});
Object.defineProperty(exports, "TimestampNanosecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.TimestampNanosecondBuilder;
    }
});
Object.defineProperty(exports, "TimeBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.TimeBuilder;
    }
});
Object.defineProperty(exports, "TimeSecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.TimeSecondBuilder;
    }
});
Object.defineProperty(exports, "TimeMillisecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.TimeMillisecondBuilder;
    }
});
Object.defineProperty(exports, "TimeMicrosecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.TimeMicrosecondBuilder;
    }
});
Object.defineProperty(exports, "TimeNanosecondBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.TimeNanosecondBuilder;
    }
});
Object.defineProperty(exports, "UnionBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.UnionBuilder;
    }
});
Object.defineProperty(exports, "DenseUnionBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.DenseUnionBuilder;
    }
});
Object.defineProperty(exports, "SparseUnionBuilder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.SparseUnionBuilder;
    }
});
Object.defineProperty(exports, "Utf8Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.Utf8Builder;
    }
});
Object.defineProperty(exports, "LargeUtf8Builder", {
    enumerable: true,
    get: function() {
        return Arrow_js_2.LargeUtf8Builder;
    }
}); //# sourceMappingURL=Arrow.dom.js.map
}),
"[project]/node_modules/apache-arrow/Arrow.node.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-ssr] (ecmascript)");
const adapters_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/adapters.js [app-ssr] (ecmascript)");
const builder_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/builder.js [app-ssr] (ecmascript)");
const reader_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/reader.js [app-ssr] (ecmascript)");
const writer_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/ipc/writer.js [app-ssr] (ecmascript)");
const iterable_js_1 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/node/iterable.js [app-ssr] (ecmascript)");
const builder_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/node/builder.js [app-ssr] (ecmascript)");
const reader_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/node/reader.js [app-ssr] (ecmascript)");
const writer_js_2 = __turbopack_context__.r("[project]/node_modules/apache-arrow/io/node/writer.js [app-ssr] (ecmascript)");
adapters_js_1.default.toNodeStream = iterable_js_1.toNodeStream;
builder_js_1.Builder['throughNode'] = builder_js_2.builderThroughNodeStream;
reader_js_1.RecordBatchReader['throughNode'] = reader_js_2.recordBatchReaderThroughNodeStream;
writer_js_1.RecordBatchWriter['throughNode'] = writer_js_2.recordBatchWriterThroughNodeStream;
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/apache-arrow/Arrow.dom.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=Arrow.node.js.map
}),
];

//# sourceMappingURL=node_modules_apache-arrow_38fe8aa1._.js.map