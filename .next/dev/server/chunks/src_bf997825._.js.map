{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///home/danudenny/Downloads/geogreen-mapper/src/lib/prisma.ts"],"sourcesContent":["import { PrismaPg } from '@prisma/adapter-pg';\nimport { Pool } from 'pg';\nimport { PrismaClient } from '../generated/prisma';\n\nconst prismaClientSingleton = () => {\n    const connectionString = process.env.DATABASE_URL;\n    const pool = new Pool({ connectionString });\n    const adapter = new PrismaPg(pool);\n\n    return new PrismaClient({ adapter });\n};\n\ndeclare global {\n    var prisma: undefined | ReturnType<typeof prismaClientSingleton>;\n}\n\nconst prisma = globalThis.prisma ?? prismaClientSingleton();\n\nexport default prisma;\n\nif (process.env.NODE_ENV !== 'production') globalThis.prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;;AAEA,MAAM,wBAAwB;IAC1B,MAAM,mBAAmB,QAAQ,GAAG,CAAC,YAAY;IACjD,MAAM,OAAO,IAAI,4GAAI,CAAC;QAAE;IAAiB;IACzC,MAAM,UAAU,IAAI,yKAAQ,CAAC;IAE7B,OAAO,IAAI,qJAAY,CAAC;QAAE;IAAQ;AACtC;AAMA,MAAM,SAAS,WAAW,MAAM,IAAI;uCAErB;AAEf,wCAA2C,WAAW,MAAM,GAAG"}},
    {"offset": {"line": 41, "column": 0}, "map": {"version":3,"sources":["file:///home/danudenny/Downloads/geogreen-mapper/src/app/api/analyze/route.ts"],"sourcesContent":["import prisma from '@/lib/prisma';\nimport { NextRequest, NextResponse } from 'next/server';\n\nconst TABLE_MAP: Record<string, { table: string; type: string }> = {\n    rtrw: { table: 'public.pola_ruang_revisi_rtrw', type: 'Polygon' },\n    badau: { table: 'public.pola_ruang_badau', type: 'Polygon' },\n    geopark: { table: 'public.pola_ruang_geopark', type: 'Polygon' },\n    tanjung: {\n        table: 'public.pola_ruang_tanjung_kelayang',\n        type: 'Polygon',\n    },\n    'badau-net': {\n        table: 'public.jaringan_struktur_ruang_badau',\n        type: 'LineString',\n    },\n    'geopark-net': {\n        table: 'public.jaringan_struktur_ruang_geopark',\n        type: 'LineString',\n    },\n    'tanjung-net': {\n        table: 'public.jaringan_struktur_ruang_tanjung_kelayang',\n        type: 'LineString',\n    },\n    'badau-infra': {\n        table: 'public.infrastruktur_struktur_ruang_badau',\n        type: 'Point',\n    },\n    'geopark-infra': {\n        table: 'public.infrastruktur_struktur_ruang_geopark',\n        type: 'Point',\n    },\n    'tanjung-infra': {\n        table: 'public.infrastruktur_struktur_ruang_tanjung_kelayang',\n        type: 'Point',\n    },\n};\n\nexport async function POST(req: NextRequest) {\n    try {\n        const body = await req.json();\n        const { geometry, layer = 'rtrw' } = body;\n\n        if (!geometry) {\n            return new NextResponse('Missing geometry', { status: 400 });\n        }\n\n        const targetLayer = TABLE_MAP[layer];\n        if (!targetLayer) {\n            return new NextResponse('Invalid layer', { status: 400 });\n        }\n\n        const geojsonString = JSON.stringify(geometry);\n\n        let sql = '';\n        let resultUnit = '';\n\n        // Determine analysis type based on Target Layer Geometry Type\n        // If Target is Polygon -> Calculate Area (Ha)\n        // If Target is LineString -> Calculate Length (km)\n        // If Target is Point -> Calculate Count (items)\n\n        if (targetLayer.type === 'Polygon') {\n            resultUnit = 'Ha';\n            sql = `\n                WITH input_geom AS (\n                    SELECT ST_SetSRID(ST_GeomFromGeoJSON($1), 4326) as geom\n                ),\n                input_transformed AS (\n                    SELECT ST_Transform(geom, 3857) as geom FROM input_geom\n                ),\n                intersection_calc AS (\n                    SELECT\n                        t.namobj as category,\n                        ST_Area(ST_Intersection(ST_Force2D(ST_Transform(t.geom, 3857)), i.geom)) as area_sqm\n                    FROM ${targetLayer.table} t, input_transformed i\n                    WHERE ST_Intersects(ST_Force2D(ST_Transform(t.geom, 3857)), i.geom)\n                )\n                SELECT\n                    category,\n                    SUM(area_sqm) as value\n                FROM intersection_calc\n                GROUP BY category\n                ORDER BY value DESC;\n            `;\n        } else if (targetLayer.type === 'LineString') {\n            resultUnit = 'm'; // will convert to km in frontend if needed, or here. Let's send meters.\n            sql = `\n                WITH input_geom AS (\n                    SELECT ST_SetSRID(ST_GeomFromGeoJSON($1), 4326) as geom\n                ),\n                input_transformed AS (\n                    SELECT ST_Transform(geom, 3857) as geom FROM input_geom\n                ),\n                intersection_calc AS (\n                    SELECT\n                        t.namobj as category,\n                        ST_Length(ST_Intersection(ST_Force2D(ST_Transform(t.geom, 3857)), i.geom)) as length_m\n                    FROM ${targetLayer.table} t, input_transformed i\n                    WHERE ST_Intersects(ST_Force2D(ST_Transform(t.geom, 3857)), i.geom)\n                )\n                SELECT\n                    category,\n                    SUM(length_m) as value\n                FROM intersection_calc\n                GROUP BY category\n                ORDER BY value DESC;\n            `;\n        } else if (targetLayer.type === 'Point') {\n            resultUnit = 'items';\n            sql = `\n                WITH input_geom AS (\n                    SELECT ST_SetSRID(ST_GeomFromGeoJSON($1), 4326) as geom\n                ),\n                input_transformed AS (\n                    SELECT ST_Transform(geom, 3857) as geom FROM input_geom\n                )\n                SELECT\n                    t.namobj as category,\n                    COUNT(*) as value\n                FROM ${targetLayer.table} t, input_transformed i\n                WHERE ST_Intersects(ST_Force2D(ST_Transform(t.geom, 3857)), i.geom)\n                GROUP BY category\n                ORDER BY value DESC;\n            `;\n        }\n\n        const result = await prisma.$queryRawUnsafe(sql, geojsonString);\n\n        // Process results\n        const rows = result as any[];\n        const totalValue = rows.reduce(\n            (sum, row) => sum + Number(row.value),\n            0\n        );\n\n        const stats = rows.map((row) => {\n            const val = Number(row.value);\n            // Conversion for display based on unit\n            let displayValue = val;\n            if (resultUnit === 'Ha') displayValue = val / 10000; // sqm to Ha\n            if (resultUnit === 'm') displayValue = val / 1000; // meters to km? Or keep meters. Let's doing KM conversion here to align with Ha logic\n            // Actually, let's keep raw value in 'areaHa' field for compatibility OR add new field.\n            // To minimize frontend breakage, let's map 'value' to 'areaHa' but strictly speaking it's \"value\"\n\n            return {\n                category: row.category,\n                areaHa: resultUnit === 'Ha' ? val / 10000 : val, // overloaded field for now, or add value field\n                value: val, // raw value\n                unit: resultUnit === 'm' ? 'km' : resultUnit, // if m, let's say it's meters, but for 'Ha' we converted.\n                // Let's standardize: 'value' is the metric.\n                // For Ha: value = sqm / 10000\n                // For km: value = m / 1000\n                // For items: value = count\n                percentage: totalValue > 0 ? (val / totalValue) * 100 : 0,\n            };\n        });\n\n        // Refine the unit/value logic\n        // If Polygon -> val is sqm, return Ha\n        // If Line -> val is m, return km?\n        // Let's do consistent returns.\n        const finalStats = rows.map((row) => {\n            const rawVal = Number(row.value);\n            let finalVal = rawVal;\n            let finalUnit = resultUnit;\n\n            if (resultUnit === 'Ha') {\n                finalVal = rawVal / 10000;\n            } else if (resultUnit === 'm') {\n                finalVal = rawVal / 1000;\n                finalUnit = 'km';\n            }\n\n            return {\n                category: row.category,\n                areaHa: finalVal, // Keep compatibility with frontend which expects 'areaHa' for pie chart value\n                percentage: totalValue > 0 ? (rawVal / totalValue) * 100 : 0,\n                unit: finalUnit,\n            };\n        });\n\n        return new NextResponse(JSON.stringify(finalStats), {\n            headers: { 'Content-Type': 'application/json' },\n        });\n    } catch (error) {\n        console.error('Analysis error:', error);\n        return new NextResponse(JSON.stringify({ error: String(error) }), {\n            status: 500,\n        });\n    }\n}\n"],"names":[],"mappings":"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"}}]
}